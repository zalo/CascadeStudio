{
  "version": 3,
  "sources": ["../../../../node_modules/openscad-parser/src/CodeSpan.ts", "../../../../node_modules/openscad-parser/src/ast/ASTNode.ts", "../../../../node_modules/openscad-parser/src/ast/ErrorNode.ts", "../../../../node_modules/openscad-parser/src/ASTAssembler.ts", "../../../../node_modules/openscad-parser/src/ast/ScadFile.ts", "../../../../node_modules/openscad-parser/src/ast/expressions.ts", "../../../../node_modules/openscad-parser/src/ast/statements.ts", "../../../../node_modules/openscad-parser/src/semantic/nodesWithScopes.ts", "../../../../node_modules/openscad-parser/src/ast/AssignmentNode.ts", "../../../../node_modules/openscad-parser/src/ASTMutator.ts", "../../../../node_modules/openscad-parser/src/extraTokens.ts", "../../../../node_modules/openscad-parser/src/TokenType.ts", "../../../../node_modules/openscad-parser/src/Token.ts", "../../../../node_modules/openscad-parser/src/ASTPinpointer.ts", "../../../../node_modules/openscad-parser/src/ASTPrinter.ts", "../../scripts/node-shims.cjs", "../../../../node_modules/openscad-parser/src/CodeFile.ts", "../../../../node_modules/openscad-parser/src/CodeLocation.ts", "../../../../node_modules/openscad-parser/src/ErrorCollector.ts", "../../../../node_modules/openscad-parser/src/FormattingConfiguration.ts", "../../../../node_modules/openscad-parser/src/errors/CodeError.ts", "../../../../node_modules/openscad-parser/src/errors/LexingError.ts", "../../../../node_modules/openscad-parser/src/errors/lexingErrors.ts", "../../../../node_modules/openscad-parser/src/keywords.ts", "../../../../node_modules/openscad-parser/src/LiteralToken.ts", "../../../../node_modules/openscad-parser/src/Lexer.ts", "../../../../node_modules/openscad-parser/src/comments/annotations.ts", "../../../../node_modules/openscad-parser/src/comments/DocComment.ts", "../../../../node_modules/openscad-parser/src/errors/ParsingError.ts", "../../../../node_modules/openscad-parser/src/friendlyTokenNames.ts", "../../../../node_modules/openscad-parser/src/errors/parsingErrors.ts", "../../../../node_modules/openscad-parser/src/Parser.ts", "../../../../node_modules/openscad-parser/src/ParsingHelper.ts", "../../../../node_modules/openscad-parser/src/semantic/Scope.ts", "../../../../node_modules/openscad-parser/src/semantic/ASTScopePopulator.ts", "../../../../node_modules/openscad-parser/src/prelude/PreludeUtil.ts", "../../../../node_modules/openscad-parser/src/semantic/ASTSymbolLister.ts", "../../../../node_modules/openscad-parser/src/semantic/CompletionSymbol.ts", "../../../../node_modules/openscad-parser/src/semantic/CompletionType.ts", "../../../../node_modules/openscad-parser/src/semantic/IncludeResolver.ts", "../../../../node_modules/openscad-parser/src/semantic/FilenameCompletionProvider.ts", "../../../../node_modules/openscad-parser/src/semantic/KeywordsCompletionProvider.ts", "../../../../node_modules/openscad-parser/src/semantic/ScopeSymbolCompletionProvider.ts", "../../../../node_modules/openscad-parser/src/semantic/CompletionUtil.ts", "../../../../node_modules/openscad-parser/src/semantic/resolvedNodes.ts", "../../../../node_modules/openscad-parser/src/semantic/unresolvedSymbolErrors.ts", "../../../../node_modules/openscad-parser/src/semantic/SymbolResolver.ts", "../../../../node_modules/openscad-parser/src/SolutionManager.ts", "../../../../node_modules/openscad-parser/dist/ast/ASTVisitor.js", "../../../../node_modules/openscad-parser/dist/comments/DocAnnotationClass.js", "../../../../node_modules/openscad-parser/dist/semantic/CompletionProvider.js", "../../../../node_modules/openscad-parser/dist/semantic/NodeWithScope.js", "../../../../node_modules/openscad-parser/dist/semantic/ScadFileProvider.js", "../../../../node_modules/openscad-parser/src/index.ts"],
  "sourcesContent": ["import CodeLocation from \"./CodeLocation\";\n\nexport default class CodeSpan {\n  constructor(public start: CodeLocation, public end: CodeLocation) {}\n\n  toString() {\n    return `${this.start.toString()} - ${this.end.toString()}`;\n  }\n\n  static combine(...rawSpans: (CodeSpan | null | undefined)[]) {\n    let spans = rawSpans.filter((s) => s != null) as CodeSpan[];\n    if (spans.length === 0) {\n      throw new Error(\"Cannot combine zero spans\");\n    }\n    if (spans.length === 1) {\n      return spans[0];\n    }\n    let min: CodeSpan = spans[0];\n    let max: CodeSpan = spans[0];\n    for (let span of spans) {\n      if (span.start.char < min.start.char) {\n        min = span;\n      }\n      if (span.end.char > max.end.char) {\n        max = span;\n      }\n    }\n    return new CodeSpan(min.start, max.end);\n  }\n\n  static combineObject(spans: { [key: string]: CodeSpan }) {\n    return CodeSpan.combine(...Object.values(spans));\n  }\n}\n", "import CodeLocation from \"../CodeLocation\";\nimport CodeSpan from \"../CodeSpan\";\nimport Token from \"../Token\";\nimport ASTVisitor from \"./ASTVisitor\";\n\n/**\n * @category AST\n */\nexport default abstract class ASTNode {\n  constructor() {}\n\n  abstract tokens: { [key: string]: Token | Token[] | null };\n\n  abstract accept<R>(visitor: ASTVisitor<R>): R;\n\n  get span(): CodeSpan {\n    return CodeSpan.combine(...Object.values(this.tokens).flat().map((t) => t?.span));\n  }\n}\n", "import CodeLocation from \"../CodeLocation\";\nimport Token from \"../Token\";\nimport ASTNode from \"./ASTNode\";\nimport ASTVisitor from \"./ASTVisitor\";\n\n/**\n * Is put into the AST after it failed to parse something. Such an AST is invalid, and an error must have been generated.\n * It is generated during synchronisation, which occurs on every statement, but you should expect it everywhere when handling the AST.\n * @category AST\n */\nexport default class ErrorNode extends ASTNode {\n  constructor(\n    public tokens: {\n      tokens: Token[];\n    }\n  ) {\n    super();\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitErrorNode(this);\n  }\n}\n", "import AssignmentNode from \"./ast/AssignmentNode\";\nimport ASTNode from \"./ast/ASTNode\";\nimport ASTVisitor from \"./ast/ASTVisitor\";\nimport ErrorNode from \"./ast/ErrorNode\";\nimport {\n  AnonymousFunctionExpr,\n  ArrayLookupExpr,\n  AssertExpr,\n  BinaryOpExpr,\n  EchoExpr,\n  FunctionCallExpr,\n  GroupingExpr,\n  LcEachExpr,\n  LcForCExpr,\n  LcForExpr,\n  LcIfExpr,\n  LcLetExpr,\n  LetExpr,\n  LiteralExpr,\n  LookupExpr,\n  MemberLookupExpr,\n  RangeExpr,\n  TernaryExpr,\n  UnaryOpExpr,\n  VectorExpr,\n} from \"./ast/expressions\";\nimport ScadFile from \"./ast/ScadFile\";\nimport {\n  BlockStmt,\n  FunctionDeclarationStmt,\n  IfElseStatement,\n  IncludeStmt,\n  ModuleDeclarationStmt,\n  ModuleInstantiationStmt,\n  NoopStmt,\n  UseStmt,\n} from \"./ast/statements\";\nimport Token from \"./Token\";\n\n/**\n * This class walks through the AST and generates arrays of tokens and function, which themselves return the same array.\n * It can be used to search through the AST, or determine the ranges of AST nodes.\n */\nexport default abstract class ASTAssembler<R> implements ASTVisitor<R> {\n  protected abstract processAssembledNode(\n    t: (Token | (() => R))[],\n    self: ASTNode\n  ): R;\n  visitScadFile(n: ScadFile): R {\n    return this.processAssembledNode(\n      [...n.statements.map((stmt) => () => stmt.accept(this)), n.tokens.eot],\n      n\n    );\n  }\n  visitAssignmentNode(n: AssignmentNode): R {\n    const arr: (Token | (() => R))[] = [];\n    if (n.tokens.name) {\n      arr.push(n.tokens.name);\n    }\n    if (n.tokens.equals) {\n      arr.push(n.tokens.equals);\n    }\n    if (n.value) {\n      // n.value won't be modified, so we can assert it is not null\n      arr.push(() => n.value!.accept(this));\n    }\n    if (n.tokens.trailingCommas) {\n      arr.push(...n.tokens.trailingCommas);\n    }\n    if (n.tokens.semicolon) {\n      arr.push(n.tokens.semicolon);\n    }\n    return this.processAssembledNode(arr, n);\n  }\n  visitUnaryOpExpr(n: UnaryOpExpr): R {\n    return this.processAssembledNode(\n      [n.tokens.operator, () => n.right.accept(this)],\n      n\n    );\n  }\n  visitBinaryOpExpr(n: BinaryOpExpr): R {\n    return this.processAssembledNode(\n      [\n        () => n.left.accept(this),\n        n.tokens.operator,\n        () => n.right.accept(this),\n      ],\n      n\n    );\n  }\n  visitTernaryExpr(n: TernaryExpr): R {\n    return this.processAssembledNode(\n      [\n        () => n.cond.accept(this),\n        n.tokens.questionMark,\n        () => n.ifExpr.accept(this),\n        n.tokens.colon,\n        () => n.elseExpr.accept(this),\n      ],\n      n\n    );\n  }\n  visitArrayLookupExpr(n: ArrayLookupExpr): R {\n    return this.processAssembledNode(\n      [\n        () => n.array.accept(this),\n        n.tokens.firstBracket,\n        () => n.index.accept(this),\n        n.tokens.secondBracket,\n      ],\n      n\n    );\n  }\n  visitLiteralExpr(n: LiteralExpr<any>): R {\n    return this.processAssembledNode([n.tokens.literalToken], n);\n  }\n  visitRangeExpr(n: RangeExpr): R {\n    if (n.step && n.tokens.secondColon) {\n      let parts = [() => n.begin.accept(this), n.tokens.firstColon];\n      if (n.step) {\n        parts.push(() => n!.step!.accept(this));\n      }\n\n      parts.push(n.tokens.secondColon, () => n.end.accept(this));\n      return this.processAssembledNode(parts, n);\n    }\n    return this.processAssembledNode(\n      [\n        () => n.begin.accept(this),\n        n.tokens.firstColon,\n        () => n.end.accept(this),\n      ],\n      n\n    );\n  }\n  visitVectorExpr(n: VectorExpr): R {\n    const arr = [];\n    arr.push(n.tokens.firstBracket);\n    for (let i = 0; i < n.children.length; i++) {\n      arr.push(() => n.children[i].accept(this));\n      if (i < n.children.length - 1) {\n        arr.push(n.tokens.commas[i]);\n      }\n    }\n    arr.push(...n.tokens.commas.slice(n.children.length));\n    arr.push(n.tokens.secondBracket);\n    return this.processAssembledNode(arr, n);\n  }\n  visitLookupExpr(n: LookupExpr): R {\n    return this.processAssembledNode([n.tokens.identifier], n);\n  }\n  visitMemberLookupExpr(n: MemberLookupExpr): R {\n    return this.processAssembledNode(\n      [() => n.expr.accept(this), n.tokens.dot, n.tokens.memberName],\n      n\n    );\n  }\n  visitFunctionCallExpr(n: FunctionCallExpr): R {\n    return this.processAssembledNode(\n      [\n        () => n.callee.accept(this),\n        n.tokens.firstParen,\n        ...n.args.map((a) => () => a.accept(this)),\n        n.tokens.secondParen,\n      ],\n      n\n    );\n  }\n  visitLetExpr(n: LetExpr): R {\n    return this.processAssembledNode(\n      [\n        n.tokens.name,\n        n.tokens.firstParen,\n        ...n.args.map((a) => () => a.accept(this)),\n        n.tokens.secondParen,\n      ],\n      n\n    );\n  }\n  visitAssertExpr(n: AssertExpr): R {\n    return this.processAssembledNode(\n      [\n        n.tokens.name,\n        n.tokens.firstParen,\n        ...n.args.map((a) => () => a.accept(this)),\n        n.tokens.secondParen,\n      ],\n      n\n    );\n  }\n  visitEchoExpr(n: EchoExpr): R {\n    return this.processAssembledNode(\n      [\n        n.tokens.name,\n        n.tokens.firstParen,\n        ...n.args.map((a) => () => a.accept(this)),\n        n.tokens.secondParen,\n      ],\n      n\n    );\n  }\n  visitLcIfExpr(n: LcIfExpr): R {\n    const elseStuff: (Token | (() => R))[] = [];\n    if (n.elseExpr && n.tokens.elseKeyword) {\n      elseStuff.push(n.tokens.elseKeyword, () => n.elseExpr!.accept(this));\n    }\n    return this.processAssembledNode(\n      [\n        n.tokens.ifKeyword,\n        n.tokens.firstParen,\n        () => n.cond.accept(this),\n        n.tokens.secondParen,\n        () => n.ifExpr.accept(this),\n        ...elseStuff,\n      ],\n      n\n    );\n  }\n  visitLcEachExpr(n: LcEachExpr): R {\n    return this.processAssembledNode(\n      [n.tokens.eachKeyword, () => n.expr.accept(this)],\n      n\n    );\n  }\n  visitLcForExpr(n: LcForExpr): R {\n    return this.processAssembledNode(\n      [\n        n.tokens.forKeyword,\n        n.tokens.firstParen,\n        ...n.args.map((a) => () => a.accept(this)),\n        n.tokens.secondParen,\n        () => n.expr.accept(this),\n      ],\n      n\n    );\n  }\n  visitLcForCExpr(n: LcForCExpr): R {\n    return this.processAssembledNode(\n      [\n        n.tokens.forKeyword,\n        n.tokens.firstParen,\n        ...n.args.map((a) => () => a.accept(this)),\n        n.tokens.firstSemicolon,\n        () => n.cond.accept(this),\n        n.tokens.secondSemicolon,\n        ...n.incrArgs.map((a) => () => a.accept(this)),\n        n.tokens.secondParen,\n        () => n.expr.accept(this),\n      ],\n      n\n    );\n  }\n  visitLcLetExpr(n: LcLetExpr): R {\n    return this.processAssembledNode(\n      [\n        n.tokens.letKeyword,\n        n.tokens.firstParen,\n        ...n.args.map((a) => () => a.accept(this)),\n        n.tokens.secondParen,\n        () => n.expr.accept(this),\n      ],\n      n\n    );\n  }\n  visitGroupingExpr(n: GroupingExpr): R {\n    return this.processAssembledNode(\n      [n.tokens.firstParen, () => n.inner.accept(this), n.tokens.secondParen],\n      n\n    );\n  }\n  visitUseStmt(n: UseStmt): R {\n    return this.processAssembledNode(\n      [n.tokens.useKeyword, n.tokens.filename],\n      n\n    );\n  }\n\n  visitIncludeStmt(n: IncludeStmt): R {\n    return this.processAssembledNode(\n      [n.tokens.includeKeyword, n.tokens.filename],\n      n\n    );\n  }\n  visitModuleInstantiationStmt(n: ModuleInstantiationStmt): R {\n    const arr = [];\n    arr.push(...n.tokens.modifiersInOrder);\n    arr.push(n.tokens.name);\n    arr.push(n.tokens.firstParen);\n    arr.push(...n.args.map((a) => () => a.accept(this)));\n    arr.push(n.tokens.secondParen);\n    if (\n      n.child &&\n      !(n.child instanceof ErrorNode && n.child.tokens.tokens.length === 0) // omit zero-width error nodes since they contribute nothing.\n    ) {\n      arr.push(() => n.child!.accept(this));\n    }\n\n    return this.processAssembledNode(arr, n);\n  }\n  visitModuleDeclarationStmt(n: ModuleDeclarationStmt): R {\n    return this.processAssembledNode(\n      [\n        n.tokens.moduleKeyword,\n        n.tokens.name,\n        n.tokens.firstParen,\n        ...n.definitionArgs.map((a) => () => a.accept(this)),\n        n.tokens.secondParen,\n        () => n.stmt.accept(this),\n      ],\n      n\n    );\n  }\n  visitFunctionDeclarationStmt(n: FunctionDeclarationStmt): R {\n    return this.processAssembledNode(\n      [\n        n.tokens.functionKeyword,\n        n.tokens.name,\n        n.tokens.firstParen,\n        ...n.definitionArgs.map((a) => () => a.accept(this)),\n        n.tokens.secondParen,\n        () => n.expr.accept(this),\n        n.tokens.semicolon,\n      ],\n      n\n    );\n  }\n  visitBlockStmt(n: BlockStmt): R {\n    return this.processAssembledNode(\n      [\n        n.tokens.firstBrace,\n        ...n.children.map((a) => () => a.accept(this)),\n        n.tokens.secondBrace,\n      ],\n      n\n    );\n  }\n  visitNoopStmt(n: NoopStmt): R {\n    return this.processAssembledNode([n.tokens.semicolon], n);\n  }\n  visitIfElseStatement(n: IfElseStatement): R {\n    const arr = [];\n    arr.push(...n.tokens.modifiersInOrder);\n    arr.push(n.tokens.ifKeyword);\n    arr.push(n.tokens.firstParen);\n    arr.push(() => n.cond.accept(this));\n    arr.push(n.tokens.secondParen);\n    arr.push(() => n.thenBranch.accept(this));\n    if (n.elseBranch) {\n      arr.push(n!.tokens!.elseKeyword!, () => n!.elseBranch!.accept(this));\n    }\n    return this.processAssembledNode(arr, n);\n  }\n  visitAnonymousFunctionExpr(n: AnonymousFunctionExpr): R {\n    return this.processAssembledNode(\n      [\n        n.tokens.functionKeyword,\n        n.tokens.firstParen,\n        ...n.definitionArgs.map((a) => () => a.accept(this)),\n        n.tokens.secondParen,\n        () => n.expr.accept(this),\n      ],\n      n\n    );\n  }\n  visitErrorNode(n: ErrorNode): R {\n    return this.processAssembledNode([...n.tokens.tokens], n);\n  }\n}\n", "import CodeLocation from \"../CodeLocation\";\nimport Token from \"../Token\";\nimport ASTNode from \"./ASTNode\";\nimport ASTVisitor from \"./ASTVisitor\";\nimport { Statement } from \"./statements\";\n\n/**\n * The root node of any AST tree.\n *\n * Contains top-level statements including the use statements.\n *\n * @category AST\n */\nexport default class ScadFile extends ASTNode {\n  constructor(\n    public statements: Statement[],\n    public tokens: {\n      eot: Token;\n    }\n  ) {\n    super();\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitScadFile(this);\n  }\n}\n", "import CodeLocation from \"../CodeLocation\";\nimport LiteralToken from \"../LiteralToken\";\nimport Token from \"../Token\";\nimport TokenType from \"../TokenType\";\nimport AssignmentNode from \"./AssignmentNode\";\nimport ASTNode from \"./ASTNode\";\nimport ASTVisitor from \"./ASTVisitor\";\n\nexport abstract class Expression extends ASTNode {}\n\n/**\n * Represents an unary expression (!right, -right)\n * @category AST\n */\nexport class UnaryOpExpr extends Expression {\n  /**\n   * The operation of this unary expression.\n   */\n  operation: TokenType;\n\n  /**\n   * The expression on which the operation is performed.\n   */\n  right: Expression;\n\n  constructor(\n    op: TokenType,\n    right: Expression,\n    public tokens: { operator: Token }\n  ) {\n    super();\n    this.operation = op;\n    this.right = right;\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitUnaryOpExpr(this);\n  }\n}\n\n/**\n * Represents a binary expression (LogicalAnd, LogicalOr, Multiply, Divide, Modulo, Plus, Minus, Less, LessEqual, Greater, GreaterEqual, Equal, NotEqual).\n * @category AST\n */\nexport class BinaryOpExpr extends Expression {\n  /**\n   * The left side of the operation.\n   */\n  left: Expression;\n\n  /**\n   * The type of the operation performed.\n   */\n  operation: TokenType;\n\n  /**\n   * The right side of the operation\n   */\n  right: Expression;\n\n  constructor(\n    left: Expression,\n    operation: TokenType,\n    right: Expression,\n    public tokens: { operator: Token }\n  ) {\n    super();\n    this.left = left;\n    this.operation = operation;\n    this.right = right;\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitBinaryOpExpr(this);\n  }\n}\n\n/**\n * Represents a ternary expression (cond ? ifexpr : elsexpr)\n * @category AST\n */\nexport class TernaryExpr extends Expression {\n  cond: Expression;\n  ifExpr: Expression;\n  elseExpr: Expression;\n  constructor(\n    cond: Expression,\n    ifExpr: Expression,\n    elseExpr: Expression,\n    public tokens: {\n      questionMark: Token;\n      colon: Token;\n    }\n  ) {\n    super();\n    this.cond = cond;\n    this.ifExpr = ifExpr;\n    this.elseExpr = elseExpr;\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitTernaryExpr(this);\n  }\n}\n\n/**\n * Represents a lookup operation on an array (indexing). Example: arr[5]\n * @category AST\n */\nexport class ArrayLookupExpr extends Expression {\n  /**\n   * The array being indexed.\n   */\n  array: Expression;\n\n  /**\n   * The index which is being looked up.\n   */\n  index: Expression;\n\n  constructor(\n    array: Expression,\n    index: Expression,\n    public tokens: {\n      firstBracket: Token;\n      secondBracket: Token;\n    }\n  ) {\n    super();\n    this.array = array;\n    this.index = index;\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitArrayLookupExpr(this);\n  }\n}\n\n/**\n * A literal expression (just a simple number, string or a boolean)\n * @category AST\n */\nexport class LiteralExpr<TValue> extends Expression {\n  value: TValue;\n\n  constructor(\n    value: TValue,\n    public tokens: {\n      literalToken: LiteralToken<TValue>;\n    }\n  ) {\n    super();\n    this.value = value;\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitLiteralExpr(this);\n  }\n}\n\n/**\n * A range epxression. Example: [0: 1 :20]\n * @category AST\n */\nexport class RangeExpr extends Expression {\n  begin: Expression;\n  /**\n   * The optional step expression.\n   * It defaults to 1 if not specified.\n   */\n  step: Expression | null;\n  end: Expression;\n  constructor(\n    begin: Expression,\n    step: Expression | null,\n    end: Expression,\n    public tokens: {\n      firstBracket: Token;\n      firstColon: Token;\n      secondColon: Token | null;\n      secondBracket: Token;\n    }\n  ) {\n    super();\n    this.begin = begin;\n    this.step = step;\n    this.end = end;\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitRangeExpr(this);\n  }\n}\n\n/**\n * A vector literal expression. Example: [1, 2, 3, 4]\n * @category AST\n */\nexport class VectorExpr extends Expression {\n  children: Expression[];\n  constructor(\n    children: Expression[],\n    public tokens: {\n      firstBracket: Token;\n      commas: Token[];\n      secondBracket: Token;\n    }\n  ) {\n    super();\n    this.children = children;\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitVectorExpr(this);\n  }\n}\n\n/**\n * A lookup expression, it references a variable, module or function by name.\n * @category AST\n */\nexport class LookupExpr extends Expression {\n  name: string;\n\n  constructor(name: string, public tokens: { identifier: Token }) {\n    super();\n    this.name = name;\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitLookupExpr(this);\n  }\n}\n\n/**\n * A member lookup expression, (abc.ddd)\n * @category AST\n */\nexport class MemberLookupExpr extends Expression {\n  expr: Expression;\n  member: string;\n\n  constructor(\n    expr: Expression,\n    member: string,\n    public tokens: {\n      dot: Token;\n      memberName: LiteralToken<string>;\n    }\n  ) {\n    super();\n    this.expr = expr;\n    this.member = member;\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitMemberLookupExpr(this);\n  }\n}\n\n/**\n * A function call expression. Example: sin(10)\n * @category AST\n */\nexport class FunctionCallExpr extends Expression {\n  /**\n   * The expression that is being called.\n   */\n  callee: Expression;\n\n  /**\n   * The named arguments of the function call\n   */\n  args: AssignmentNode[];\n  constructor(\n    callee: Expression,\n    args: AssignmentNode[],\n    public tokens: {\n      firstParen: Token;\n      secondParen: Token;\n    }\n  ) {\n    super();\n    this.callee = callee;\n    this.args = args;\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitFunctionCallExpr(this);\n  }\n}\n\n/**\n * A common class for the Echo, Assert and Let expression so that the constructor is not copied.\n * @category AST\n */\nexport abstract class FunctionCallLikeExpr extends Expression {\n  /**\n   * The names of the assigned variables in this let expression.\n   */\n  args: AssignmentNode[];\n\n  /**\n   * The inner expression which will use the expression.\n   */\n  expr: Expression;\n\n  constructor(\n    args: AssignmentNode[],\n    expr: Expression,\n    public tokens: { name: Token; firstParen: Token; secondParen: Token }\n  ) {\n    super();\n    this.args = args;\n    this.expr = expr;\n  }\n}\n\n/**\n * Represents a let expression. Please note that this is syntactically diffrent from the let module instantation and the let list comprehension.\n * @category AST\n */\nexport class LetExpr extends FunctionCallLikeExpr {\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitLetExpr(this);\n  }\n}\n\n/**\n * @category AST\n */\nexport class AssertExpr extends FunctionCallLikeExpr {\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitAssertExpr(this);\n  }\n}\n\n/**\n * @category AST\n */\nexport class EchoExpr extends FunctionCallLikeExpr {\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitEchoExpr(this);\n  }\n}\n\n/**\n * @category AST\n */\nexport abstract class ListComprehensionExpression extends Expression {}\n\n/**\n * @category AST\n */\nexport class LcIfExpr extends ListComprehensionExpression {\n  cond: Expression;\n  ifExpr: Expression;\n  elseExpr: Expression | null;\n  constructor(\n    cond: Expression,\n    ifExpr: Expression,\n    elseExpr: Expression | null,\n    public tokens: {\n      ifKeyword: Token;\n      firstParen: Token;\n      secondParen: Token;\n      elseKeyword: Token | null;\n    }\n  ) {\n    super();\n    this.cond = cond;\n    this.ifExpr = ifExpr;\n    this.elseExpr = elseExpr;\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitLcIfExpr(this);\n  }\n}\n\n/**\n * @category AST\n */\nexport class LcEachExpr extends ListComprehensionExpression {\n  /**\n   * The expression where the declared variables will be accessible.\n   */\n  expr: Expression;\n\n  constructor(\n    expr: Expression,\n    public tokens: {\n      eachKeyword: Token;\n    }\n  ) {\n    super();\n\n    this.expr = expr;\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitLcEachExpr(this);\n  }\n}\n\n/**\n * @category AST\n */\nexport class LcForExpr extends ListComprehensionExpression {\n  /**\n   * The variable names in the for expression\n   */\n  args: AssignmentNode[];\n\n  /**\n   * The expression which will be looped.\n   */\n  expr: Expression;\n\n  constructor(\n    args: AssignmentNode[],\n    expr: Expression,\n    public tokens: {\n      forKeyword: Token;\n      firstParen: Token;\n      secondParen: Token;\n    }\n  ) {\n    super();\n    this.args = args;\n    this.expr = expr;\n  }\n\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitLcForExpr(this);\n  }\n}\n\n/**\n * @category AST\n */\nexport class LcForCExpr extends ListComprehensionExpression {\n  /**\n   * The variable names in the for expression\n   */\n  args: AssignmentNode[];\n\n  incrArgs: AssignmentNode[];\n\n  cond: Expression;\n  /**\n   * The expression which will be looped.\n   */\n  expr: Expression;\n\n  constructor(\n    args: AssignmentNode[],\n    incrArgs: AssignmentNode[],\n    cond: Expression,\n    expr: Expression,\n    public tokens: {\n      forKeyword: Token;\n      firstParen: Token;\n      firstSemicolon: Token;\n      secondSemicolon: Token;\n      secondParen: Token;\n    }\n  ) {\n    super();\n    this.args = args;\n    this.incrArgs = incrArgs;\n    this.cond = cond;\n    this.expr = expr;\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitLcForCExpr(this);\n  }\n}\n\n/**\n * @category AST\n */\nexport class LcLetExpr extends ListComprehensionExpression {\n  /**\n   * The variable names in the let expression\n   */\n  args: AssignmentNode[];\n\n  /**\n   * The expression where the declared variables will be accessible.\n   */\n  expr: Expression;\n\n  constructor(\n    args: AssignmentNode[],\n    expr: Expression,\n    public tokens: {\n      letKeyword: Token;\n      firstParen: Token;\n      secondParen: Token;\n    }\n  ) {\n    super();\n    this.args = args;\n    this.expr = expr;\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitLcLetExpr(this);\n  }\n}\n\n/**\n * An expression enclosed in parenthesis.\n * @category AST\n */\nexport class GroupingExpr extends Expression {\n  inner: Expression;\n  constructor(\n    inner: Expression,\n    public tokens: {\n      firstParen: Token;\n      secondParen: Token;\n    }\n  ) {\n    super();\n    this.inner = inner;\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitGroupingExpr(this);\n  }\n}\n\n/**\n * AnonymousFunctionExpr represents a function expression. 'function(x) x * x'\n * @category AST\n */\nexport class AnonymousFunctionExpr extends Expression {\n  constructor(\n    public definitionArgs: AssignmentNode[],\n    public expr: Expression,\n    public tokens: {\n      functionKeyword: Token;\n      firstParen: Token;\n      secondParen: Token;\n    }\n  ) {\n    super();\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitAnonymousFunctionExpr(this);\n  }\n}\n", "import CodeLocation from \"../CodeLocation\";\nimport DocComment from \"../comments/DocComment\";\nimport LiteralToken from \"../LiteralToken\";\nimport Token from \"../Token\";\nimport AssignmentNode from \"./AssignmentNode\";\nimport ASTNode from \"./ASTNode\";\nimport ASTVisitor from \"./ASTVisitor\";\nimport { Expression } from \"./expressions\";\n\n/**\n * @category AST\n */\nexport abstract class Statement extends ASTNode {}\n\n/**\n * @category AST\n */\nexport class UseStmt extends Statement {\n  /**\n   *\n   * @param pos\n   * @param filename The used filename\n   */\n  constructor(\n    \n    public filename: string,\n    public tokens: {\n      useKeyword: Token;\n      filename: LiteralToken<string>;\n    }\n  ) {\n    super();\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitUseStmt(this);\n  }\n}\n\n/**\n * @category AST\n */\nexport class IncludeStmt extends Statement {\n  /**\n   *\n   * @param pos\n   * @param filename The used filename\n   */\n  constructor(\n    public filename: string,\n    public tokens: {\n      includeKeyword: Token;\n      filename: LiteralToken<string>;\n    }\n  ) {\n    super();\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitIncludeStmt(this);\n  }\n}\n\n/**\n * Represents a statement that can be prefixed with the !%#* symbols to change it's behaviour.\n * @category AST\n */\nexport interface TaggableStatement {\n  /**\n   * Set to true if this module instantation has been tagged with a '!' symbol.\n   */\n  tagRoot: boolean;\n\n  /**\n   * Set to true if this module instantation has been tagged with a '#' symbol.\n   */\n  tagHighlight: boolean;\n\n  /**\n   * Set to true if this module instantation has been tagged with a '%' symbol.\n   */\n  tagBackground: boolean;\n\n  /**\n   * Set to true if this module instantation has been tagged with a '*' symbol.\n   */\n  tagDisabled: boolean;\n}\n\n/**\n * @category AST\n */\nexport class ModuleInstantiationStmt\n  extends Statement\n  implements TaggableStatement\n{\n  /**\n   * !\n   */\n  public tagRoot: boolean = false;\n\n  /**\n   * #\n   */\n  public tagHighlight: boolean = false;\n\n  /**\n   * %\n   */\n  public tagBackground: boolean = false;\n\n  /**\n   * *\n   */\n  public tagDisabled: boolean = false;\n\n  constructor(\n    \n    public name: string,\n    public args: AssignmentNode[],\n    /**\n     * The child statement in a module instantiation chain.\n     * Can be null if this is the last statement in the chain.\n     */\n    public child: Statement | null,\n    public tokens: {\n      name: Token;\n      firstParen: Token;\n      secondParen: Token;\n      modifiersInOrder: Token[];\n    }\n  ) {\n    super();\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitModuleInstantiationStmt(this);\n  }\n}\n\n/**\n * @category AST\n */\nexport class ModuleDeclarationStmt extends Statement {\n  constructor(\n    \n    public name: string,\n    public definitionArgs: AssignmentNode[],\n    public stmt: Statement,\n    public tokens: {\n      moduleKeyword: Token;\n      name: Token;\n      firstParen: Token;\n      secondParen: Token;\n    },\n    public docComment: DocComment\n  ) {\n    super();\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitModuleDeclarationStmt(this);\n  }\n}\n\n/**\n * FunctionDeclarationStmt reperesents a named function declaration statement.\n * @category AST\n */\nexport class FunctionDeclarationStmt extends Statement {\n  constructor(\n    \n    public name: string,\n    public definitionArgs: AssignmentNode[],\n    public expr: Expression,\n    public tokens: {\n      functionKeyword: Token;\n      name: Token;\n      firstParen: Token;\n      secondParen: Token;\n      equals: Token;\n      semicolon: Token;\n    },\n    public docComment: DocComment\n  ) {\n    super();\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitFunctionDeclarationStmt(this);\n  }\n}\n\n/**\n * @category AST\n */\nexport class BlockStmt extends Statement {\n  constructor(\n    \n    public children: Statement[],\n    public tokens: {\n      firstBrace: Token;\n      secondBrace: Token;\n    }\n  ) {\n    super();\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitBlockStmt(this);\n  }\n}\n\n/**\n * @category AST\n */\nexport class NoopStmt extends Statement {\n  constructor(\n    \n    public tokens: {\n      semicolon: Token;\n    }\n  ) {\n    super();\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitNoopStmt(this);\n  }\n}\n\n/**\n * IfElseStmt represents an if-else statement. elseIfs are represented as\n * additional IfElseStmt instances in the else branch (simmilar to how C works).\n * @category AST\n */\nexport class IfElseStatement extends Statement implements TaggableStatement {\n  public tagRoot: boolean = false;\n  public tagHighlight: boolean = false;\n  public tagBackground: boolean = false;\n  public tagDisabled: boolean = false;\n  constructor(\n    \n    public cond: Expression,\n    public thenBranch: Statement,\n    /**\n     * The else branch.\n     * It can be null if there is no else branch.\n     */\n    public elseBranch: Statement | null,\n    public tokens: {\n      ifKeyword: Token;\n      firstParen: Token;\n      secondParen: Token;\n      elseKeyword: Token | null;\n      modifiersInOrder: Token[];\n    }\n  ) {\n    super();\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitIfElseStatement(this);\n  }\n}\n", "import ASTVisitor from \"../ast/ASTVisitor\";\nimport { AnonymousFunctionExpr, LcForCExpr, LcForExpr, LcLetExpr, LetExpr } from \"../ast/expressions\";\nimport ScadFile from \"../ast/ScadFile\";\nimport {\n  BlockStmt,\n  FunctionDeclarationStmt,\n  ModuleDeclarationStmt,\n  ModuleInstantiationStmt,\n} from \"../ast/statements\";\nimport NodeWithScope from \"./NodeWithScope\";\nimport Scope from \"./Scope\";\n\nexport interface ASTVisitorForNodesWithScopes<R> extends ASTVisitor<R> {\n  visitBlockStmtWithScope(n: BlockStmtWithScope): R;\n  visitLetExprWithScope(n: LetExprWithScope): R;\n  visitScadFileWithScope(n: ScadFileWithScope): R;\n  visitFunctionDeclarationStmtWithScope(n: FunctionDeclarationStmtWithScope): R;\n  visitModuleDeclarationStmtWithScope(n: ModuleDeclarationStmtWithScope): R;\n  visitLcLetExprWithScope(n: LcLetExprWithScope): R;\n  visitLcForExprWithScope(n: LcForExprWithScope): R;\n  visitLcForCExprWithScope(n: LcForCExprWithScope): R;\n  visitModuleInstantiationStmtWithScope(n: ModuleInstantiationStmtWithScope): R;\n  visitAnonymousFunctionExprWithScope(n: AnonymousFunctionExprWithScope): R;\n}\n\nexport class BlockStmtWithScope extends BlockStmt implements NodeWithScope {\n  scope!: Scope;\n  accept<R>(visitor: ASTVisitorForNodesWithScopes<R>): R {\n    if (visitor.visitBlockStmtWithScope) {\n      return visitor.visitBlockStmtWithScope(this);\n    }\n    return visitor.visitBlockStmt(this);\n  }\n}\nexport class LetExprWithScope extends LetExpr implements NodeWithScope {\n  scope!: Scope;\n  accept<R>(visitor: ASTVisitorForNodesWithScopes<R>): R {\n    if (visitor.visitLetExprWithScope) {\n      return visitor.visitLetExprWithScope(this);\n    }\n    return visitor.visitLetExpr(this);\n  }\n}\n\nexport class ScadFileWithScope extends ScadFile implements NodeWithScope {\n  scope!: Scope;\n  accept<R>(visitor: ASTVisitorForNodesWithScopes<R>): R {\n    if (visitor.visitScadFileWithScope) {\n      return visitor.visitScadFileWithScope(this);\n    }\n    return visitor.visitScadFile(this);\n  }\n}\n\nexport class FunctionDeclarationStmtWithScope\n  extends FunctionDeclarationStmt\n  implements NodeWithScope\n{\n  scope!: Scope;\n  accept<R>(visitor: ASTVisitorForNodesWithScopes<R>): R {\n    if (visitor.visitFunctionDeclarationStmtWithScope) {\n      return visitor.visitFunctionDeclarationStmtWithScope(this);\n    }\n    return visitor.visitFunctionDeclarationStmt(this);\n  }\n}\n\nexport class ModuleDeclarationStmtWithScope\n  extends ModuleDeclarationStmt\n  implements NodeWithScope\n{\n  scope!: Scope;\n  accept<R>(visitor: ASTVisitorForNodesWithScopes<R>): R {\n    if (visitor.visitModuleDeclarationStmtWithScope) {\n      return visitor.visitModuleDeclarationStmtWithScope(this);\n    }\n    return visitor.visitModuleDeclarationStmt(this);\n  }\n}\n\nexport class ModuleInstantiationStmtWithScope\n  extends ModuleInstantiationStmt\n  implements NodeWithScope\n{\n  scope!: Scope;\n  accept<R>(visitor: ASTVisitorForNodesWithScopes<R>): R {\n    if (visitor.visitModuleInstantiationStmtWithScope) {\n      return visitor.visitModuleInstantiationStmtWithScope(this);\n    }\n    return visitor.visitModuleInstantiationStmt(this);\n  }\n}\n\nexport class LcLetExprWithScope extends LcLetExpr implements NodeWithScope {\n  scope!: Scope;\n  accept<R>(visitor: ASTVisitorForNodesWithScopes<R>): R {\n    if (visitor.visitLcLetExprWithScope) {\n      return visitor.visitLcLetExprWithScope(this);\n    }\n    return visitor.visitLcLetExpr(this);\n  }\n}\n\nexport class LcForExprWithScope extends LcForExpr implements NodeWithScope {\n  scope!: Scope;\n  accept<R>(visitor: ASTVisitorForNodesWithScopes<R>): R {\n    if (visitor.visitLcForExprWithScope) {\n      return visitor.visitLcForExprWithScope(this);\n    }\n    return visitor.visitLcForExpr(this);\n  }\n}\n\nexport class LcForCExprWithScope extends LcForCExpr implements NodeWithScope {\n  scope!: Scope;\n  accept<R>(visitor: ASTVisitorForNodesWithScopes<R>): R {\n    if (visitor.visitLcForCExprWithScope) {\n      return visitor.visitLcForCExprWithScope(this);\n    }\n    return visitor.visitLcForCExpr(this);\n  }\n}\n\nexport class AnonymousFunctionExprWithScope extends AnonymousFunctionExpr implements NodeWithScope {\n  scope!: Scope;\n  accept<R>(visitor: ASTVisitorForNodesWithScopes<R>): R {\n    if (visitor.visitAnonymousFunctionExprWithScope) {\n      return visitor.visitAnonymousFunctionExprWithScope(this);\n    }\n    return visitor.visitAnonymousFunctionExpr(this);\n  }\n}\n", "import CodeLocation from \"../CodeLocation\";\nimport DocComment from \"../comments/DocComment\";\nimport Token from \"../Token\";\nimport ASTNode from \"./ASTNode\";\nimport ASTVisitor from \"./ASTVisitor\";\nimport { Expression } from \"./expressions\";\n\nexport enum AssignmentNodeRole {\n  VARIABLE_DECLARATION,\n  ARGUMENT_DECLARATION,\n  ARGUMENT_ASSIGNMENT,\n}\n\n/**\n * Represents a value being assigned to a name. Used when declaring and calling modules or functions.\n * It is also used in control flow structures such as for loops and let expressions.\n * @category AST\n */\nexport default class AssignmentNode extends ASTNode {\n  /**\n   * The name of the value being assigned.\n   * The name field may be empty when it represents a positional argument in a call.\n   */\n  name: string;\n\n  /**\n   * THe value of the name being assigned.\n   * It can be null when the AssignmentNode is used as a function parameter without a default value.\n   */\n  value: Expression | null;\n\n  /**\n   * The documentation and annotations connected with this variable.\n   */\n  docComment: DocComment | null = null;\n\n  constructor(\n    name: string,\n    value: Expression | null,\n    public role: AssignmentNodeRole,\n    public tokens: {\n      name: Token | null;\n      equals: Token | null;\n      trailingCommas: Token[] | null;\n      semicolon: Token | null;\n    }\n  ) {\n    super();\n    this.name = name;\n    this.value = value;\n  }\n  accept<R>(visitor: ASTVisitor<R>): R {\n    return visitor.visitAssignmentNode(this);\n  }\n}\n", "import ScadFile from \"./ast/ScadFile\";\n\nimport ASTVisitor from \"./ast/ASTVisitor\";\nimport {\n  UnaryOpExpr,\n  BinaryOpExpr,\n  TernaryExpr,\n  ArrayLookupExpr,\n  LiteralExpr,\n  RangeExpr,\n  VectorExpr,\n  LookupExpr,\n  MemberLookupExpr,\n  FunctionCallExpr,\n  LetExpr,\n  AssertExpr,\n  EchoExpr,\n  LcIfExpr,\n  LcEachExpr,\n  LcForExpr,\n  LcForCExpr,\n  LcLetExpr,\n  GroupingExpr,\n  AnonymousFunctionExpr,\n} from \"./ast/expressions\";\nimport {\n  UseStmt,\n  IncludeStmt,\n  ModuleInstantiationStmt,\n  ModuleDeclarationStmt,\n  FunctionDeclarationStmt,\n  BlockStmt,\n  NoopStmt,\n  IfElseStatement,\n} from \"./ast/statements\";\nimport DocComment from \"./comments/DocComment\";\nimport {\n  ASTVisitorForNodesWithScopes,\n  BlockStmtWithScope,\n  LetExprWithScope,\n  ScadFileWithScope,\n  FunctionDeclarationStmtWithScope,\n  ModuleDeclarationStmtWithScope,\n  LcLetExprWithScope,\n  LcForExprWithScope,\n  LcForCExprWithScope,\n  ModuleInstantiationStmtWithScope,\n  AnonymousFunctionExprWithScope,\n} from \"./semantic/nodesWithScopes\";\nimport AssignmentNode from \"./ast/AssignmentNode\";\nimport ASTNode from \"./ast/ASTNode\";\nimport ErrorNode from \"./ast/ErrorNode\";\n\nexport default class ASTMutator\n  implements ASTVisitorForNodesWithScopes<ASTNode>\n{\n  visitScadFile(n: ScadFile): ASTNode {\n    const stmts = n.statements.map((s) => s.accept(this));\n    if (stmts.length === n.statements.length) {\n      let modified = false;\n      for (let i = 0; i < stmts.length; i++) {\n        if (stmts[i] !== n.statements[i]) {\n          modified = true;\n          break;\n        }\n      }\n      if (!modified) {\n        return n;\n      }\n    }\n\n    return new ScadFile(stmts, n.tokens);\n  }\n  visitAssignmentNode(n: AssignmentNode): ASTNode {\n    const newValue = n.value ? n.value.accept(this) : null;\n    if (newValue === n.value) {\n      return n;\n    }\n    return new AssignmentNode(n.name, newValue, n.role, n.tokens);\n  }\n  visitUnaryOpExpr(n: UnaryOpExpr): ASTNode {\n    const newRight = n.right.accept(this);\n    if (newRight === n.right) {\n      return n;\n    }\n    return new UnaryOpExpr(n.operation, newRight, n.tokens);\n  }\n  visitBinaryOpExpr(n: BinaryOpExpr): ASTNode {\n    const newLeft = n.left.accept(this);\n    const newRight = n.right.accept(this);\n    if (newRight === n.right && newLeft === n.left) {\n      return n;\n    }\n    return new BinaryOpExpr(newLeft, n.operation, newRight, n.tokens);\n  }\n  visitTernaryExpr(n: TernaryExpr): ASTNode {\n    const newCond = n.cond.accept(this);\n    const newIfExpr = n.ifExpr.accept(this);\n    const newElseExpr = n.elseExpr.accept(this);\n    if (\n      newCond === n.cond &&\n      newIfExpr === n.ifExpr &&\n      newElseExpr === n.elseExpr\n    ) {\n      return n;\n    }\n    return new TernaryExpr(n.cond, n.ifExpr, n.elseExpr, n.tokens);\n  }\n  visitArrayLookupExpr(n: ArrayLookupExpr): ASTNode {\n    const newArray = n.array.accept(this);\n    const newIndex = n.index.accept(this);\n    if (newArray === n.array && newIndex === n.index) {\n      return n;\n    }\n    return new ArrayLookupExpr(newArray, newIndex, n.tokens);\n  }\n  visitLiteralExpr(n: LiteralExpr<any>): ASTNode {\n    return n;\n  }\n  visitRangeExpr(n: RangeExpr): ASTNode {\n    const newBegin = n.begin.accept(this);\n    const newStep = n.step ? n.step.accept(this) : null;\n    const newEnd = n.end.accept(this);\n    if (newBegin === n.begin && newStep === n.step && newEnd === n.end) {\n      return n;\n    }\n    return new RangeExpr(newBegin, newStep, newEnd, n.tokens);\n  }\n  visitVectorExpr(n: VectorExpr): ASTNode {\n    const newChildren = n.children.map((c) => c.accept(this));\n    if (newChildren.length === n.children.length) {\n      let modified = false;\n      for (let i = 0; i < newChildren.length; i++) {\n        if (newChildren[i] !== n.children[i]) {\n          modified = true;\n          break;\n        }\n      }\n      if (!modified) return n;\n    }\n    return new VectorExpr(newChildren, n.tokens);\n  }\n  visitLookupExpr(n: LookupExpr): ASTNode {\n    return n;\n  }\n  visitMemberLookupExpr(n: MemberLookupExpr): ASTNode {\n    const newExpr = n.expr.accept(this);\n    if (newExpr === n.expr) {\n      return n;\n    }\n    return new MemberLookupExpr(newExpr, n.member, n.tokens);\n  }\n  visitFunctionCallExpr(n: FunctionCallExpr): ASTNode {\n    const newArgs = n.args.map((a) => a.accept(this)) as AssignmentNode[];\n    const newCalee = n.callee.accept(this);\n    if (newArgs.length === n.args.length && newCalee === n.callee) {\n      let modified = false;\n      for (let i = 0; i < newArgs.length; i++) {\n        if (newArgs[i] !== n.args[i]) {\n          modified = true;\n          break;\n        }\n      }\n      if (!modified) return n;\n    }\n    return new FunctionCallExpr(newCalee, newArgs, n.tokens);\n  }\n  visitLetExpr(n: LetExpr): ASTNode {\n    const newExpr = n.expr.accept(this);\n    const newArgs = n.args.map((a) => a.accept(this)) as AssignmentNode[];\n    if (newArgs.length === n.args.length && newExpr === n.expr) {\n      let modified = false;\n      for (let i = 0; i < newArgs.length; i++) {\n        if (newArgs[i] !== n.args[i]) {\n          modified = true;\n          break;\n        }\n      }\n      if (!modified) return n;\n    }\n\n    return new LetExpr(newArgs, newExpr, n.tokens);\n  }\n  visitAssertExpr(n: AssertExpr): ASTNode {\n    const newExpr = n.expr.accept(this);\n    const newArgs = n.args.map((a) => a.accept(this)) as AssignmentNode[];\n    if (newArgs.length === n.args.length && newExpr === n.expr) {\n      let modified = false;\n      for (let i = 0; i < newArgs.length; i++) {\n        if (newArgs[i] !== n.args[i]) {\n          modified = true;\n          break;\n        }\n      }\n      if (!modified) return n;\n    }\n\n    return new AssertExpr(newArgs, newExpr, n.tokens);\n  }\n  visitEchoExpr(n: EchoExpr): ASTNode {\n    const newExpr = n.expr.accept(this);\n    const newArgs = n.args.map((a) => a.accept(this)) as AssignmentNode[];\n    if (newArgs.length === n.args.length && newExpr === n.expr) {\n      let modified = false;\n      for (let i = 0; i < newArgs.length; i++) {\n        if (newArgs[i] !== n.args[i]) {\n          modified = true;\n          break;\n        }\n      }\n      if (!modified) return n;\n    }\n\n    return new EchoExpr(newArgs, newExpr, n.tokens);\n  }\n  visitLcIfExpr(n: LcIfExpr): ASTNode {\n    const newCond = n.cond.accept(this);\n    const newIfExpr = n.ifExpr.accept(this);\n    const newElseExpr = n.elseExpr ? n.elseExpr.accept(this) : null;\n    if (\n      newCond === n.cond &&\n      newIfExpr === n.ifExpr &&\n      newElseExpr === n.elseExpr\n    ) {\n      return n;\n    }\n    return new LcIfExpr(newCond, newIfExpr, newElseExpr, n.tokens);\n  }\n  visitLcEachExpr(n: LcEachExpr): ASTNode {\n    const newExpr = n.expr.accept(this);\n    if (newExpr === n.expr) {\n      return n;\n    }\n    return new LcEachExpr(newExpr, n.tokens);\n  }\n  visitLcForExpr(n: LcForExpr): ASTNode {\n    const newExpr = n.expr.accept(this);\n    const newArgs = n.args.map((a) => a.accept(this)) as AssignmentNode[];\n    if (newArgs.length === n.args.length && newExpr === n.expr) {\n      let modified = false;\n      for (let i = 0; i < newArgs.length; i++) {\n        if (newArgs[i] !== n.args[i]) {\n          modified = true;\n          break;\n        }\n      }\n      if (!modified) return n;\n    }\n    return new LcForExpr(newArgs, newExpr, n.tokens);\n  }\n  visitLcForCExpr(n: LcForCExpr): ASTNode {\n    const newArgs = n.args.map((a) => a.accept(this)) as AssignmentNode[];\n    const newIncrArgs = n.incrArgs.map((a) =>\n      a.accept(this)\n    ) as AssignmentNode[];\n    const newExpr = n.expr.accept(this);\n    const newCond = n.cond.accept(this);\n    if (\n      newArgs.length === n.args.length &&\n      newIncrArgs.length === n.incrArgs.length &&\n      newExpr === n.expr &&\n      newCond === n.cond\n    ) {\n      let modified = false;\n      for (let i = 0; i < newArgs.length; i++) {\n        if (newArgs[i] !== n.args[i]) {\n          modified = true;\n          break;\n        }\n      }\n      for (let i = 0; i < newIncrArgs.length; i++) {\n        if (newIncrArgs[i] !== n.incrArgs[i]) {\n          modified = true;\n          break;\n        }\n      }\n      if (!modified) return n;\n    }\n    return new LcForCExpr(newArgs, newIncrArgs, newCond, newExpr, n.tokens);\n  }\n  visitLcLetExpr(n: LcLetExpr): ASTNode {\n    const newExpr = n.expr.accept(this);\n    const newArgs = n.args.map((a) => a.accept(this)) as AssignmentNode[];\n    if (newArgs.length === n.args.length && newExpr === n.expr) {\n      let modified = false;\n      for (let i = 0; i < newArgs.length; i++) {\n        if (newArgs[i] !== n.args[i]) {\n          modified = true;\n          break;\n        }\n      }\n      if (!modified) return n;\n    }\n    return new LcLetExpr(newArgs, newExpr, n.tokens);\n  }\n  visitGroupingExpr(n: GroupingExpr): ASTNode {\n    const newInner = n.inner.accept(this);\n    if (newInner === n.inner) {\n      return n;\n    }\n    return new GroupingExpr(n.inner.accept(this), n.tokens);\n  }\n  visitUseStmt(n: UseStmt): ASTNode {\n    return n;\n  }\n  visitIncludeStmt(n: IncludeStmt): ASTNode {\n    return n;\n  }\n  visitModuleInstantiationStmt(n: ModuleInstantiationStmt): ASTNode {\n    // TODO: add cached check\n    const inst = new ModuleInstantiationStmt(\n      n.name,\n      n.args.map((a) => a.accept(this)) as AssignmentNode[],\n      n.child ? n.child.accept(this) : null,\n      n.tokens\n    );\n    inst.tagRoot = n.tagRoot;\n    inst.tagHighlight = n.tagHighlight;\n    inst.tagBackground = n.tagBackground;\n    inst.tagDisabled = n.tagDisabled;\n    return inst;\n  }\n  visitModuleDeclarationStmt(n: ModuleDeclarationStmt): ASTNode {\n    const newDefinitionArgs = n.definitionArgs.map((a) =>\n      a.accept(this)\n    ) as AssignmentNode[];\n    const newStmt = n.stmt.accept(this);\n    if (\n      newDefinitionArgs.length === n.definitionArgs.length &&\n      newStmt === n.stmt\n    ) {\n      let modified = false;\n      for (let i = 0; i < newDefinitionArgs.length; i++) {\n        if (newDefinitionArgs[i] !== n.definitionArgs[i]) {\n          modified = true;\n          break;\n        }\n      }\n      if (!modified) return n;\n    }\n    return new ModuleDeclarationStmt(\n      n.name,\n      newDefinitionArgs,\n      newStmt,\n      n.tokens,\n      n.docComment\n    );\n  }\n  visitFunctionDeclarationStmt(n: FunctionDeclarationStmt): ASTNode {\n    const newDefinitionArgs = n.definitionArgs.map((a) =>\n      a.accept(this)\n    ) as AssignmentNode[];\n    const newExpr = n.expr.accept(this);\n    if (\n      newDefinitionArgs.length === n.definitionArgs.length &&\n      newExpr === n.expr\n    ) {\n      let modified = false;\n      for (let i = 0; i < newDefinitionArgs.length; i++) {\n        if (newDefinitionArgs[i] !== n.definitionArgs[i]) {\n          modified = true;\n          break;\n        }\n      }\n      if (!modified) return n;\n    }\n    return new FunctionDeclarationStmt(\n      n.name,\n      newDefinitionArgs,\n      newExpr,\n      n.tokens,\n      n.docComment\n    );\n  }\n  visitBlockStmt(n: BlockStmt): ASTNode {\n    const children = n.children.map((s) => s.accept(this));\n    if (children.length === n.children.length) {\n      let modified = false;\n      for (let i = 0; i < children.length; i++) {\n        if (children[i] !== n.children[i]) {\n          modified = true;\n          break;\n        }\n      }\n      if (!modified) {\n        return n;\n      }\n    }\n\n    return new BlockStmt(children, n.tokens);\n  }\n  visitNoopStmt(n: NoopStmt): ASTNode {\n    return n;\n  }\n  visitIfElseStatement(n: IfElseStatement): ASTNode {\n    const newCond = n.cond.accept(this);\n    const newThenBranch = n.thenBranch.accept(this);\n    const newElseBranch = n.elseBranch ? n.elseBranch.accept(this) : null;\n    if (\n      newCond === n.cond &&\n      newThenBranch === n.thenBranch &&\n      newElseBranch === n.elseBranch\n    ) {\n      return n;\n    }\n    return new IfElseStatement(newCond, newThenBranch, newElseBranch, n.tokens);\n  }\n  visitErrorNode(n: ErrorNode): ASTNode {\n    return n;\n  }\n\n  visitAnonymousFunctionExpr(n: AnonymousFunctionExpr): ASTNode {\n    const newArgs = n.definitionArgs.map((a) =>\n      a.accept(this)\n    ) as AssignmentNode[];\n    const newBody = n.expr.accept(this);\n    if (newArgs.length === n.definitionArgs.length && newBody === n.expr) {\n      let modified = false;\n      for (let i = 0; i < newArgs.length; i++) {\n        if (newArgs[i] !== n.definitionArgs[i]) {\n          modified = true;\n          break;\n        }\n      }\n      if (!modified) return n;\n    }\n    return new AnonymousFunctionExpr(newArgs, newBody, n.tokens);\n  }\n\n  visitBlockStmtWithScope(n: BlockStmtWithScope): ASTNode {\n    const oldNode = this.visitBlockStmt(n) as BlockStmt;\n    const newNode = new BlockStmtWithScope(oldNode.children, oldNode.tokens);\n    newNode.scope = n.scope;\n    return newNode;\n  }\n  visitLetExprWithScope(n: LetExprWithScope): ASTNode {\n    const oldNode = this.visitLetExpr(n) as LetExpr;\n    const newNode = new LetExprWithScope(\n      oldNode.args,\n      oldNode.expr,\n      oldNode.tokens\n    );\n    newNode.scope = n.scope;\n    return newNode;\n  }\n  visitScadFileWithScope(n: ScadFileWithScope): ASTNode {\n    const oldNode = this.visitScadFile(n) as ScadFile;\n    const newNode = new ScadFileWithScope(oldNode.statements, oldNode.tokens);\n    newNode.scope = n.scope;\n    return newNode;\n  }\n  visitFunctionDeclarationStmtWithScope(\n    n: FunctionDeclarationStmtWithScope\n  ): ASTNode {\n    const oldNode = this.visitFunctionDeclarationStmt(\n      n\n    ) as FunctionDeclarationStmt;\n    const newNode = new FunctionDeclarationStmtWithScope(\n      oldNode.name,\n      oldNode.definitionArgs,\n      oldNode.expr,\n      oldNode.tokens,\n      oldNode.docComment\n    );\n    newNode.scope = n.scope;\n    return newNode;\n  }\n  visitModuleDeclarationStmtWithScope(\n    n: ModuleDeclarationStmtWithScope\n  ): ASTNode {\n    const oldNode = this.visitModuleDeclarationStmt(n) as ModuleDeclarationStmt;\n    const newNode = new ModuleDeclarationStmtWithScope(\n      oldNode.name,\n      oldNode.definitionArgs,\n      oldNode.stmt,\n      oldNode.tokens,\n      n.docComment\n    );\n    newNode.scope = n.scope;\n    return newNode;\n  }\n  visitModuleInstantiationStmtWithScope(n: ModuleInstantiationStmtWithScope) {\n    const oldNode = this.visitModuleInstantiationStmt(\n      n\n    ) as ModuleInstantiationStmt;\n    const newNode = new ModuleInstantiationStmtWithScope(\n      oldNode.name,\n      oldNode.args,\n      oldNode.child,\n      oldNode.tokens\n    );\n    newNode.scope = n.scope;\n    return newNode;\n  }\n  visitLcLetExprWithScope(n: LcLetExprWithScope): ASTNode {\n    const oldNode = this.visitLcLetExpr(n) as LcLetExpr;\n    const newNode = new LcLetExprWithScope(\n      oldNode.args,\n      oldNode.expr,\n      oldNode.tokens\n    );\n    newNode.scope = n.scope;\n    return newNode;\n  }\n  visitLcForExprWithScope(n: LcForExprWithScope): ASTNode {\n    const oldNode = this.visitLcForExpr(n) as LcForExpr;\n    const newNode = new LcForExprWithScope(\n      oldNode.args,\n      oldNode.expr,\n      oldNode.tokens\n    );\n    newNode.scope = n.scope;\n    return newNode;\n  }\n  visitLcForCExprWithScope(n: LcForCExprWithScope): ASTNode {\n    const oldNode = this.visitLcForCExpr(n) as LcForCExpr;\n    const newNode = new LcForCExprWithScope(\n      oldNode.args,\n      oldNode.incrArgs,\n      oldNode.cond,\n      oldNode.expr,\n      oldNode.tokens\n    );\n    newNode.scope = n.scope;\n    return newNode;\n  }\n\n  visitAnonymousFunctionExprWithScope(n: AnonymousFunctionExprWithScope) {\n    const oldNode = this.visitAnonymousFunctionExpr(n) as AnonymousFunctionExpr;\n    const newNode = new AnonymousFunctionExprWithScope(\n      oldNode.definitionArgs,\n      oldNode.expr,\n      oldNode.tokens\n    );\n    newNode.scope = n.scope;\n    return newNode;\n  }\n}\n", "import CodeLocation from \"./CodeLocation\";\n\n/**\n * An extra tolen is a parto of the source file that doesn't directly influence the AST, but it should be preserved when foromatting the code.\n */\nexport abstract class ExtraToken {\n  constructor(public pos: CodeLocation) {}\n}\n\n/**\n * A new line between two other tokens.\n */\nexport class NewLineExtraToken extends ExtraToken {}\n\nexport class SingleLineComment extends ExtraToken {\n  constructor(pos: CodeLocation, public contents: string) {\n    super(pos);\n  }\n}\n\nexport class MultiLineComment extends ExtraToken {\n  constructor(pos: CodeLocation, public contents: string) {\n    super(pos);\n  }\n}\n", "enum TokenType {\n  Error,\n  /**\n   * Eot is always pushed as the last token and used by the parser to detect the endo of the file.\n   */\n  Eot,\n  /**\n   * The module keyword.\n   */\n  Module,\n  /**\n   * The function keyword.\n   */\n  Function,\n  /**\n   * The if keyword.\n   */\n  If,\n  /**\n   * The else keyword.\n   */\n  Else,\n  /**\n   * The for keyword.\n   */\n  For,\n  /**\n   * The let keyword.\n   */\n  Let,\n  /**\n   * The assert keyword.\n   */\n  Assert,\n  /**\n   * The echo keyword.\n   */\n  Echo,\n  /**\n   * The each keyword.\n   */\n  Each,\n  /**\n   * The use keyword.\n   */\n  Use,\n  /**\n   * An identifier, represents a function, module or variable name\n   */\n  Identifier,\n  /**\n   * A string literal (e.g. quoted color names)\n   */\n  StringLiteral,\n  /**\n   * A number literal.\n   */\n  NumberLiteral,\n\n  /**\n   * The true keyword.\n   */\n  True,\n  /**\n   * The false keyword.\n   */\n  False,\n  /**\n   * The undef keyword.\n   */\n  Undef,\n\n  /**\n   * !\n   */\n  Bang,\n  /**\n   * <\n   */\n  Less,\n  /**\n   * >\n   */\n  Greater,\n  /**\n   * <=\n   */\n  LessEqual,\n  /**\n   * >=\n   */\n  GreaterEqual,\n  /**\n   * ==\n   */\n  EqualEqual,\n  /**\n   * =\n   */\n  Equal,\n  /**\n   * !=\n   */\n  BangEqual,\n  /**\n   * &&\n   */\n  AND,\n  /**\n   * ||\n   */\n  OR,\n\n  Plus,\n  Minus,\n  Star,\n  Slash,\n  Percent,\n  Caret,\n  \n  /**\n   * Left parenthesis: (\n   */\n  LeftParen,\n  /**\n   * Right parenthesis: )\n   */\n  RightParen,\n  /**\n   * Left bracket: [\n   */\n  LeftBracket,\n  /**\n   * Right bracket: ]\n   */\n  RightBracket,\n  /**\n   * Left brace: {\n   */\n  LeftBrace,\n  /**\n   * Right brace: }\n   */\n  RightBrace,\n  /**\n   * ;\n   */\n  Semicolon,\n  /**\n   * ,\n   */\n  Comma,\n  /**\n   * .\n   */\n  Dot,\n\n  /**\n   * The ? symbol\n   */\n  QuestionMark,\n\n  /**\n   * The : symbol\n   */\n  Colon,\n\n  /**\n   * The '#' symbol\n   */\n  Hash,\n\n  /**\n   * The filename of an imported file e.g. '<file.scad>'\n   */\n  FilenameInChevrons,\n\n  /**\n   * The include keyword.\n   */\n  Include,\n}\n\nexport default TokenType;\n", "import CodeLocation from \"./CodeLocation\";\nimport CodeSpan from \"./CodeSpan\";\nimport { ExtraToken, NewLineExtraToken } from \"./extraTokens\";\nimport TokenType from \"./TokenType\";\n\nexport default class Token {\n  /**\n   * All the newlines and comments that appear before this token and should be preserved when printing the AST.\n   */\n  public extraTokens: ExtraToken[] = [];\n\n  /**\n   * Start of this token, including all the whitespace before it.\n   * \n   * Set externally in the lexer.\n   */\n  public startWithWhitespace!: CodeLocation;\n\n  constructor(\n    public type: TokenType,\n    public span: CodeSpan,\n    public lexeme: string\n  ) {}\n\n  toString(): string {\n    return `token ${TokenType[this.type]} ${this.span.toString()}`;\n  }\n\n  hasNewlineInExtraTokens() {\n    return this.extraTokens.some((t) => t instanceof NewLineExtraToken);\n  }\n}\n", "import ASTNode from \"./ast/ASTNode\";\nimport ASTVisitor from \"./ast/ASTVisitor\";\nimport ASTAssembler from \"./ASTAssembler\";\nimport CodeLocation from \"./CodeLocation\";\nimport Token from \"./Token\";\n\nexport const BinAfter = Symbol(\"BinAfter\");\nexport const BinBefore = Symbol(\"BinBefore\");\n\nexport type PinpointerRet = ASTNode | typeof BinAfter | typeof BinBefore;\n\nexport type DispatchTokenMix = (Token | (() => PinpointerRet))[];\n\n/**\n * This class searches through the AST to find a node based on its position.\n * It may return BinAfter or BinBefore if the node cannot be found.\n */\nexport default class ASTPinpointer\n  extends ASTAssembler<PinpointerRet>\n  implements ASTVisitor<PinpointerRet>\n{\n  /**\n   * Contains all the ancestors of the pinpointed nodes. The pinpointed node is always first.\n   */\n  public bottomUpHierarchy: ASTNode[] = [];\n\n  constructor(public pinpointLocation: CodeLocation) {\n    super();\n  }\n\n  /**\n   * Returns the node at pinpointLocation and populates bottomUpHierarchy.\n   * @param n The AST (or AST fragment) to search through.\n   */\n  doPinpoint(n: ASTNode): PinpointerRet {\n    this.bottomUpHierarchy = [];\n    return n.accept(this);\n  }\n  protected processAssembledNode(\n    t: DispatchTokenMix,\n    self: ASTNode\n  ): PinpointerRet {\n    let l = 0,\n      r = t.length - 1;\n    // perform a binary search on the tokens\n    while (l <= r) {\n      let pivot = Math.floor((r + l) / 2);\n      if (t[pivot] instanceof Token) {\n        const tokenAtPiviot = t[pivot] as Token;\n        if (tokenAtPiviot.span.end.char <= this.pinpointLocation.char) {\n          l = pivot + 1;\n          continue;\n        }\n        if (\n          tokenAtPiviot.startWithWhitespace.char > this.pinpointLocation.char\n        ) {\n          r = pivot - 1;\n          continue;\n        }\n        this.bottomUpHierarchy.push(self);\n        return self; // yay this is us\n      } else if (typeof t[pivot] === \"function\") {\n        const astFunc = t[pivot] as () => PinpointerRet;\n        const result = astFunc.call(this) as PinpointerRet;\n\n        if (result === BinBefore) {\n          r = pivot - 1;\n          continue;\n        }\n        if (result === BinAfter) {\n          l = pivot + 1;\n          continue;\n        }\n        if (result instanceof ASTNode) {\n          this.bottomUpHierarchy.push(self);\n          return result;\n        }\n      } else {\n        throw new Error(\n          `Bad element in token mix: ${typeof t[pivot]} at index ${pivot}.`\n        );\n      }\n    }\n    const firstThing = t[0];\n    if (firstThing instanceof Token) {\n      if (firstThing.span.end.char <= this.pinpointLocation.char) {\n        return BinAfter;\n      }\n      return BinBefore;\n    }\n    if (typeof firstThing === \"function\") {\n      return firstThing.call(this);\n    }\n    throw new Error(\n      `Bad element in first token mix element. Recieved ${firstThing}, expected a function or a Token.`\n    );\n  }\n}\n", "import { LiteralToken } from \".\";\nimport AssignmentNode from \"./ast/AssignmentNode\";\nimport ASTVisitor from \"./ast/ASTVisitor\";\nimport ErrorNode from \"./ast/ErrorNode\";\nimport {\n  AnonymousFunctionExpr,\n  ArrayLookupExpr,\n  AssertExpr,\n  BinaryOpExpr,\n  EchoExpr,\n  FunctionCallExpr,\n  GroupingExpr,\n  LcEachExpr,\n  LcForCExpr,\n  LcForExpr,\n  LcIfExpr,\n  LcLetExpr,\n  LetExpr,\n  LiteralExpr,\n  LookupExpr,\n  MemberLookupExpr,\n  RangeExpr,\n  TernaryExpr,\n  UnaryOpExpr,\n  VectorExpr,\n} from \"./ast/expressions\";\nimport ScadFile from \"./ast/ScadFile\";\nimport {\n  BlockStmt,\n  FunctionDeclarationStmt,\n  IfElseStatement,\n  IncludeStmt,\n  ModuleDeclarationStmt,\n  ModuleInstantiationStmt,\n  NoopStmt,\n  Statement,\n  UseStmt,\n} from \"./ast/statements\";\nimport {\n  MultiLineComment,\n  NewLineExtraToken,\n  SingleLineComment,\n} from \"./extraTokens\";\nimport FormattingConfiguration from \"./FormattingConfiguration\";\nimport Token from \"./Token\";\nimport TokenType from \"./TokenType\";\n\nexport default class ASTPrinter implements ASTVisitor<string> {\n  indentLevel = 0;\n  breakBetweenModuleInstantations = false;\n  firstModuleInstantation = true;\n  doNotAddNewlineAfterBlockStatement = false;\n  /**\n   * We store data that is global between all the copies of the ASTPrinter in an object so that it is passed by reference.\n   */\n  deepGlobals = {\n    didAddNewline: false,\n    shouldAddNewlineAfterNextComment: false,\n    newlineAfterNextCommentReason: \"\",\n  };\n\n  constructor(public config: FormattingConfiguration) {}\n\n  visitErrorNode(n: ErrorNode): string {\n    throw new Error(\"Cannot pretty print ast with an error node.\");\n  }\n\n  visitScadFile(n: ScadFile): string {\n    let source = \"\";\n    for (const stmt of n.statements) {\n      source += this.processStatementWithBreakIfNeeded(stmt);\n    }\n    source += this.stringifyExtraTokens(n.tokens.eot);\n    return source;\n  }\n  visitAssignmentNode(n: AssignmentNode): string {\n    let source = \"\";\n    if (n.name) {\n      source += this.stringifyExtraTokens(n.tokens.name!);\n      source += n.name;\n      if (n.tokens.equals) {\n        source += this.stringifyExtraTokens(n.tokens.equals);\n        source += \" = \";\n      }\n    }\n\n    if (n.value) {\n      source += n.value.accept(this);\n    }\n\n    if (n.tokens.trailingCommas && n.tokens.trailingCommas.length > 0) {\n      for (const tc of n.tokens.trailingCommas) {\n        source += this.stringifyExtraTokens(tc);\n      }\n      source += \", \";\n    }\n\n    if (n.tokens.semicolon) {\n      source += this.stringifyExtraTokens(n.tokens.semicolon);\n      source += \";\";\n      this.newLineAfterNextComment(\"after assignment\");\n    }\n\n    return source;\n  }\n  visitUnaryOpExpr(n: UnaryOpExpr): string {\n    let source = \"\";\n    source += this.stringifyExtraTokens(n.tokens.operator);\n    if (n.operation === TokenType.Bang) {\n      source += \"!\";\n    } else if (n.operation === TokenType.Plus) {\n      source += \"+\";\n    } else if (n.operation === TokenType.Minus) {\n      source += \"-\";\n    }\n    source += n.right.accept(this);\n    return source;\n  }\n  visitBinaryOpExpr(n: BinaryOpExpr): string {\n    let source = \"\";\n    source += n.left.accept(this);\n    source += this.stringifyExtraTokens(n.tokens.operator);\n    source += \" \";\n    if (n.operation === TokenType.Star) {\n      source += \"*\";\n    } else if (n.operation === TokenType.Slash) {\n      source += \"/\";\n    } else if (n.operation === TokenType.Caret) {\n      source += \"^\";\n    } else if (n.operation === TokenType.Percent) {\n      source += \"%\";\n    } else if (n.operation === TokenType.Less) {\n      source += \"<\";\n    } else if (n.operation === TokenType.LessEqual) {\n      source += \"<=\";\n    } else if (n.operation === TokenType.Greater) {\n      source += \">\";\n    } else if (n.operation === TokenType.GreaterEqual) {\n      source += \">=\";\n    } else if (n.operation === TokenType.AND) {\n      source += \"&&\";\n    } else if (n.operation === TokenType.OR) {\n      source += \"||\";\n    } else if (n.operation === TokenType.EqualEqual) {\n      source += \"==\";\n    } else if (n.operation === TokenType.BangEqual) {\n      source += \"!=\";\n    } else if (n.operation === TokenType.Plus) {\n      source += \"+\";\n    } else if (n.operation === TokenType.Minus) {\n      source += \"-\";\n    }\n    source += \" \";\n    source += n.right.accept(this);\n    return source;\n  }\n  visitTernaryExpr(n: TernaryExpr): string {\n    let source = \"\";\n    source += n.cond.accept(this);\n    source += this.stringifyExtraTokens(n.tokens.questionMark);\n    source += \" ? \";\n    source += n.ifExpr.accept(this);\n    source += this.stringifyExtraTokens(n.tokens.colon);\n    source += \" : \";\n    source += n.elseExpr.accept(this);\n    return source;\n  }\n  visitArrayLookupExpr(n: ArrayLookupExpr): string {\n    let source = \"\";\n    source += n.array.accept(this);\n    source += this.stringifyExtraTokens(n.tokens.firstBracket);\n    source += \"[\";\n    source += n.index.accept(this);\n    source += this.stringifyExtraTokens(n.tokens.secondBracket);\n    source += \"]\";\n    return source;\n  }\n  visitLiteralExpr(n: LiteralExpr<any>): string {\n    let source = \"\";\n\n    source += this.stringifyExtraTokens(n.tokens.literalToken);\n    if (n.value === null) {\n      source += \"undef\";\n    } else if (typeof n.value === \"string\") {\n      source += JSON.stringify(n.value); // TODO: change to a custom stringification function\n    } else {\n      source += n.value;\n    }\n\n    return source;\n  }\n  visitRangeExpr(n: RangeExpr): string {\n    let source = \"\";\n\n    source += this.stringifyExtraTokens(n.tokens.firstBracket);\n    source += \"[\";\n\n    source += n.begin.accept(this);\n    source += this.stringifyExtraTokens(n.tokens.firstColon);\n    source += \" : \";\n    if (n.step && n.tokens.secondColon) {\n      source += n.step.accept(this);\n      source += this.stringifyExtraTokens(n.tokens.secondColon);\n      source += \" : \";\n    }\n    source += n.end.accept(this);\n    source += this.stringifyExtraTokens(n.tokens.secondBracket);\n    source += \"]\";\n    return source;\n  }\n  visitVectorExpr(n: VectorExpr): string {\n    let source = \"\";\n    source += this.stringifyExtraTokens(n.tokens.firstBracket);\n    source += \"[\";\n    let commaI = 0;\n    for (let i = 0; i < n.children.length; i++) {\n      const child = n.children[i];\n      source += child.accept(this.copyWithIndent());\n      if (i < n.children.length - 1) {\n        source += this.stringifyExtraTokens(n.tokens.commas[commaI]);\n        commaI++;\n        source += \", \";\n      }\n    }\n    for (; commaI < n.tokens.commas.length; commaI++) {\n      source += this.stringifyExtraTokens(n.tokens.commas[commaI]);\n    }\n\n    source += this.stringifyExtraTokens(n.tokens.secondBracket);\n    source += \"]\";\n    return source;\n  }\n  visitLookupExpr(n: LookupExpr): string {\n    let source = \"\";\n\n    source += this.stringifyExtraTokens(n.tokens.identifier);\n    source += n.name;\n\n    return source;\n  }\n  visitMemberLookupExpr(n: MemberLookupExpr): string {\n    let source = \"\";\n    source += n.expr.accept(this);\n    source += this.stringifyExtraTokens(n.tokens.dot);\n    source += \".\";\n    source += this.stringifyExtraTokens(n.tokens.memberName);\n    source += n.member;\n\n    return source;\n  }\n  visitFunctionCallExpr(n: FunctionCallExpr): string {\n    let source = n.callee.accept(this);\n    source += this.stringifyExtraTokens(n.tokens.firstParen);\n    source += \"(\";\n    for (let i = 0; i < n.args.length; i++) {\n      const arg = n.args[i];\n      source += arg.accept(this);\n      //   if (i < n.args.length - 1) {\n      //     source += \", \";\n      //   }\n    }\n    source += this.stringifyExtraTokens(n.tokens.secondParen);\n    source += \")\";\n    return source;\n  }\n  visitLetExpr(n: LetExpr): string {\n    let source = \"\";\n    source += this.stringifyExtraTokens(n.tokens.name);\n    source += \"let\";\n    source += this.stringifyExtraTokens(n.tokens.firstParen);\n    source += \"(\";\n    for (let i = 0; i < n.args.length; i++) {\n      const arg = n.args[i];\n      source += arg.accept(this.copyWithIndent());\n    }\n    source += this.stringifyExtraTokens(n.tokens.secondParen);\n    source += \")\";\n    source += \" \";\n    source += n.expr.accept(this);\n    return source;\n  }\n  visitAssertExpr(n: AssertExpr): string {\n    let source = \"\";\n    source += this.stringifyExtraTokens(n.tokens.name);\n    source += \"assert\";\n    source += this.stringifyExtraTokens(n.tokens.firstParen);\n    source += \"(\";\n    for (let i = 0; i < n.args.length; i++) {\n      const arg = n.args[i];\n      source += arg.accept(this);\n      //   if (i < n.args.length - 1) {\n      //     source += \", \";\n      //   }\n    }\n    source += this.stringifyExtraTokens(n.tokens.secondParen);\n    source += \")\";\n    source += \" \";\n    source += n.expr.accept(this);\n    return source;\n  }\n  visitEchoExpr(n: EchoExpr): string {\n    let source = \"\";\n    source += this.stringifyExtraTokens(n.tokens.name);\n    source += \"echo\";\n    source += this.stringifyExtraTokens(n.tokens.firstParen);\n    source += \"(\";\n    for (let i = 0; i < n.args.length; i++) {\n      const arg = n.args[i];\n      source += arg.accept(this);\n      //   if (i < n.args.length - 1) {\n      //     source += \", \";\n      //   }\n    }\n    source += this.stringifyExtraTokens(n.tokens.secondParen);\n    source += \")\";\n    source += \" \";\n    source += n.expr.accept(this);\n    return source;\n  }\n  visitLcIfExpr(n: LcIfExpr): string {\n    let source = \"\";\n    source += this.stringifyExtraTokens(n.tokens.ifKeyword);\n    source += \"if\";\n    source += this.stringifyExtraTokens(n.tokens.firstParen);\n    source += \"(\";\n    source += n.cond.accept(this);\n    source += this.stringifyExtraTokens(n.tokens.secondParen);\n    source += \") \";\n    source += n.ifExpr.accept(this);\n    if (n.elseExpr && n.tokens.elseKeyword) {\n      source += this.stringifyExtraTokens(n.tokens.elseKeyword);\n      source += \" else \";\n      source += n.elseExpr.accept(this);\n    }\n\n    return source;\n  }\n  visitLcEachExpr(n: LcEachExpr): string {\n    let source = \"\";\n    source += this.stringifyExtraTokens(n.tokens.eachKeyword);\n    source += \"each \";\n    source += n.expr.accept(this);\n    return source;\n  }\n  visitLcForExpr(n: LcForExpr): string {\n    let source = \"\";\n    source += this.stringifyExtraTokens(n.tokens.forKeyword);\n    source += \"for\";\n    source += this.stringifyExtraTokens(n.tokens.firstParen);\n    source += \"(\";\n    for (let i = 0; i < n.args.length; i++) {\n      const arg = n.args[i];\n      source += arg.accept(this);\n    }\n    source += this.stringifyExtraTokens(n.tokens.secondParen);\n    source += \") \";\n    source += n.expr.accept(this);\n\n    return source;\n  }\n  visitLcForCExpr(n: LcForCExpr): string {\n    let source = \"\";\n    source += this.stringifyExtraTokens(n.tokens.forKeyword);\n    source += \"for\";\n    source += this.stringifyExtraTokens(n.tokens.firstParen);\n    source += \"(\";\n    for (let i = 0; i < n.args.length; i++) {\n      const arg = n.args[i];\n      source += arg.accept(this);\n    }\n    source += this.stringifyExtraTokens(n.tokens.firstSemicolon);\n    source += \"; \";\n    source += n.cond.accept(this);\n    source += this.stringifyExtraTokens(n.tokens.secondSemicolon);\n    source += \"; \";\n    for (let i = 0; i < n.incrArgs.length; i++) {\n      const arg = n.incrArgs[i];\n      source += arg.accept(this);\n    }\n    source += this.stringifyExtraTokens(n.tokens.secondParen);\n    source += \") \";\n    source += n.expr.accept(this);\n\n    return source;\n  }\n  visitLcLetExpr(n: LcLetExpr): string {\n    let source = \"\";\n    source += this.stringifyExtraTokens(n.tokens.letKeyword);\n    source += \"let\";\n    source += this.stringifyExtraTokens(n.tokens.firstParen);\n    source += \"(\";\n    for (let i = 0; i < n.args.length; i++) {\n      const arg = n.args[i];\n      source += arg.accept(this);\n    }\n    source += this.stringifyExtraTokens(n.tokens.secondParen);\n    source += \") \";\n    source += n.expr.accept(this);\n\n    return source;\n  }\n  visitGroupingExpr(n: GroupingExpr): string {\n    let source = \"\";\n\n    source += this.stringifyExtraTokens(n.tokens.firstParen);\n    source += \"(\";\n    source += n.inner.accept(this);\n    source += this.stringifyExtraTokens(n.tokens.secondParen);\n    source += \")\";\n    return source;\n  }\n  visitUseStmt(n: UseStmt): string {\n    let source = \"\";\n    source += this.stringifyExtraTokens(n.tokens.useKeyword);\n    source +=\n      \"use \" +\n      this.stringifyExtraTokens(n.tokens.filename) +\n      \" <\" +\n      n.filename +\n      \">\" +\n      this.newLine();\n    return source;\n  }\n\n  visitIncludeStmt(n: IncludeStmt): string {\n    let source = \"\";\n    source += this.stringifyExtraTokens(n.tokens.includeKeyword);\n    source +=\n      \"include \" +\n      this.stringifyExtraTokens(n.tokens.filename) +\n      \" <\" +\n      n.filename +\n      \">\" +\n      this.newLine();\n    return source;\n  }\n\n  visitModuleInstantiationStmt(n: ModuleInstantiationStmt): string {\n    let source = \"\";\n    source += n.tokens.modifiersInOrder\n      .map((tk) => this.stringifyExtraTokens(tk) + tk.lexeme)\n      .join(\" \");\n    if (source != \"\") {\n      source += \" \";\n    }\n    source += this.stringifyExtraTokens(n.tokens.name);\n    source += n.name;\n    source += this.stringifyExtraTokens(n.tokens.firstParen);\n    source += \"(\";\n    for (let i = 0; i < n.args.length; i++) {\n      const arg = n.args[i];\n      source += arg.accept(this);\n      //   if (i < n.args.length - 1) {\n      //     source += \", \";\n      //   }\n    }\n    source += this.stringifyExtraTokens(n.tokens.secondParen);\n    source += \")\";\n    if (\n      !(n.child instanceof NoopStmt) &&\n      !this.breakBetweenModuleInstantations\n    ) {\n      source += \" \";\n    }\n    if (this.breakBetweenModuleInstantations) {\n      if (n.child instanceof ModuleInstantiationStmt) {\n        let c = this as ASTPrinter;\n        if (this.firstModuleInstantation) {\n          c = this.copyWithIndent();\n          c.firstModuleInstantation = false;\n        }\n        this.newLineAfterNextComment(\"breakBetweenModuleInstantations\");\n        source += n.child.accept(c);\n      } else {\n        const c = this.copyWithBreakBetweenModuleInstantations(false);\n        c.firstModuleInstantation = true;\n        if (n.child) source += n.child.accept(c);\n      }\n    } else {\n      let c: ASTPrinter = this;\n      if (n.child instanceof ModuleInstantiationStmt) {\n        if (\n          this.firstModuleInstantation &&\n          n.child.tokens.name.hasNewlineInExtraTokens()\n        ) {\n          c = this.copyWithIndent();\n          c.firstModuleInstantation = false;\n        }\n      } else {\n        c.firstModuleInstantation = true;\n      }\n      if (n.child) source += n.child.accept(c);\n    }\n    return source;\n  }\n  visitModuleDeclarationStmt(n: ModuleDeclarationStmt): string {\n    let source = \"\";\n    source += this.stringifyExtraTokens(n.tokens.moduleKeyword);\n    source += \"module \";\n    source += this.stringifyExtraTokens(n.tokens.name);\n    source += (n.tokens.name as LiteralToken<string>).value;\n    source += this.stringifyExtraTokens(n.tokens.firstParen);\n    source += \"(\";\n    for (let i = 0; i < n.definitionArgs.length; i++) {\n      const arg = n.definitionArgs[i];\n      source += arg.accept(this);\n    }\n    source += this.stringifyExtraTokens(n.tokens.secondParen);\n    source += \")\";\n    if (!this.config.definitionsOnly) {\n      if (!(n.stmt instanceof NoopStmt)) {\n        source += \" \";\n      }\n      source += n.stmt.accept(this);\n    }\n    return source;\n  }\n  visitFunctionDeclarationStmt(n: FunctionDeclarationStmt): string {\n    let source = \"\";\n    source += this.stringifyExtraTokens(n.tokens.functionKeyword);\n    source += \"function \";\n    source += this.stringifyExtraTokens(n.tokens.name);\n    source += n.name;\n    source += this.stringifyExtraTokens(n.tokens.firstParen);\n    source += \"(\";\n    for (let i = 0; i < n.definitionArgs.length; i++) {\n      const arg = n.definitionArgs[i];\n      source += arg.accept(this);\n      //   if (i < n.definitionArgs.length - 1) {\n      //     source += \", \";\n      //   }\n    }\n    source += this.stringifyExtraTokens(n.tokens.secondParen);\n    source += \")\";\n    if (!this.config.definitionsOnly) {\n      source += this.stringifyExtraTokens(n.tokens.equals);\n      source += \" = \";\n      source += n.expr.accept(this.copyWithIndent());\n      source += this.stringifyExtraTokens(n.tokens.semicolon);\n      source += \";\" + this.newLine(false, \"afterFunctionDeclaration\");\n    }\n    return source;\n  }\n  visitBlockStmt(n: BlockStmt): string {\n    let source = \"\";\n    source += this.stringifyExtraTokens(n.tokens.firstBrace);\n    let withIndent = this.copyWithIndent();\n    source += \"{\" + withIndent.newLine(false, \"beforeBlockStmt\");\n    if (this.doNotAddNewlineAfterBlockStatement) {\n      withIndent.doNotAddNewlineAfterBlockStatement = false;\n    }\n    for (const stmt of n.children) {\n      source += withIndent.processStatementWithBreakIfNeeded(stmt);\n    }\n    source += withIndent.stringifyExtraTokens(n.tokens.secondBrace);\n    // erease indentation\n    if (\n      n.tokens.secondBrace.extraTokens[\n        n.tokens.secondBrace.extraTokens.length - 1\n      ] instanceof NewLineExtraToken\n    ) {\n      source = source.substring(0, source.length - this.config.indentCount);\n    }\n    source += \"}\";\n    if (!this.doNotAddNewlineAfterBlockStatement) {\n      this.newLineAfterNextComment(\"afterBlockStmt\");\n    }\n    return source;\n  }\n  visitNoopStmt(n: NoopStmt): string {\n    let source = \"\";\n    source += this.stringifyExtraTokens(n.tokens.semicolon);\n    source += \";\";\n    return source;\n  }\n  visitIfElseStatement(n: IfElseStatement): string {\n    let source = \"\";\n    source += this.stringifyExtraTokens(n.tokens.ifKeyword);\n    source += \"if\";\n    source += this.stringifyExtraTokens(n.tokens.firstParen);\n    source += \"(\";\n    source += n.cond.accept(this);\n    source += this.stringifyExtraTokens(n.tokens.secondParen);\n    source += \")\";\n    if (!(n.thenBranch instanceof NoopStmt)) {\n      source += \" \";\n    }\n    source += n.thenBranch.accept(\n      n.tokens.elseKeyword\n        ? this.copyWithDoNotAddNewlineAfterBlockStatement()\n        : this\n    );\n    if (n.tokens.elseKeyword && n.elseBranch) {\n      source += this.stringifyExtraTokens(n.tokens.elseKeyword);\n      source += \" else\";\n      if (!(n.elseBranch instanceof NoopStmt)) {\n        source += \" \";\n      }\n      source += n.elseBranch.accept(this);\n    }\n    return source;\n  }\n  visitAnonymousFunctionExpr(n: AnonymousFunctionExpr): string {\n    let source = \"\";\n    source += this.stringifyExtraTokens(n.tokens.functionKeyword);\n    source += \"function\";\n    source += this.stringifyExtraTokens(n.tokens.firstParen);\n    source += \"(\";\n    for (let i = 0; i < n.definitionArgs.length; i++) {\n      const arg = n.definitionArgs[i];\n      source += arg.accept(this);\n    }\n    source += this.stringifyExtraTokens(n.tokens.secondParen);\n    source += \")\";\n    if (!this.config.definitionsOnly) {\n      source += n.expr.accept(this.copyWithIndent());\n    }\n    return source;\n  }\n\n  /**\n   * Tries printing a ModuleInstantiationStmt without breaking it, if it exceeds 40 chars it breaks it, by printing it again.\n   * @param stmt\n   */\n  protected processStatementWithBreakIfNeeded(stmt: Statement) {\n    if (stmt instanceof ModuleInstantiationStmt) {\n      const saved = this.saveDeepGlobals();\n      const line = stmt.accept(this);\n\n      // try finding the first line without a comment and break if it is too long\n      const firstRealLine = line\n        .split(\"\\n\")\n        .find((l) => !!l.split(\"//\")[0].trim());\n\n      if (\n        firstRealLine &&\n        firstRealLine.length > this.config.moduleInstantiationBreakLength\n      ) {\n        this.restoreDeepGlobals(saved);\n        return stmt.accept(this.copyWithBreakBetweenModuleInstantations());\n      }\n      return line;\n    } else {\n      return stmt.accept(this);\n    }\n  }\n\n  protected stringifyExtraTokens(token: Token) {\n    const source = token.extraTokens\n      .map((et) => {\n        if (et instanceof NewLineExtraToken) {\n          if (this.deepGlobals.didAddNewline) {\n            this.deepGlobals.didAddNewline = false;\n            return \"\";\n          }\n          this.deepGlobals.shouldAddNewlineAfterNextComment = false;\n          return this.newLine(true, \"forcedNewlineExtraToken\");\n        }\n\n        if (\n          !this.config.definitionsOnly &&\n          (et instanceof MultiLineComment || et instanceof SingleLineComment)\n        ) {\n          let commentText = \"\";\n          if (this.deepGlobals.shouldAddNewlineAfterNextComment) {\n            commentText += \" \"; // add a spece since we are in the same line as the previous token\n          }\n          if (et instanceof MultiLineComment) {\n            commentText += \"/*\" + et.contents + \"*/\";\n          } else if (et instanceof SingleLineComment) {\n            commentText += \"//\" + et.contents;\n          }\n\n          // here we execute some logic to make sure that a newline is inserted after the comment if needed\n          // since the information about the comments and newlines is stored in the next token, we need to do this weird stuff\n          if (this.deepGlobals.shouldAddNewlineAfterNextComment) {\n            this.deepGlobals.shouldAddNewlineAfterNextComment = false;\n            return (\n              commentText +\n              this.newLine(\n                false,\n                this.deepGlobals.newlineAfterNextCommentReason\n              )\n            );\n          }\n\n          return commentText;\n        }\n        return \"\";\n      })\n      .reduce((prev, curr) => prev + curr, \"\");\n    this.deepGlobals.didAddNewline = false;\n    if (source === \"\" && this.deepGlobals.shouldAddNewlineAfterNextComment) {\n      this.deepGlobals.shouldAddNewlineAfterNextComment = false;\n      return this.newLine(\n        false,\n        this.deepGlobals.newlineAfterNextCommentReason\n      );\n    }\n    return source;\n  }\n  protected newLine(forced = false, newlineReason = \"no reason\") {\n    if (!forced) {\n      this.deepGlobals.didAddNewline = true;\n    }\n    if (this.config.debugNewlines) {\n      return `   /* NL: ${newlineReason} */` + \"\\n\" + this.makeIndent();\n    }\n    return \"\\n\" + this.makeIndent();\n  }\n\n  /**\n   * Schedules a newline to be added after the next comment, if present.\n   * Otherwise it will be inserted immediately.\n   */\n  protected newLineAfterNextComment(reason: string) {\n    this.deepGlobals.shouldAddNewlineAfterNextComment = true;\n    this.deepGlobals.newlineAfterNextCommentReason = reason;\n  }\n\n  protected makeIndent() {\n    let ind = \"\";\n    for (let i = 0; i < this.indentLevel * this.config.indentCount; i++) {\n      ind += this.config.indentChar;\n    }\n    return ind;\n  }\n\n  protected copy() {\n    const next = new ASTPrinter(this.config);\n    next.indentLevel = this.indentLevel;\n    next.deepGlobals = this.deepGlobals;\n    next.breakBetweenModuleInstantations = this.breakBetweenModuleInstantations;\n    return next;\n  }\n\n  protected copyWithIndent() {\n    const next = this.copy();\n    next.indentLevel++;\n    return next;\n  }\n\n  protected copyWithBreakBetweenModuleInstantations(doBreak = true) {\n    const next = this.copy();\n    next.breakBetweenModuleInstantations = doBreak;\n    return next;\n  }\n\n  protected copyWithDoNotAddNewlineAfterBlockStatement(val = true) {\n    const next = this.copy();\n    next.doNotAddNewlineAfterBlockStatement = val;\n    return next;\n  }\n\n  protected saveDeepGlobals() {\n    return JSON.parse(JSON.stringify(this.deepGlobals));\n  }\n\n  protected restoreDeepGlobals(dat: any) {\n    for (const k of Object.keys(dat)) {\n      (this.deepGlobals as any)[k] = dat[k];\n    }\n  }\n}\n", "// Empty shims for Node.js builtins that openscad-parser references\n// but doesn't use in browser context (fs, path, os are only used for\n// file loading features like include/use which we don't support)\nmodule.exports = {};\n", "import * as fs from \"fs\";\nimport * as path from \"path\";\n\nexport default class CodeFile {\n  constructor(public path: string, public code: string) {}\n\n  get filename() {\n    return path.basename(this.path);\n  }\n\n  /**\n   * Loads an openscad file from the filesystem.\n   */\n  static async load(pathToLoad: string): Promise<CodeFile> {\n    pathToLoad = path.resolve(pathToLoad); // normalize the path\n    const contents = await new Promise<string>((res, rej) => {\n      fs.readFile(\n        pathToLoad,\n        {\n          encoding: \"utf8\",\n        },\n        (err, data) => {\n          if (err) {\n            rej(err);\n            return;\n          }\n          res(data);\n        }\n      );\n    });\n    return new CodeFile(pathToLoad, contents);\n  }\n}\n", "import CodeFile from \"./CodeFile\";\n\n/**\n * THe number of lines to display when printing the context of the error.\n */\nconst CONTEXT_LINES_BEFORE = 5;\n\nexport default class CodeLocation {\n  constructor(\n    file: CodeFile | null = null,\n    char: number = 0,\n    line: number = 0,\n    col: number = 0\n  ) {\n    this.file = file;\n    this.char = char;\n    this.line = line;\n    this.col = col;\n  }\n\n  /**\n   * THe file to which this location points.\n   */\n  readonly file: CodeFile | null;\n\n  /**\n   * The character offset in the file contents.\n   */\n  readonly char: number = 0;\n\n  /**\n   * The line number of this location. Zero-indexed.\n   */\n  readonly line: number = 0;\n\n  /**\n   * The column number of this location. Zero-indexed.\n   */\n  readonly col: number = 0;\n\n  toString(): string {\n    return `file '${this.filename}' line ${\n      this.line + 1\n    } column ${this.col + 1}'`;\n  }\n\n  formatWithContext() {\n    if(!this.file) {\n      throw new Error(\"No CodeFile associated with this location\");\n    }\n    let outStr = `${this.filename}:${this.line + 1}:${this.col}:\\n`;\n    const sourceLines = this.file.code.split(\"\\n\");\n    const contextStartIndex = Math.max(0, this.line - CONTEXT_LINES_BEFORE);\n\n    const linesToDisplay = sourceLines.slice(contextStartIndex, this.line + 1);\n    outStr += linesToDisplay.reduce((prev, line, index) => {\n      return (\n        prev +\n        ` ${(contextStartIndex + index + 1).toString().padStart(3)}| ${line}\\n`\n      );\n    }, \"\");\n    outStr += \"\";\n    for (let i = -5; i < this.col; i++) {\n      outStr += \" \";\n    }\n    outStr += \"^\\n\";\n    return outStr;\n  }\n\n  private get filename(): string {\n    return this?.file?.filename || \"<unknown>\"\n  }\n}\n", "import CodeError from \"./errors/CodeError\";\n\nexport default class ErrorCollector {\n  errors: CodeError[] = [];\n  reportError<ET extends CodeError>(err: ET): ET {\n    this.errors.push(err);\n    return err;\n  }\n  printErrors() {\n    const msgs = this.errors.reduce((prev, e) => {\n      return (\n        prev +\n        e.codeLocation.formatWithContext() +\n        Object.getPrototypeOf(e).constructor.name +\n        \": \" +\n        e.message +\n        \"\\n\"\n      );\n    }, \"\");\n    console.log(msgs);\n  }\n  hasErrors() {\n    return this.errors.length > 0;\n  }\n  /**\n   * Throws the first error on the list. Used to simplify testing.\n   */\n  throwIfAny() {\n    if (this.errors.length > 0) {\n      throw this.errors[0];\n    }\n  }\n}\n", "export default class FormattingConfiguration {\n  indentChar = \" \";\n  indentCount = 4;\n  moduleInstantiationBreakLength = 40;\n\n  /**\n   * When sets to true the printer does not print bodies of functions and modules.\n   * Used for generating focumentation stubs.\n   */\n  definitionsOnly = false;\n\n  /**\n   * When set to true the formatter adds a comment to each newline describing its purpose.\n   */\n  debugNewlines = false;\n\n}\n", "import CodeLocation from \"../CodeLocation\";\n\n/**\n * A root class for all the errors generated during parsing and lexing.\n * @category Error\n */\nexport default abstract class CodeError extends Error {\n  constructor(public codeLocation: CodeLocation, message: string) {\n    super(message);\n  }\n}\n", "import CodeError from \"./CodeError\";\n\n/**\n * @category Error\n */\nexport default class LexingError extends CodeError {}\n", "import CodeLocation from \"../CodeLocation\";\nimport LexingError from \"./LexingError\";\n\n/**\n * @category Error\n */\nexport class UnterminatedMultilineCommentLexingError extends LexingError {\n  constructor(pos: CodeLocation) {\n    super(pos, `Unterminated multiline comment.`);\n  }\n}\n\n/**\n * @category Error\n */\nexport class SingleCharacterNotAllowedLexingError extends LexingError {\n  constructor(pos: CodeLocation, char: string) {\n    super(pos, `Single '${char}' is not allowed.`);\n  }\n}\n\n/**\n * @category Error\n */\nexport class UnexpectedCharacterLexingError extends LexingError {\n  constructor(pos: CodeLocation, char: string) {\n    super(pos, `Unexpected character '${char}'.`);\n  }\n}\n\n/**\n * @category Error\n */\nexport class IllegalStringEscapeSequenceLexingError extends LexingError {\n  constructor(pos: CodeLocation, sequence: string) {\n    super(pos, `Illegal string escape sequence '${sequence}'.`);\n  }\n}\n\n/**\n * @category Error\n */\nexport class UnterminatedStringLiteralLexingError extends LexingError {\n  constructor(pos: CodeLocation) {\n    super(pos, `Unterminated string literal.`);\n  }\n}\n\n/**\n * @category Error\n */\nexport class TooManyDotsInNumberLiteralLexingError extends LexingError {\n  constructor(pos: CodeLocation, lexeme: string) {\n    super(\n      pos,\n      `Too many dots in number literal ${lexeme}. Number literals must contain zero or one dot.`\n    );\n  }\n}\n\n/**\n * @category Error\n */\nexport class TooManyEInNumberLiteralLexingError extends LexingError {\n  constructor(pos: CodeLocation, lexeme: string) {\n    super(\n      pos,\n      `Too many 'e' separators in number literal ${lexeme}. Number literals must contain zero or one 'e'.`\n    );\n  }\n}\n\n/**\n * @category Error\n */\nexport class InvalidNumberLiteralLexingError extends LexingError {\n  constructor(pos: CodeLocation, lexeme: string) {\n    super(pos, `Invalid number literal ${lexeme}.`);\n  }\n}\n\n/**\n * @category Error\n */\nexport class UnterminatedFilenameLexingError extends LexingError {\n  constructor(pos: CodeLocation) {\n    super(pos, `Unterminated filename.`);\n  }\n}\n", "import TokenType from \"./TokenType\";\n\n/**\n * A dictionary which maps keyword string values to their TokenType.\n */\nconst keywords: { [x: string]: TokenType } = {\n  true: TokenType.True,\n  false: TokenType.False,\n  undef: TokenType.Undef,\n  module: TokenType.Module,\n  function: TokenType.Function,\n  if: TokenType.If,\n  else: TokenType.Else,\n  for: TokenType.For,\n  assert: TokenType.Assert,\n  each: TokenType.Each,\n  echo: TokenType.Echo,\n  use: TokenType.Use,\n  let: TokenType.Let,\n  include: TokenType.Include,\n};\n\nexport const keywordDocumentation: { [x: keyof typeof keywords]: string } = {\n  true: \"Represents the boolean value true.\",\n  false: \"Represents the boolean value false.\",\n  undef: `Represents the undefined value. \n\nIt's the initial value of a variable that hasn't been assigned a value, and it is often returned as a result by functions or operations that are passed illegal arguments. `,\n  module: `Starts a module declaration.\n\nUsage:\n\n${\"```scad\"}\nmodule my_module(arg = \"default\") {\n  // module code\n}\n${\"```\"}\n`,\n  function: `Starts a function declaration.\n\nUsage:\n\n${\"```scad\"}\nfunction my_function (x) = x * x;\n\n// or for anonymous functions\nsquare = function (x) x * x;\n\n${\"```\"}\n`,\n  if: `Starts an if statement or expression.\n\nUsage:\n\n${\"```scad\"}\nif (x > 0) {\n  // do something\n}\n${\"```\"}\n`,\n  else: `Marks the beginning of an else block in an if statement.\n\nUsage:\n${\"```scad\"}\nif (x > 0) {\n  // if x is positive\n} else {\n  // if x is zero or negative\n}\n${\"```\"}\n`,\n  for: `Starts a for loop.\n\nUsage:\n\n${\"```scad\"}\nfor ( i = [0 : 5] ){\n  rotate( i * 60, [1, 0, 0])\n  translate([0, 10, 0])\n  sphere(r = 10);\n}\n${\"```\"}\n`,\n  assert: `Starts an assert statement.\n\nUsage:\n\n${\"```scad\"}\nassert(x > 0, \"x is not positive\");\n\n${\"```\"}\n`,\n};\n\nexport default keywords;\n", "import CodeSpan from \"./CodeSpan\";\nimport Token from \"./Token\";\nimport TokenType from \"./TokenType\";\n\n/**\n * This represents a token which contains a literal value (e.g. string literal, number literal and identifiers.).\n */\nexport default class LiteralToken<ValueT> extends Token {\n  constructor(\n    type: TokenType,\n    span: CodeSpan,\n    lexeme: string,\n    public value: ValueT\n  ) {\n    super(type, span, lexeme);\n  }\n}\n", "import CodeFile from \"./CodeFile\";\nimport CodeLocation from \"./CodeLocation\";\nimport CodeSpan from \"./CodeSpan\";\nimport ErrorCollector from \"./ErrorCollector\";\nimport {\n  IllegalStringEscapeSequenceLexingError,\n  InvalidNumberLiteralLexingError,\n  SingleCharacterNotAllowedLexingError,\n  TooManyDotsInNumberLiteralLexingError,\n  TooManyEInNumberLiteralLexingError,\n  UnexpectedCharacterLexingError,\n  UnterminatedFilenameLexingError,\n  UnterminatedMultilineCommentLexingError,\n  UnterminatedStringLiteralLexingError,\n} from \"./errors/lexingErrors\";\nimport {\n  ExtraToken,\n  MultiLineComment,\n  NewLineExtraToken,\n  SingleLineComment,\n} from \"./extraTokens\";\nimport keywords from \"./keywords\";\nimport LiteralToken from \"./LiteralToken\";\nimport Token from \"./Token\";\nimport TokenType from \"./TokenType\";\n\n/**\n * The lexer is responsible for turning a string of characters into a stream of\n * tokens. The tokens are then used by the parser to build an abstract syntax\n * tree.\n *\n * The lexer handles parsing of string literals, digraphs (e.g. `<=`), and numbers.\n * It also handles detecting keywords and identifiers.\n */\nexport default class Lexer {\n  protected start!: CodeLocation;\n  protected startWithWhitespace!: CodeLocation;\n  public tokens: Token[] = [];\n  protected currentExtraTokens: ExtraToken[] = [];\n\n  protected charOffset = 0;\n  protected lineOffset = 0;\n  protected colOffset = 0;\n  protected _currLocCache: CodeLocation | null = null;\n\n  constructor(\n    public codeFile: CodeFile,\n    public errorCollector: ErrorCollector\n  ) {}\n  /**\n   * Scans the whole CodeFile and splits it into tokens.\n   * @throws LexingError\n   */\n  scan(): Token[] {\n    this.start = this.getLoc();\n    this.startWithWhitespace = this.getLoc();\n    while (!this.isAtEnd()) {\n      this.start = this.getLoc();\n      this.scanToken();\n    }\n    this.start = this.getLoc();\n    this.addToken(TokenType.Eot);\n    return this.tokens;\n  }\n\n  protected scanToken() {\n    const c = this.advance();\n    switch (c) {\n      case \"(\":\n        this.addToken(TokenType.LeftParen);\n        break;\n      case \")\":\n        this.addToken(TokenType.RightParen);\n        break;\n      case \"{\":\n        this.addToken(TokenType.LeftBrace);\n        break;\n      case \"}\":\n        this.addToken(TokenType.RightBrace);\n        break;\n      case \"[\":\n        this.addToken(TokenType.LeftBracket);\n        break;\n      case \"]\":\n        this.addToken(TokenType.RightBracket);\n        break;\n      case \"+\":\n        this.addToken(TokenType.Plus);\n        break;\n      case \"-\":\n        this.addToken(TokenType.Minus);\n        break;\n      case \"%\":\n        this.addToken(TokenType.Percent);\n        break;\n      case \"*\":\n        this.addToken(TokenType.Star);\n        break;\n      case \"^\":\n        this.addToken(TokenType.Caret);\n        break;\n      case \"/\":\n        if (this.match(\"/\")) {\n          const comment = new SingleLineComment(this.getLoc(), \"\");\n          // consume a comment\n          while (this.peek() != \"\\n\" && !this.isAtEnd()) {\n            comment.contents += this.advance();\n          }\n          this.currentExtraTokens.push(comment);\n        } else if (this.match(\"*\")) {\n          const comment = new MultiLineComment(this.getLoc(), \"\");\n\n          // multiline comment\n          while (\n            !(this.peek() == \"*\" && this.peekNext() == \"/\") &&\n            !this.isAtEnd()\n          ) {\n            comment.contents += this.advance();\n          }\n          if (this.isAtEnd()) {\n            throw this.errorCollector.reportError(\n              new UnterminatedMultilineCommentLexingError(this.getLoc())\n            );\n          }\n          this.currentExtraTokens.push(comment);\n          this.advance(); // advance the star\n          this.advance(); // advance the slash\n        } else {\n          this.addToken(TokenType.Slash);\n        }\n        break;\n      case \".\":\n        // allow lexing of numbers without the leading 0\n        if (/[0-9]/.test(this.peek())) {\n          this.consumeNumberLiteral();\n          break;\n        }\n        this.addToken(TokenType.Dot);\n        break;\n      case \",\":\n        this.addToken(TokenType.Comma);\n        break;\n      case \":\":\n        this.addToken(TokenType.Colon);\n        break;\n      case \"?\":\n        this.addToken(TokenType.QuestionMark);\n        break;\n      case \";\":\n        this.addToken(TokenType.Semicolon);\n        break;\n      case \"#\":\n        this.addToken(TokenType.Hash);\n        break;\n      case \"!\":\n        if (this.match(\"=\")) {\n          this.addToken(TokenType.BangEqual);\n        } else {\n          this.addToken(TokenType.Bang);\n        }\n        break;\n      case \"<\":\n        if (this.match(\"=\")) {\n          this.addToken(TokenType.LessEqual);\n        } else {\n          this.addToken(TokenType.Less);\n        }\n        break;\n      case \">\":\n        if (this.match(\"=\")) {\n          this.addToken(TokenType.GreaterEqual);\n        } else {\n          this.addToken(TokenType.Greater);\n        }\n        break;\n      case \"=\":\n        if (this.match(\"=\")) {\n          this.addToken(TokenType.EqualEqual);\n        } else {\n          this.addToken(TokenType.Equal);\n        }\n        break;\n      case \"&\":\n        if (this.match(\"&\")) {\n          this.addToken(TokenType.AND);\n        } else {\n          throw this.errorCollector.reportError(\n            new SingleCharacterNotAllowedLexingError(this.getLoc(), \"&\")\n          );\n        }\n        break;\n      case \"|\":\n        if (this.match(\"|\")) {\n          this.addToken(TokenType.OR);\n        } else {\n          throw this.errorCollector.reportError(\n            new SingleCharacterNotAllowedLexingError(this.getLoc(), \"&\")\n          );\n        }\n        break;\n      case \"\\n\":\n        this.currentExtraTokens.push(new NewLineExtraToken(this.getLoc()));\n        break;\n      case \"\\r\":\n      case \" \":\n      case \"\\t\":\n        break; // ignore whitespace\n      case '\"':\n        this.consumeStringLiteral();\n        break;\n      default:\n        if (/[0-9]/.test(c)) {\n          this.consumeNumberOrIdentifierOrKeyword();\n        } else if (/[A-Za-z\\$_]/.test(c)) {\n          this.consumeIdentifierOrKeyword();\n        } else {\n          throw this.errorCollector.reportError(\n            new UnexpectedCharacterLexingError(this.getLoc(), c)\n          );\n        }\n    }\n  }\n  protected consumeStringLiteral() {\n    let str = \"\";\n    while (this.peek() != '\"' && !this.isAtEnd()) {\n      const c = this.advance();\n      // handle escape sequences\n      if (c == \"\\\\\") {\n        if (this.match('\"')) {\n          str += '\"';\n        } else if (this.match(\"\\\\\")) {\n          str += \"\\\\\";\n        } else if (this.match(\"n\")) {\n          str += \"\\n\";\n        } else if (this.match(\"t\")) {\n          str += \"\\t\";\n        } else if (this.match(\"r\")) {\n          str += \"\\r\";\n        } else {\n          throw this.errorCollector.reportError(\n            new IllegalStringEscapeSequenceLexingError(this.getLoc(), `\\\\${c}`)\n          );\n        }\n        //TODO: Add unicode escape sequences handling\n      } else {\n        str += c;\n      }\n    }\n    if (this.isAtEnd()) {\n      throw this.errorCollector.reportError(\n        new UnterminatedStringLiteralLexingError(this.getLoc())\n      );\n    }\n    this.advance();\n    this.addToken(TokenType.StringLiteral, str);\n  }\n  protected consumeNumberLiteral() {\n    let ateDigit = /[0-9]/.test(this.codeFile.code[this.start.char]);\n    let ateDot = \".\" === this.codeFile.code[this.start.char];\n    let justAteExp = false;\n\n    while (\n      /[0-9]/.test(this.peek()) ||\n      (this.peek() == \".\" && /[0-9]/.test(this.peekNext())) ||\n      ((this.peek() == \"e\" || this.peek() == \"E\") &&\n        /[0-9\\-+]/.test(this.peekNext())) ||\n      (this.peek() == \"-\" && /[0-9]/.test(this.peekNext()) && justAteExp) ||\n      (this.peek() == \"+\" && /[0-9]/.test(this.peekNext()) && justAteExp) ||\n      (this.peek() == \".\" && ateDigit && !ateDot)\n    ) {\n      ateDigit = ateDigit || /[0-9]/.test(this.peek());\n      ateDot = ateDot || this.peek() == \".\";\n      justAteExp = this.peek() == \"e\" || this.peek() == \"E\";\n      this.advance();\n    }\n    const lexeme = this.codeFile.code.substring(\n      this.start.char,\n      this.charOffset\n    );\n    if ((lexeme.match(/\\./g) || []).length > 1) {\n      throw this.errorCollector.reportError(\n        new TooManyDotsInNumberLiteralLexingError(this.getLoc(), lexeme)\n      );\n    }\n    if ((lexeme.match(/e/g) || []).length > 1) {\n      throw this.errorCollector.reportError(\n        new TooManyEInNumberLiteralLexingError(this.getLoc(), lexeme)\n      );\n    }\n    const value = parseFloat(lexeme);\n    if (isNaN(value) || !isFinite(value)) {\n      throw this.errorCollector.reportError(\n        new InvalidNumberLiteralLexingError(this.getLoc(), lexeme)\n      );\n    }\n    this.addToken(TokenType.NumberLiteral, value);\n  }\n  protected consumeIdentifierOrKeyword() {\n    while (/[A-Za-z0-9_\\$]/.test(this.peek()) && !this.isAtEnd()) {\n      this.advance();\n    }\n    const lexeme = this.codeFile.code.substring(\n      this.start.char,\n      this.charOffset\n    );\n    if (lexeme in keywords) {\n      const keywordType = keywords[lexeme];\n      this.addToken(keywordType);\n      // check if we need to lex a filename\n      if (keywordType === TokenType.Use || keywordType === TokenType.Include) {\n        this.consumeFileNameInChevrons();\n      }\n      return;\n    }\n    this.addToken(TokenType.Identifier, lexeme);\n  }\n\n  protected consumeNumberOrIdentifierOrKeyword() {\n    // OpenSCAD does accept identifiers starting with a digit.\n    // `9e9e9=1;echo(9e9e9);` is a valid code, `9e9=1;` produces a syntax error.\n    // Docs don't specify how conflicts are resolved, but from experiments\n    // it seems like a number is chosen unless an identifier is a longer match.\n    // That would be consistent with how lex/flex generated lexers work.\n\n    let wordLength = 1;\n    while (\n      this.start.char + wordLength < this.codeFile.code.length &&\n      /[0-9a-zA-Z_\\$]/.test(this.codeFile.code[this.start.char + wordLength])\n    ) {\n      wordLength++;\n    }\n\n    const possibleNumberStarts = [\n      this.peekRegex(/^[0-9]+/),\n      this.peekRegex(/^[0-9]+[.]/),\n      this.peekRegex(/^[0-9]+[eE][+-]?[0-9]+/),\n    ];\n    const numberLength = Math.max(...possibleNumberStarts.map((x) => x.length));\n\n    // If number is longer or same length as an indentifier - number wins.\n    if (numberLength >= wordLength) {\n      return this.consumeNumberLiteral();\n    } else {\n      return this.consumeIdentifierOrKeyword();\n    }\n  }\n\n  protected consumeFileNameInChevrons() {\n    this.startWithWhitespace = this.getLoc();\n    while (!this.isAtEnd()) {\n      this.start = this.getLoc();\n      if (\n        this.match(\"\\n\") ||\n        this.match(\"\\t\") ||\n        this.match(\"\\r\") ||\n        this.match(\" \")\n      )\n        continue; // ignore whitespace\n\n      if (this.match(\"<\")) break;\n      // The openscad parser does not allow putting comments like this: `use /* ddd*/ <file.scad>`\n      // We must check that and report an error\n      throw this.errorCollector.reportError(\n        new UnexpectedCharacterLexingError(this.getLoc(), this.advance())\n      );\n    }\n    if (this.isAtEnd()) {\n      throw this.errorCollector.reportError(\n        new UnterminatedFilenameLexingError(this.getLoc())\n      );\n    }\n    let filename = \"\";\n    let didEnd = false;\n    while (!this.isAtEnd()) {\n      const c = this.advance();\n      if (c === \">\") {\n        didEnd = true;\n        break;\n      }\n      filename += c;\n    }\n    if (!didEnd) {\n      throw this.errorCollector.reportError(\n        new UnterminatedFilenameLexingError(this.getLoc())\n      );\n    }\n    this.addToken(TokenType.FilenameInChevrons, filename);\n  }\n\n  /**\n   * Adds a token to the token list. If a value is provieded a LiteralToken is pushed.\n   *\n   * Additionally it handles clearing and attaching the extra tokens.\n   */\n  protected addToken<TValue = any>(\n    tokenType: TokenType,\n    value: TValue | null = null\n  ) {\n    const lexeme = this.codeFile.code.substring(\n      this.start.char,\n      this.charOffset\n    );\n    let token;\n    if (value != null) {\n      token = new LiteralToken(\n        tokenType,\n        new CodeSpan(this.start, this.getLoc()),\n        lexeme,\n        value\n      );\n    } else {\n      token = new Token(\n        tokenType,\n        new CodeSpan(this.start, this.getLoc()),\n        lexeme\n      );\n    }\n    token.extraTokens = this.currentExtraTokens;\n    token.startWithWhitespace = this.startWithWhitespace;\n    this.startWithWhitespace = this.getLoc();\n    this.currentExtraTokens = [];\n    this.tokens.push(token);\n  }\n  protected isAtEnd() {\n    return this.charOffset >= this.codeFile.code.length;\n  }\n  protected match(expected: string) {\n    if (this.isAtEnd()) return false;\n    if (this.codeFile.code[this.charOffset] !== expected) return false;\n    this.advance();\n    return true;\n  }\n  protected advance() {\n    const c = this.codeFile.code[this.charOffset];\n    this.charOffset++;\n    if (c === \"\\n\") {\n      this.lineOffset++;\n      this.colOffset = 0;\n    } else {\n      this.colOffset++;\n    }\n    this._currLocCache = null;\n    return c;\n  }\n\n  protected getLoc() {\n    if (!this._currLocCache) {\n      this._currLocCache = new CodeLocation(\n        this.codeFile,\n        this.charOffset,\n        this.lineOffset,\n        this.colOffset\n      );\n    }\n    return this._currLocCache;\n  }\n\n  protected peek() {\n    if (this.isAtEnd()) return \"\\0\";\n    return this.codeFile.code[this.charOffset];\n  }\n  protected peekNext() {\n    if (this.charOffset + 1 >= this.codeFile.code.length) return \"\\0\";\n    return this.codeFile.code[this.charOffset + 1];\n  }\n\n  protected peekRegex(regex: RegExp) {\n    const text = this.codeFile.code.slice(this.start.char);\n    const match = regex.exec(text);\n    return !match || match.index !== 0 ? \"\" : match[0];\n  }\n}\n", "/**\n * Adds special flags for built in constructs in the language.\n * Only for use in the prelude.\n * Used to mark the `for` and `intersection_for` modules as loops, and their arguments are in fact variable declarations.\n */\nexport class IntrinsicAnnotation {\n  static annotationTag = \"intrinsic\";\n  intrinsicType: string;\n  constructor(contents: string[]) {\n    this.intrinsicType = contents[0] || \"\";\n  }\n}\n\n/**\n * Renames this symbol to a diffrent name (which for example is a reserved keyword).\n * Used by the prelude to define `for` and `intersection_for` so that they can be resolved without errors.\n */\nexport class IntrinsicRenameAnnotation {\n  static annotationTag = \"intrinsicRename\";\n  newName: string;\n  constructor(contents: string[]) {\n    this.newName = contents[0] || \"\";\n  }\n}\n\n/**\n * An annotation with a link to online documentation.\n * @todo Add links to other source-code locations\n */\nexport class SeeAnnotation {\n  static annotationTag = \"see\";\n  link: string;\n  constructor(contents: string[]) {\n    this.link = contents[0] || \"\";\n  }\n}\n\n/**\n * Describes a module or function parameter annotation.\n * It has the form of `@param name [... optional tags] description`\n * The tags either contain a name (`[positional]`) for binary tags or a name and a value (`[conflictsWith=abc,cba]`)\n */\nexport class ParamAnnotation {\n  static annotationTag = \"param\";\n  link: string;\n  description: string;\n  tags: {\n    [x: string]: any;\n    positional: boolean;\n    named: boolean;\n    required: boolean;\n    type: string[];\n    conflictsWith: string[];\n    possibleValues: string[];\n  } = {\n    positional: false,\n    named: false,\n    required: false,\n    type: [],\n    conflictsWith: [],\n    possibleValues: [],\n  };\n  constructor(contents: string[]) {\n    this.link = contents[0] || \"\";\n    this.description = contents\n      .slice(1)\n      .filter((c) => {\n        let m = c.match(/^\\[(.*?)(=(.*))?\\]$/);\n        if (!m) return true;\n        if (!m[3]) {\n          // boolean tag, no value\n          this.tags[m[1]] = true;\n        } else {\n          this.tags[m[1]] = m[3].split(\",\");\n        }\n        return false;\n      })\n      .join(\" \");\n  }\n}\n", "import {\n  ExtraToken,\n  MultiLineComment,\n  NewLineExtraToken,\n  SingleLineComment,\n} from \"../extraTokens\";\nimport {\n  IntrinsicAnnotation,\n  IntrinsicRenameAnnotation,\n  ParamAnnotation,\n  SeeAnnotation,\n} from \"./annotations\";\nimport DocAnnotationClass from \"./DocAnnotationClass\";\n\nexport default class DocComment {\n  static possibleAnnotations: DocAnnotationClass[] = [\n    IntrinsicAnnotation,\n    IntrinsicRenameAnnotation,\n    ParamAnnotation,\n    SeeAnnotation,\n  ];\n  constructor(\n    public documentationContent: string,\n    public annotations: Object[]\n  ) {}\n  static fromExtraTokens(extraTokens: ExtraToken[]): DocComment {\n    const docComments: (MultiLineComment | SingleLineComment)[] = [];\n    let beginningNewlinesLimit = 5;\n    // iterate through the extra tokens backwards, looking from the annotated element\n    for (let i = extraTokens.length - 1; i >= 0; i--) {\n      if (extraTokens[i] instanceof NewLineExtraToken) {\n        beginningNewlinesLimit--;\n      }\n      if (\n        extraTokens[i] instanceof MultiLineComment ||\n        extraTokens[i] instanceof SingleLineComment\n      ) {\n        beginningNewlinesLimit = 2;\n        docComments.unshift(\n          extraTokens[i] as MultiLineComment | SingleLineComment\n        );\n      }\n      if (beginningNewlinesLimit <= 0) {\n        break;\n      }\n    }\n    // we assemble the comments into one string, and remove the preceding stars\n    const lines = docComments\n      .map((c) => c.contents)\n      .flatMap((c) => c.split(\"\\n\"))\n      .map((l) => l.trim().replace(/^\\*/, \"\").trim());\n    let contents = \"\";\n    let annotations: Object[] = [];\n    // we loop over every line of the preceeding comment to find the documentation contents and the annotations\n    // for each line we check if it stats with a @ (annotation)\n    for (const line of lines) {\n      if (line.startsWith(\"@\")) {\n        // this is an annotation\n        const segments = line.substring(1).split(\" \");\n        let foundAnnotation = false;\n        for (const possible of this.possibleAnnotations) {\n          if (possible.annotationTag === segments[0]) {\n            annotations.push(new possible(segments.slice(1)));\n            foundAnnotation = true;\n            break;\n          }\n        }\n        if (foundAnnotation) {\n          continue;\n        }\n      }\n\n      contents += line + \"\\n\";\n    }\n    contents = contents.trim();\n    return new DocComment(contents, annotations);\n  }\n}\n", "import CodeError from \"./CodeError\";\n\n/**\n * @category Error\n */\nexport default class ParsingError extends CodeError {}\n", "import TokenType from \"./TokenType\";\n\nexport default {\n  [TokenType.AND]: \"'&&' (AND)\",\n  [TokenType.Assert]: \"'assert' (Assert)\",\n  [TokenType.Bang]: \"'!' (Bang)\",\n  [TokenType.BangEqual]: \"'!=' (BangEqual)\",\n  [TokenType.Colon]: \"':' (Colon)\",\n  [TokenType.Comma]: \"',' (Comma)\",\n  [TokenType.Dot]: \"'.' (Dot)\",\n  [TokenType.Each]: \"'each' (Each)\",\n  [TokenType.Echo]: \"'echo' (Echo)\",\n  [TokenType.Else]: \"'else' (Else)\",\n  [TokenType.Eot]: \"end of file (Eot)\",\n  [TokenType.Equal]: \"'=' (Equal)\",\n  [TokenType.EqualEqual]: \"'==' (EqualEqual)\",\n  [TokenType.Error]: \"<error> (Error)\",\n  [TokenType.False]: \"'false' (False)\",\n  [TokenType.For]: \"'for' (For)\",\n  [TokenType.Function]: \"'function' (Function)\",\n  [TokenType.Greater]: \"'>' (Greater)\",\n  [TokenType.GreaterEqual]: \"'>=' (GreaterEqual)\",\n  [TokenType.Hash]: \"'#' (Hash)\",\n  [TokenType.Identifier]: \"identifier (Identifier)\",\n  [TokenType.If]: \"'if' (If)\",\n  [TokenType.LeftBrace]: \"'{' (LeftBrace)\",\n  [TokenType.LeftBracket]: \"'[' (LeftBracket)\",\n  [TokenType.LeftParen]: \"'(' (LeftParen)\",\n  [TokenType.Less]: \"'<' (Less)\",\n  [TokenType.LessEqual]: \"'<=' (LessEqual)\",\n  [TokenType.Let]: \"'let' (Let)\",\n  [TokenType.Minus]: \"'-' (Minus)\",\n  [TokenType.Module]: \"'module' (Module)\",\n  [TokenType.NumberLiteral]: \"number literal (NumberLiteral)\",\n  [TokenType.OR]: \"'||' (OR)\",\n  [TokenType.Percent]: \"'%' (Percent)\",\n  [TokenType.Plus]: \"'+' (Plus)\",\n  [TokenType.QuestionMark]: \"'?' (QuestionMark)\",\n  [TokenType.RightBrace]: \"'}' (RightBrace)\",\n  [TokenType.RightBracket]: \"']' (RightBracket)\",\n  [TokenType.RightParen]: \"')' (RightParen)\",\n  [TokenType.Semicolon]: \"';' (Semicolon)\",\n  [TokenType.Slash]: \"'/' (Slash)\",\n  [TokenType.Star]: \"'*' (Star)\",\n  [TokenType.Caret]: \"'^' (Caret)\",\n  [TokenType.StringLiteral]: \"string literal (StringLiteral)\",\n  [TokenType.True]: \"'true' (True)\",\n  [TokenType.Undef]: \"'undef' (Undef)\",\n  [TokenType.Use]: \"'use' (Use)\",\n  [TokenType.FilenameInChevrons]: \"filename (FilenameInChevrons)\",\n  [TokenType.Include]: \"'include' (Include)\",\n};\n", "import CodeLocation from \"../CodeLocation\";\nimport friendlyTokenNames from \"../friendlyTokenNames\";\nimport TokenType from \"../TokenType\";\nimport ParsingError from \"./ParsingError\";\n\n/**\n * @category Error\n */\nexport class UnterminatedUseStatementParsingError extends ParsingError {\n  constructor(pos: CodeLocation) {\n    super(pos, `Unterminated 'use' statement.`);\n  }\n}\n\n/**\n * @category Error\n */\nexport class UnexpectedTokenParsingError extends ParsingError {\n  constructor(pos: CodeLocation, tt: TokenType, extraMsg?: string) {\n    if (extraMsg) {\n      super(pos, `Unexpected token ${friendlyTokenNames[tt]}${extraMsg}`);\n    } else {\n      super(pos, `Unexpected token ${friendlyTokenNames[tt]}.`);\n    }\n  }\n}\n\n/**\n * @category Error\n */\nexport class UnexpectedTokenWhenStatementParsingError extends UnexpectedTokenParsingError {\n  constructor(pos: CodeLocation, tt: TokenType) {\n    super(pos, tt, `, expected statement.`);\n  }\n}\n\n/**\n * @category Error\n */\nexport class UnexpectedTokenAfterIdentifierInStatementParsingError extends UnexpectedTokenParsingError {\n  constructor(pos: CodeLocation, tt: TokenType) {\n    super(\n      pos,\n      tt,\n      `, expected ${friendlyTokenNames[TokenType.LeftParen]} or ${\n        friendlyTokenNames[TokenType.Equal]\n      } after identifier in statement.`\n    );\n  }\n}\n\n/**\n * @category Error\n */\nexport class UnexpectedEndOfFileBeforeModuleInstantiationParsingError extends ParsingError {\n  constructor(pos: CodeLocation) {\n    super(pos, `Unexpected end of file before module instantiation.`);\n  }\n}\n\n/**\n * @category Error\n */\nexport class UnterminatedParametersListParsingError extends ParsingError {\n  constructor(pos: CodeLocation) {\n    super(pos, `Unterminated parameters list.`);\n  }\n}\n\n/**\n * @category Error\n */\nexport class UnexpectedTokenInNamedArgumentsListParsingError extends UnexpectedTokenParsingError {\n  constructor(pos: CodeLocation, tt: TokenType) {\n    super(pos, tt, ` in named arguments list.`);\n  }\n}\n\n/**\n * @category Error\n */\nexport class UnterminatedForLoopParamsParsingError extends ParsingError {\n  constructor(pos: CodeLocation) {\n    super(pos, `Unterminated for loop params.`);\n  }\n}\n\n/**\n * @category Error\n */\nexport class UnexpectedTokenInForLoopParamsListParsingError extends UnexpectedTokenParsingError {\n  constructor(pos: CodeLocation, tt: TokenType) {\n    super(pos, tt, ` in for loop params list.`);\n  }\n}\n\n/**\n * @category Error\n */\nexport class FailedToMatchPrimaryExpressionParsingError extends ParsingError {\n  constructor(pos: CodeLocation) {\n    super(pos, `Failed to match primary expression.`);\n  }\n}\n\n/**\n * @category Error\n */\nexport class UnterminatedVectorExpressionParsingError extends ParsingError {\n  constructor(pos: CodeLocation) {\n    super(pos, `Unterminated vector literal.`);\n  }\n}\n\n/**\n * @category Error\n */\nexport class ConsumptionParsingError extends UnexpectedTokenParsingError {\n  constructor(\n    pos: CodeLocation,\n    public real: TokenType,\n    public expected: TokenType,\n    where: string\n  ) {\n    super(pos, real, `, expected ${friendlyTokenNames[expected]} ${where}.`);\n  }\n}\n\n/**\n * @category Error\n */\nexport class UnexpectedCommentBeforeUseChevronParsingError extends ParsingError {\n  constructor(pos: CodeLocation) {\n    super(pos, `Comments are illegal before '<' in the use statement.`);\n  }\n}\n\n/**\n * @category Error\n */\nexport class UnexpectedUseStatementParsingError extends ParsingError {\n  constructor(pos: CodeLocation) {\n    super(\n      pos,\n      `Use ('use <...>') statements are only allowed at the root scope of the file, not inside of blocks.`\n    );\n  }\n}\n\n/**\n * @category Error\n */\nexport class UnexpectedIncludeStatementParsingError extends ParsingError {\n  constructor(pos: CodeLocation) {\n    super(\n      pos,\n      `Include ('include <...>') statements are only allowed at the root scope of the file, not inside of blocks.`\n    );\n  }\n}\n", "import AssignmentNode, { AssignmentNodeRole } from \"./ast/AssignmentNode\";\nimport ErrorNode from \"./ast/ErrorNode\";\nimport {\n  AnonymousFunctionExpr,\n  ArrayLookupExpr,\n  AssertExpr,\n  BinaryOpExpr,\n  EchoExpr,\n  Expression,\n  FunctionCallExpr,\n  GroupingExpr,\n  LcEachExpr,\n  LcForCExpr,\n  LcForExpr,\n  LcIfExpr,\n  LcLetExpr,\n  LetExpr,\n  ListComprehensionExpression,\n  LiteralExpr,\n  LookupExpr,\n  MemberLookupExpr,\n  RangeExpr,\n  TernaryExpr,\n  UnaryOpExpr,\n  VectorExpr,\n} from \"./ast/expressions\";\nimport ScadFile from \"./ast/ScadFile\";\nimport {\n  BlockStmt,\n  FunctionDeclarationStmt,\n  IfElseStatement,\n  IncludeStmt,\n  ModuleDeclarationStmt,\n  ModuleInstantiationStmt,\n  NoopStmt,\n  Statement,\n  UseStmt,\n} from \"./ast/statements\";\nimport CodeFile from \"./CodeFile\";\nimport CodeLocation from \"./CodeLocation\";\nimport { IntrinsicRenameAnnotation } from \"./comments/annotations\";\nimport DocComment from \"./comments/DocComment\";\nimport ErrorCollector from \"./ErrorCollector\";\nimport ParsingError from \"./errors/ParsingError\";\nimport {\n  ConsumptionParsingError,\n  FailedToMatchPrimaryExpressionParsingError,\n  UnexpectedEndOfFileBeforeModuleInstantiationParsingError,\n  UnexpectedIncludeStatementParsingError,\n  UnexpectedTokenAfterIdentifierInStatementParsingError,\n  UnexpectedTokenInForLoopParamsListParsingError,\n  UnexpectedTokenInNamedArgumentsListParsingError,\n  UnexpectedTokenWhenStatementParsingError,\n  UnexpectedUseStatementParsingError,\n  UnterminatedForLoopParamsParsingError,\n  UnterminatedParametersListParsingError,\n  UnterminatedVectorExpressionParsingError,\n} from \"./errors/parsingErrors\";\nimport keywords from \"./keywords\";\nimport LiteralToken from \"./LiteralToken\";\nimport Token from \"./Token\";\nimport TokenType from \"./TokenType\";\n\nconst moduleInstantiationTagTokens = [\n  TokenType.Bang,\n  TokenType.Hash,\n  TokenType.Percent,\n  TokenType.Star,\n];\n\nconst keywordModuleNames = [\n  TokenType.For,\n  TokenType.Let,\n  TokenType.Assert,\n  TokenType.Echo,\n  TokenType.Each,\n  TokenType.If,\n];\n\nconst listComprehensionElementKeywords = [\n  TokenType.For,\n  TokenType.Let,\n  TokenType.Each,\n  TokenType.If,\n];\n\nexport default class Parser {\n  protected currentToken = 0;\n\n  /**\n   * The code file being parsed.\n   */\n  public code: CodeFile;\n\n  /**\n   * The tokens being parsed. They have to be provided from the lexer\n   * @see [[Lexer.scan]]\n   */\n  public tokens: Token[];\n\n  /**\n   * The ErrorCollector for this parser. All the errors encountered by the parser will be put there, since it does not throw on non-fatal errors.\n   */\n  public errorCollector: ErrorCollector;\n\n  constructor(code: CodeFile, tokens: Token[], errorCollector: ErrorCollector) {\n    this.code = code;\n    this.tokens = tokens;\n    this.errorCollector = errorCollector;\n  }\n\n  /**\n   * Attempts to parse a file and return the AST with the ScadFile as a root node.\n   * @throws ParsingError\n   */\n  parse(): ScadFile {\n    const statements: Statement[] = [];\n    while (!this.isAtEnd()) {\n      statements.push(this.statement(true));\n    }\n    const eot = this.peek();\n    return new ScadFile(statements, { eot });\n  }\n\n  protected synchronize(e: ParsingError) {\n    if (e instanceof ConsumptionParsingError) {\n      if (e.expected === TokenType.Semicolon) {\n        if (this.peek().hasNewlineInExtraTokens()) {\n          return;\n        }\n      }\n    }\n    if (e instanceof FailedToMatchPrimaryExpressionParsingError) {\n      if (this.peek().hasNewlineInExtraTokens()) {\n        // assume that when there is a newline we want to parse the next statement\n        return;\n      }\n    }\n    if (e instanceof UnexpectedTokenAfterIdentifierInStatementParsingError) {\n      if (this.peek().hasNewlineInExtraTokens()) {\n        return;\n      }\n    }\n    this.advance();\n    while (!this.isAtEnd()) {\n      if (this.previous().type === TokenType.Semicolon) return;\n      switch (this.peek().type) {\n        case TokenType.Module:\n        case TokenType.Function:\n        case TokenType.If:\n        case TokenType.For:\n        case TokenType.Echo:\n        case TokenType.Assert:\n        case TokenType.Let:\n          return;\n      }\n      this.advance();\n    }\n  }\n\n  /**\n   * Parses a statement, including `use` and `include` when isAtRoot is set to true.\n   * @param isAtRoot whther we are parsing a statement in the root of the file, set to false inside blocks or modules.\n   */\n  protected statement(isAtRoot = false) {\n    const syncStartToken = this.currentToken;\n    const syncStartLocation = this.getLocation();\n    try {\n      if (this.matchToken(TokenType.Use)) {\n        if (!isAtRoot) {\n          throw this.errorCollector.reportError(\n            new UnexpectedUseStatementParsingError(this.getLocation())\n          );\n        }\n        const useKeyword = this.previous();\n        const filenameToken: LiteralToken<string> = this.consume(\n          TokenType.FilenameInChevrons,\n          \"after 'use' keyword\"\n        ) as LiteralToken<string>;\n\n        return new UseStmt(filenameToken.value, {\n          useKeyword,\n          filename: filenameToken,\n        });\n      }\n      if (this.matchToken(TokenType.Include)) {\n        if (!isAtRoot) {\n          throw this.errorCollector.reportError(\n            new UnexpectedIncludeStatementParsingError(this.getLocation())\n          );\n        }\n        const includeKeyword = this.previous();\n        const filenameToken: LiteralToken<string> = this.consume(\n          TokenType.FilenameInChevrons,\n          \"after 'include' keyword\"\n        ) as LiteralToken<string>;\n\n        return new IncludeStmt(filenameToken.value, {\n          includeKeyword,\n          filename: filenameToken,\n        });\n      }\n      if (this.matchToken(TokenType.Semicolon)) {\n        const semicolon = this.previous();\n        return new NoopStmt({ semicolon });\n      }\n      if (this.matchToken(TokenType.LeftBrace)) {\n        return this.blockStatement();\n      }\n      if (this.matchToken(TokenType.Module)) {\n        return this.moduleDeclarationStatement();\n      }\n      if (this.matchToken(TokenType.Function)) {\n        return this.functionDeclarationStatement();\n      }\n      const assignmentOrInst = this.matchAssignmentOrModuleInstantation();\n      if (assignmentOrInst) {\n        return assignmentOrInst;\n      }\n      throw this.errorCollector.reportError(\n        new UnexpectedTokenWhenStatementParsingError(\n          this.getLocation(),\n          this.peek().type\n        )\n      );\n    } catch (e) {\n      if (e instanceof ParsingError) {\n        this.synchronize(e);\n        return new ErrorNode({\n          tokens: this.tokens.slice(syncStartToken, this.currentToken),\n        });\n      } else {\n        throw e;\n      }\n    }\n  }\n  protected matchAssignmentOrModuleInstantation() {\n    // identifiers can mean either an instantiation is incoming or an assignment\n    if (this.matchToken(TokenType.Identifier)) {\n      if (this.peek().type === TokenType.Equal) {\n        return this.assignmentStatement();\n      }\n      if (this.peek().type === TokenType.LeftParen) {\n        return this.moduleInstantiationStatement();\n      }\n      throw this.errorCollector.reportError(\n        new UnexpectedTokenAfterIdentifierInStatementParsingError(\n          this.getLocation(),\n          this.peek().type\n        )\n      );\n    }\n    if (\n      this.matchToken(...moduleInstantiationTagTokens, ...keywordModuleNames)\n    ) {\n      return this.moduleInstantiationStatement();\n    }\n    return null;\n  }\n  protected blockStatement() {\n    const firstBrace = this.previous();\n    const startLocation = this.getLocation();\n    const innerStatements: Statement[] = [];\n    while (!this.checkToken(TokenType.RightBrace) && !this.isAtEnd()) {\n      innerStatements.push(this.statement());\n    }\n    this.consume(TokenType.RightBrace, \"after block statement\");\n    const secondBrace = this.previous();\n    return new BlockStmt(innerStatements, {\n      firstBrace,\n      secondBrace,\n    });\n  }\n  protected moduleDeclarationStatement(): ModuleDeclarationStmt {\n    const moduleKeyword = this.previous();\n    const nameToken = this.consume(\n      TokenType.Identifier,\n      \"after 'module' keyword\"\n    );\n    this.consume(TokenType.LeftParen, \"after module name\");\n    const firstParen = this.previous();\n    const args: AssignmentNode[] = this.args();\n    const secondParen = this.previous();\n    const body = this.statement();\n    const doc = DocComment.fromExtraTokens(moduleKeyword.extraTokens);\n    let name = (nameToken as LiteralToken<string>).value;\n\n    // handle renaming of the symbol via annotations in documentation comments\n    // used by the prelude\n    const renameAnnotation = doc.annotations.find(\n      (a) => a instanceof IntrinsicRenameAnnotation\n    ) as IntrinsicRenameAnnotation;\n    if (renameAnnotation) {\n      name = renameAnnotation.newName;\n    }\n    return new ModuleDeclarationStmt(\n      name,\n      args,\n      body,\n      {\n        moduleKeyword,\n        name: nameToken,\n        firstParen,\n        secondParen,\n      },\n      doc\n    );\n  }\n  protected functionDeclarationStatement(): FunctionDeclarationStmt {\n    const functionKeyword = this.previous();\n    const nameToken = this.consume(\n      TokenType.Identifier,\n      \"after 'function' keyword\"\n    );\n    this.consume(TokenType.LeftParen, \"after function name\");\n    const firstParen = this.previous();\n    const args = this.args();\n    const secondParen = this.previous();\n    this.consume(TokenType.Equal, \"after function parameters\");\n    const equals = this.previous();\n    const body = this.expression();\n    this.consume(TokenType.Semicolon, \"after function declaration\");\n    const semicolon = this.previous();\n    return new FunctionDeclarationStmt(\n      (nameToken as LiteralToken<string>).value,\n      args,\n      body,\n      {\n        functionKeyword,\n        equals,\n        firstParen,\n        name: nameToken,\n        secondParen,\n        semicolon,\n      },\n      DocComment.fromExtraTokens(functionKeyword.extraTokens)\n    );\n  }\n\n  protected assignmentStatement() {\n    const pos = this.getLocation();\n    const name = this.previous() as LiteralToken<string>;\n    this.consume(TokenType.Equal, \"after assignment name\");\n    const equals = this.previous();\n    const expr = this.expression();\n    this.consume(TokenType.Semicolon, \"after assignment statement\");\n    const semicolon = this.previous();\n    const node = new AssignmentNode(\n      name.value,\n      expr,\n      AssignmentNodeRole.VARIABLE_DECLARATION,\n      {\n        name,\n        equals,\n        trailingCommas: null,\n        semicolon,\n      }\n    );\n    node.docComment = DocComment.fromExtraTokens(name.extraTokens);\n    return node;\n  }\n  protected moduleInstantiationStatement():\n    | ModuleInstantiationStmt\n    | IfElseStatement {\n    if (this.isAtEnd()) {\n      throw this.errorCollector.reportError(\n        new UnexpectedEndOfFileBeforeModuleInstantiationParsingError(\n          this.getLocation()\n        )\n      );\n    }\n    if (this.previous().type === TokenType.Bang) {\n      const tagToken = this.previous();\n      this.advance();\n      const mod = this.moduleInstantiationStatement();\n      mod.tagRoot = true;\n      mod.tokens.modifiersInOrder.push(tagToken);\n      return mod;\n    }\n    if (this.previous().type === TokenType.Hash) {\n      const tagToken = this.previous();\n      this.advance();\n      const mod = this.moduleInstantiationStatement();\n      mod.tagHighlight = true;\n      mod.tokens.modifiersInOrder.push(tagToken);\n      return mod;\n    }\n    if (this.previous().type === TokenType.Percent) {\n      const tagToken = this.previous();\n      this.advance();\n      const mod = this.moduleInstantiationStatement();\n      mod.tagBackground = true;\n      mod.tokens.modifiersInOrder.push(tagToken);\n      return mod;\n    }\n    if (this.previous().type === TokenType.Star) {\n      const tagToken = this.previous();\n      this.advance();\n      const mod = this.moduleInstantiationStatement();\n      mod.tagDisabled = true;\n      mod.tokens.modifiersInOrder.push(tagToken);\n      return mod;\n    }\n    const mod = this.singleModuleInstantiation();\n    if (!(mod instanceof IfElseStatement)) {\n      mod.child = this.statement();\n    }\n    return mod;\n  }\n  protected ifElseStatement(): IfElseStatement {\n    const ifKeyword = this.previous();\n    this.consume(TokenType.LeftParen, \"after the if keyword\");\n    const firstParen = this.previous();\n    const cond = this.expression();\n    this.consume(TokenType.RightParen, \"after the if condition\");\n    const secondParen = this.previous();\n    const thenBranch = this.statement();\n    let elseBranch: Statement | null = null;\n    let elseKeyword = null;\n    if (this.matchToken(TokenType.Else)) {\n      elseKeyword = this.previous();\n      elseBranch = this.statement();\n    }\n    return new IfElseStatement(cond, thenBranch, elseBranch, {\n      ifKeyword,\n      elseKeyword,\n      firstParen,\n      secondParen,\n      modifiersInOrder: [],\n    });\n  }\n  protected singleModuleInstantiation() {\n    const prev = this.previous();\n    if (prev.type === TokenType.If) {\n      return this.ifElseStatement();\n    }\n    this.consume(TokenType.LeftParen, \"after module instantation\");\n    const firstParen = this.previous();\n    let name!: string;\n    if (prev instanceof LiteralToken) {\n      name = prev.value as string;\n    } else {\n      for (const keywordName of Object.keys(keywords)) {\n        if (keywords[keywordName] === prev.type) {\n          name = keywordName;\n          break;\n        }\n      }\n    }\n    let isForLoop = name === \"for\" || name === \"intersection_for\";\n    const args = this.args(true, isForLoop ? AssignmentNodeRole.VARIABLE_DECLARATION : null);\n    const secondParen = this.previous();\n    return new ModuleInstantiationStmt(name, args, null, {\n      firstParen,\n      name: prev,\n      secondParen,\n      modifiersInOrder: [],\n    });\n  }\n  /**\n   * Parses an argument list including the finishing paren. Can handle trailing and extra commas as well as an empty arguments list.\n   * The initial paren must be consumed.\n   * @param allowPositional Set to true when in call mode, positional arguments will be allowed.\n   */\n  protected args(\n    allowPositional = false,\n    forceType: AssignmentNodeRole | null = null\n  ): AssignmentNode[] {\n    this.consumeUselessCommas();\n    const args: AssignmentNode[] = [];\n    if (this.matchToken(TokenType.RightParen)) {\n      return args;\n    }\n    while (true) {\n      if (this.isAtEnd()) {\n        break;\n      }\n      if (!allowPositional && this.peek().type !== TokenType.Identifier) {\n        // error out when we encounter a positional argument when it is not allowed\n        break;\n      }\n      let value: Expression | null = null;\n      let name: string;\n      let nameToken: Token | null = null;\n      let equals: Token | null = null;\n      if (!allowPositional || this.peekNext().type === TokenType.Equal) {\n        // this is a named parameter\n        name = (this.advance() as LiteralToken<string>).value;\n        nameToken = this.previous();\n        // a value is provided for this param\n        if (this.matchToken(TokenType.Equal)) {\n          equals = this.previous();\n          value = this.expression();\n        }\n      } else {\n        name = \"\";\n        value = this.expression();\n        // this is a positional paramater\n      }\n\n      const arg = new AssignmentNode(\n        name,\n        value,\n        forceType == null\n          ? allowPositional\n            ? AssignmentNodeRole.ARGUMENT_ASSIGNMENT\n            : AssignmentNodeRole.ARGUMENT_DECLARATION\n          : forceType,\n        {\n          name: nameToken,\n          equals,\n          semicolon: null,\n          trailingCommas: [],\n        }\n      );\n      args.push(arg);\n\n      if (this.matchToken(TokenType.Comma)) {\n        arg.tokens.trailingCommas!.push(this.previous());\n        this.consumeUselessCommas(arg.tokens.trailingCommas!);\n        if (this.matchToken(TokenType.RightParen)) {\n          return args;\n        }\n        continue;\n      }\n      this.consumeUselessCommas(arg.tokens.trailingCommas!);\n      // end of named arguments\n      if (this.matchToken(TokenType.RightParen)) {\n        return args;\n      }\n    }\n    if (this.isAtEnd()) {\n      throw this.errorCollector.reportError(\n        new UnterminatedParametersListParsingError(this.getLocation())\n      );\n    }\n    throw this.errorCollector.reportError(\n      new UnexpectedTokenInNamedArgumentsListParsingError(\n        this.getLocation(),\n        this.advance().type\n      )\n    );\n  }\n  /**\n   * Parses arguments from the 'for' loop comprehension.\n   * The initial paren must be consumed. Stops on semicolon or right paren, but does not consume them.\n   */\n  protected forComprehensionArgs(): AssignmentNode[] {\n    this.consumeUselessCommas();\n    const args: AssignmentNode[] = [];\n    if (\n      this.checkToken(TokenType.RightParen) ||\n      this.checkToken(TokenType.Semicolon)\n    ) {\n      return args;\n    }\n    while (true) {\n      if (this.isAtEnd()) {\n        break;\n      }\n\n      let arg;\n\n      if (\n        this.peek().type === TokenType.Identifier &&\n        this.peekNext().type === TokenType.Equal\n      ) {\n        // Named for loop variable\n        const name = (this.advance() as LiteralToken<string>).value;\n        const nameToken = this.previous();\n        // a value is provided for this param\n        this.consume(\n          TokenType.Equal,\n          \"after variable name in the 'for' list comprehension\"\n        );\n        const equals = this.previous();\n        const value = this.expression();\n\n        arg = new AssignmentNode(\n          name,\n          value,\n          AssignmentNodeRole.VARIABLE_DECLARATION,\n          {\n            equals,\n            semicolon: null,\n            name: nameToken,\n            trailingCommas: [],\n          }\n        );\n        args.push(arg);\n      } else {\n        // This condition handles this a pathological case where the for list comprehension can\n        // have a single expression without any variable declaration.\n        // This can be used to repeat the same element a number of times.\n        // See: https://github.com/alufers/openscad-parser/issues/27\n        const value = this.expression();\n        arg = new AssignmentNode(\n          \"\",\n          value,\n          AssignmentNodeRole.ARGUMENT_ASSIGNMENT,\n          {\n            equals: null,\n            semicolon: null,\n            name: null,\n            trailingCommas: [],\n          }\n        );\n        args.push(arg);\n      }\n\n      if (this.matchToken(TokenType.Comma)) {\n        arg.tokens.trailingCommas!.push(this.previous());\n        this.consumeUselessCommas(arg.tokens.trailingCommas!);\n        if (\n          this.checkToken(TokenType.RightParen) ||\n          this.checkToken(TokenType.Semicolon)\n        ) {\n          return args;\n        }\n        continue;\n      }\n      this.consumeUselessCommas(arg.tokens.trailingCommas!);\n      if (\n        this.checkToken(TokenType.RightParen) ||\n        this.checkToken(TokenType.Semicolon)\n      ) {\n        return args;\n      }\n    }\n    if (this.isAtEnd()) {\n      throw this.errorCollector.reportError(\n        new UnterminatedForLoopParamsParsingError(this.getLocation())\n      );\n    }\n    throw this.errorCollector.reportError(\n      new UnexpectedTokenInForLoopParamsListParsingError(\n        this.getLocation(),\n        this.advance().type\n      )\n    );\n  }\n  /**\n   * Consumes redundant commas and returns true if it consumed any.\n   *\n   * You can also pass an array of tokens to which all the comma tokens will be pushed.\n   */\n  protected consumeUselessCommas(trailingArr?: Token[]) {\n    let ret = false;\n    while (this.matchToken(TokenType.Comma) && !this.isAtEnd()) {\n      if (trailingArr) {\n        trailingArr.push(this.previous());\n      }\n      ret = true;\n    }\n    return ret;\n  }\n  protected expression(): Expression {\n    return this.ternary();\n  }\n  /**\n   * Parses the ternary '? :' expression\n   */\n  protected ternary() {\n    let expr = this.logicalOr();\n    while (this.matchToken(TokenType.QuestionMark)) {\n      const questionMark = this.previous();\n      const thenBranch = this.ternary();\n      this.consume(TokenType.Colon, \"between ternary expression branches\");\n      const colon = this.previous();\n      const elseBranch = this.ternary();\n      expr = new TernaryExpr(expr, thenBranch, elseBranch, {\n        questionMark,\n        colon,\n      });\n    }\n    return expr;\n  }\n  /**\n   * Parses the '||' operators\n   */\n  protected logicalOr() {\n    let expr = this.logicalAnd();\n    while (this.matchToken(TokenType.OR)) {\n      const operator = this.previous();\n      const right = this.logicalAnd();\n      expr = new BinaryOpExpr(expr, operator.type, right, {\n        operator,\n      });\n    }\n    return expr;\n  }\n  /**\n   * Parses the '&&' operators\n   */\n  protected logicalAnd() {\n    let expr = this.equality();\n    while (this.matchToken(TokenType.AND)) {\n      const operator = this.previous();\n      const right = this.equality();\n      expr = new BinaryOpExpr(expr, operator.type, right, {\n        operator,\n      });\n    }\n    return expr;\n  }\n  /**\n   * Parses the '==' and '!=' operators.\n   */\n  protected equality(): Expression {\n    let expr = this.comparsion();\n    while (this.matchToken(TokenType.EqualEqual, TokenType.BangEqual)) {\n      const operator = this.previous();\n      const right = this.comparsion();\n      expr = new BinaryOpExpr(expr, operator.type, right, {\n        operator,\n      });\n    }\n    return expr;\n  }\n  protected comparsion(): Expression {\n    let expr = this.addition();\n    while (\n      this.matchToken(\n        TokenType.Less,\n        TokenType.LessEqual,\n        TokenType.Greater,\n        TokenType.GreaterEqual\n      )\n    ) {\n      const operator = this.previous();\n      const right = this.addition();\n      expr = new BinaryOpExpr(expr, operator.type, right, {\n        operator,\n      });\n    }\n    return expr;\n  }\n  protected addition(): Expression {\n    let expr = this.multiplication();\n    while (this.matchToken(TokenType.Plus, TokenType.Minus)) {\n      const operator = this.previous();\n      const right = this.multiplication();\n      expr = new BinaryOpExpr(expr, operator.type, right, {\n        operator,\n      });\n    }\n    return expr;\n  }\n  protected multiplication(): Expression {\n    let expr = this.exponentiation();\n    while (\n      this.matchToken(TokenType.Star, TokenType.Slash, TokenType.Percent)\n    ) {\n      const operator = this.previous();\n      const right = this.exponentiation();\n      expr = new BinaryOpExpr(expr, operator.type, right, {\n        operator,\n      });\n    }\n    return expr;\n  }\n\n  /**\n   * Parses b ^ e.\n   */\n  protected exponentiation(): Expression {\n    let expr = this.unary();\n    while (this.matchToken(TokenType.Caret)) {\n      const operator = this.previous();\n      const right = this.unary();\n      expr = new BinaryOpExpr(expr, operator.type, right, {\n        operator,\n      });\n    }\n    return expr;\n  }\n\n  /**\n   * Parses +expr, -expr and !expr.\n   */\n  protected unary(): Expression {\n    if (this.matchToken(TokenType.Plus, TokenType.Minus, TokenType.Bang)) {\n      const operator = this.previous();\n      const right = this.unary();\n      return new UnaryOpExpr(operator.type, right, {\n        operator,\n      });\n    }\n    return this.memberLookupOrArrayLookup();\n  }\n  protected memberLookupOrArrayLookup() {\n    let expr = this.primary();\n    while (true) {\n      if (this.matchToken(TokenType.Dot)) {\n        const dot = this.previous();\n        const name = this.consume(\n          TokenType.Identifier,\n          \"after '.'\"\n        ) as LiteralToken<string>;\n        expr = new MemberLookupExpr(expr, name.value, {\n          dot,\n          memberName: name,\n        });\n      } else if (this.matchToken(TokenType.LeftBracket)) {\n        const firstBracket = this.previous();\n        const index = this.expression();\n        this.consume(TokenType.RightBracket, \"after array index expression\");\n        const secondBracket = this.previous();\n        expr = new ArrayLookupExpr(expr, index, {\n          firstBracket,\n          secondBracket,\n        });\n      } else if (this.matchToken(TokenType.LeftParen)) {\n        expr = this.finishCall(expr);\n      } else {\n        break;\n      }\n    }\n    return expr;\n  }\n  protected finishCall(callee: Expression): Expression {\n    const firstParen = this.previous();\n    const args = this.args(true);\n    const secondParen = this.previous();\n    return new FunctionCallExpr(callee, args, {\n      firstParen,\n      secondParen,\n    });\n  }\n  protected primary(): Expression {\n    if (this.matchToken(TokenType.True)) {\n      return new LiteralExpr(true, {\n        literalToken: this.previous() as LiteralToken<any>,\n      });\n    }\n    if (this.matchToken(TokenType.False)) {\n      return new LiteralExpr(false, {\n        literalToken: this.previous() as LiteralToken<any>,\n      });\n    }\n    if (this.matchToken(TokenType.Undef)) {\n      return new LiteralExpr<null>(null, {\n        literalToken: this.previous() as LiteralToken<any>,\n      });\n    }\n    if (this.matchToken(TokenType.NumberLiteral)) {\n      return new LiteralExpr((this.previous() as LiteralToken<number>).value, {\n        literalToken: this.previous() as LiteralToken<any>,\n      });\n    }\n    if (this.matchToken(TokenType.StringLiteral)) {\n      return new LiteralExpr((this.previous() as LiteralToken<string>).value, {\n        literalToken: this.previous() as LiteralToken<any>,\n      });\n    }\n    if (this.matchToken(TokenType.Identifier)) {\n      const tok = this.previous() as LiteralToken<string>;\n      return new LookupExpr(tok.value, {\n        identifier: tok,\n      });\n    }\n    if (this.matchToken(TokenType.Assert)) {\n      const keyword = this.previous();\n      this.consume(TokenType.LeftParen, \"after call expression\");\n      const firstParen = this.previous();\n      const vars = this.args(true);\n      const secondParen = this.previous();\n      const innerExpr = this.expression();\n      return new AssertExpr(vars, innerExpr, {\n        firstParen,\n        secondParen,\n        name: keyword,\n      });\n    }\n    if (this.matchToken(TokenType.Let)) {\n      const keyword = this.previous();\n      this.consume(TokenType.LeftParen, `after call expression`);\n      const firstParen = this.previous();\n      const vars = this.args(true);\n      const secondParen = this.previous();\n      const innerExpr = this.expression();\n      return new LetExpr(vars, innerExpr, {\n        firstParen,\n        secondParen,\n        name: keyword,\n      });\n    }\n    if (this.matchToken(TokenType.Echo)) {\n      const keyword = this.previous();\n      this.consume(TokenType.LeftParen, `after call expression`);\n      const firstParen = this.previous();\n      const vars = this.args(true);\n      const secondParen = this.previous();\n      const innerExpr = this.expression();\n      return new EchoExpr(vars, innerExpr, {\n        firstParen,\n        secondParen,\n        name: keyword,\n      });\n    }\n    if (this.matchToken(TokenType.Function)) {\n      return this.anonymousFunction();\n    }\n    if (this.matchToken(TokenType.LeftParen)) {\n      const firstParen = this.previous();\n      const expr = this.expression();\n      this.consume(TokenType.RightParen, \"after grouping expression\");\n      const secondParen = this.previous();\n      return new GroupingExpr(expr, {\n        firstParen,\n        secondParen,\n      });\n    }\n    if (this.matchToken(TokenType.LeftBracket)) {\n      return this.bracketInsides();\n    }\n    throw this.errorCollector.reportError(\n      new FailedToMatchPrimaryExpressionParsingError(this.previous().span.start)\n    );\n  }\n  /**\n   * Handles the parsing of vector literals and range literals.\n   */\n  protected bracketInsides(): Expression {\n    const startBracket = this.previous();\n    // the openscad bison parser has a weird thing where it allows optional commas only if the brackets represent an empty vector\n    // Good: [,,,,,,]\n    // Bad: [,,,,10]\n    // Bad [,,,,,10: 20 : 20]\n    const uselessCommaTokens: Token[] = [];\n    if (this.consumeUselessCommas(uselessCommaTokens)) {\n      this.consume(\n        TokenType.RightBracket,\n        \"after leading commas in a vector literal\"\n      );\n      const secondBracket = this.previous();\n      return new VectorExpr([], {\n        firstBracket: startBracket,\n        secondBracket,\n        commas: uselessCommaTokens,\n      });\n    }\n\n    if (this.matchToken(TokenType.RightBracket)) {\n      const secondBracket = this.previous();\n      return new VectorExpr([], {\n        firstBracket: startBracket,\n        commas: [],\n        secondBracket,\n      });\n    }\n\n    const first = this.listComprehensionElementsOrExpr();\n    // check if we are parsing a range\n    if (\n      !(first instanceof ListComprehensionExpression) &&\n      this.matchToken(TokenType.Colon)\n    ) {\n      const firstColon = this.previous();\n      let secondRangeExpr = this.expression();\n      let thirdRangeExpr = null;\n      let secondColon = null;\n      if (this.matchToken(TokenType.Colon)) {\n        secondColon = this.previous();\n        thirdRangeExpr = this.expression();\n      }\n      this.consume(\n        TokenType.RightBracket,\n        \"after expression in a range literal\"\n      );\n      const secondBracket = this.previous();\n      if (thirdRangeExpr) {\n        return new RangeExpr(first, secondRangeExpr, thirdRangeExpr, {\n          firstBracket: startBracket,\n          firstColon,\n          secondColon,\n          secondBracket,\n        });\n      } else {\n        return new RangeExpr(first, null, secondRangeExpr, {\n          firstBracket: startBracket,\n          firstColon,\n          secondColon,\n          secondBracket,\n        });\n      }\n    }\n\n    // we are parsing a vector expression\n    const vectorLiteral = new VectorExpr([first], {\n      commas: [],\n      firstBracket: startBracket,\n      secondBracket: null as unknown as any, // we will add the second bracket later in the parsing, so we allow to have a null here\n    });\n    if (this.matchToken(TokenType.Comma)) {\n      vectorLiteral.tokens.commas.push(this.previous()); // add the comma to the tokens list, because we matchedIt\n      this.consumeUselessCommas(vectorLiteral.tokens.commas);\n      if (this.matchToken(TokenType.RightBracket)) {\n        vectorLiteral.tokens.secondBracket = this.previous();\n        return vectorLiteral;\n      }\n      while (true) {\n        if (this.isAtEnd()) {\n          throw this.errorCollector.reportError(\n            new UnterminatedVectorExpressionParsingError(this.getLocation())\n          );\n        }\n\n        vectorLiteral.children.push(this.listComprehensionElementsOrExpr());\n        if (this.matchToken(TokenType.RightBracket)) {\n          vectorLiteral.tokens.secondBracket = this.previous();\n          break;\n        }\n        this.consume(TokenType.Comma, \"after vector literal element\");\n        vectorLiteral.tokens.commas.push(this.previous()); // we musn't forget about adding the comma to the array since it may contain comments\n        this.consumeUselessCommas(vectorLiteral.tokens.commas);\n        if (this.matchToken(TokenType.RightBracket)) {\n          vectorLiteral.tokens.secondBracket = this.previous();\n          break;\n        }\n      }\n    } else {\n      this.consume(\n        TokenType.RightBracket,\n        \"after the only vector expression element\"\n      );\n      vectorLiteral.tokens.secondBracket = this.previous();\n    }\n\n    return vectorLiteral;\n  }\n\n  protected anonymousFunction(): AnonymousFunctionExpr {\n    const functionKeyword = this.previous();\n    const firstParen = this.consume(\n      TokenType.LeftParen,\n      \"after function keyword in anonymous function\"\n    );\n    const args = this.args();\n    const secondParen = this.previous();\n    const body = this.expression();\n    return new AnonymousFunctionExpr(args, body, {\n      functionKeyword,\n      firstParen,\n      secondParen,\n    });\n  }\n\n  protected listComprehensionElements(): Expression {\n    if (this.matchToken(TokenType.Let)) {\n      const letKwrd = this.previous();\n      this.consume(TokenType.LeftParen, \"after the let keyword\");\n      const firstParen = this.previous();\n      const args = this.args();\n      const secondParen = this.previous();\n      const next = this.listComprehensionElementsOrExpr();\n      return new LcLetExpr(args, next, {\n        letKeyword: letKwrd,\n        firstParen,\n        secondParen,\n      });\n    }\n    if (this.matchToken(TokenType.Each)) {\n      const eachKwrd = this.previous();\n      const next = this.listComprehensionElementsOrExpr();\n      return new LcEachExpr(next, {\n        eachKeyword: eachKwrd,\n      });\n    }\n    if (this.matchToken(TokenType.For)) {\n      return this.listComprehensionFor();\n    }\n    if (this.matchToken(TokenType.If)) {\n      const ifKwrd = this.previous();\n      this.consume(TokenType.LeftParen, \"after the if keyword\");\n      const firstParen = this.previous();\n      const cond = this.expression();\n      this.consume(\n        TokenType.RightParen,\n        \"after the if comprehension condition\"\n      );\n      const secondParen = this.previous();\n      const thenBranch = this.listComprehensionElementsOrExpr();\n      let elseBranch: Expression | null = null;\n      let elseKeyword = null;\n      if (this.matchToken(TokenType.Else)) {\n        elseKeyword = this.previous();\n        elseBranch = this.listComprehensionElementsOrExpr();\n      }\n      return new LcIfExpr(cond, thenBranch, elseBranch, {\n        ifKeyword: ifKwrd,\n        elseKeyword,\n        firstParen,\n        secondParen,\n      });\n    }\n    // we should not get here\n    throw new Error(\n      \"Unexpected token in list comprehension elements! THIS SHOULD NOT HAPPEN\"\n    );\n  }\n  protected listComprehensionFor(): Expression {\n    const forKwrd = this.previous();\n    this.consume(\n      TokenType.LeftParen,\n      \"after for keyword in list comprehension\"\n    );\n    const firstParen = this.previous();\n    const firstArgs = this.forComprehensionArgs();\n    if (this.matchToken(TokenType.RightParen)) {\n      const secondParen = this.previous();\n      return new LcForExpr(firstArgs, this.listComprehensionElementsOrExpr(), {\n        forKeyword: forKwrd,\n        firstParen,\n        secondParen,\n      });\n    }\n    this.consume(\n      TokenType.Semicolon,\n      \"after first 'for' comprehension parameters\"\n    );\n    const firstSemicolon = this.previous();\n    const condition = this.expression();\n    this.consume(TokenType.Semicolon, \"after 'for' comprehension condition\");\n    const secondSemicolon = this.previous();\n    const secondArgs = this.forComprehensionArgs();\n    this.consume(\n      TokenType.RightParen,\n      \"after second 'for' comprehension parameters\"\n    );\n    const secondParen = this.previous();\n    const next = this.listComprehensionElementsOrExpr();\n    return new LcForCExpr(firstArgs, secondArgs, condition, next, {\n      firstParen,\n      forKeyword: forKwrd,\n      firstSemicolon,\n      secondParen,\n      secondSemicolon,\n    });\n  }\n  protected listComprehensionElementsOrExpr(): Expression {\n    // checks if we have a list comprehension element.\n    if (\n      listComprehensionElementKeywords.includes(this.peek().type) ||\n      (this.peek().type === TokenType.LeftParen &&\n        listComprehensionElementKeywords.includes(this.peekNext().type))\n    ) {\n      let withParens = false;\n\n      if (this.matchToken(TokenType.LeftParen)) {\n        withParens = true;\n      }\n      const comprElemsResult = this.listComprehensionElements();\n      if (withParens) {\n        this.consume(\n          TokenType.RightParen,\n          \"after parenthesized list comprehension expression\"\n        );\n      }\n      return comprElemsResult;\n    }\n\n    return this.expression();\n  }\n  protected consume(tt: TokenType, where: string) {\n    if (this.checkToken(tt)) {\n      return this.advance();\n    }\n    throw this.errorCollector.reportError(\n      new ConsumptionParsingError(\n        this.getLocation(),\n        this.peek().type,\n        tt,\n        where\n      )\n    );\n  }\n  protected matchToken(...toMatch: TokenType[]) {\n    for (const tt of toMatch) {\n      if (this.checkToken(tt)) {\n        this.advance();\n        return true;\n      }\n    }\n    return false;\n  }\n  protected checkToken(tt: TokenType) {\n    if (this.isAtEnd()) {\n      return false;\n    }\n    return this.peek().type == tt;\n  }\n  protected advance() {\n    if (!this.isAtEnd()) {\n      this.currentToken++;\n    }\n    return this.previous();\n  }\n  protected isAtEnd() {\n    return this.peek().type === TokenType.Eot;\n  }\n  protected peek(): Token {\n    return this.tokens[this.currentToken];\n  }\n  protected peekNext(): Token {\n    if (this.tokens[this.currentToken].type === TokenType.Eot) {\n      return this.tokens[this.currentToken];\n    }\n    return this.tokens[this.currentToken + 1];\n  }\n  protected getLocation() {\n    return this.peek().span.start;\n  }\n  protected previous(): Token {\n    return this.tokens[this.currentToken - 1];\n  }\n}\n", "import ScadFile from \"./ast/ScadFile\";\nimport CodeFile from \"./CodeFile\";\nimport ErrorCollector from \"./ErrorCollector\";\nimport Lexer from \"./Lexer\";\nimport Parser from \"./Parser\";\nimport Token from \"./Token\";\n\nexport default class ParsingHelper {\n  static parseFile(f: CodeFile): [ScadFile | null, ErrorCollector] {\n    const errorCollector = new ErrorCollector();\n    const lexer = new Lexer(f, errorCollector);\n    let tokens: Token[] | undefined;\n    try {\n      tokens = lexer.scan();\n    } catch (e) {}\n    if (errorCollector.hasErrors()) {\n      return [null, errorCollector];\n    }\n    if (!tokens) {\n     throw new Error(\"No tokens returned from lexer, and no errors were reported\");\n    }\n    const parser = new Parser(f, tokens, errorCollector);\n    let ast: ScadFile | null = null;\n    try {\n      ast = parser.parse();\n    } catch (e) {}\n    return [ast, errorCollector];\n  }\n}\n", "import AssignmentNode from \"../ast/AssignmentNode\";\nimport {\n  FunctionDeclarationStmt,\n  ModuleDeclarationStmt,\n} from \"../ast/statements\";\n\nexport type KeysOfType<T, TProp> = {\n  [P in keyof T]: T[P] extends TProp ? P : never;\n}[keyof T];\n\n/**\n * Represents a lexical scope, where variables, modules, and functions are resolved.\n * It links symbol names with their declarations.\n */\nexport default class Scope {\n  /**\n   * References to other, 'include'd or 'use'd file scopes, filled by the solution manager.\n   * We can use those scopes to resolve types from those files.\n   */\n  siblingScopes: Scope[] = [];\n  parent: Scope | null = null;\n  functions = new Map<string, FunctionDeclarationStmt>();\n  variables = new Map<string, AssignmentNode>();\n  modules = new Map<string, ModuleDeclarationStmt>();\n\n  copy(): Scope {\n    const s = new Scope();\n    s.siblingScopes = [...this.siblingScopes];\n    s.functions = this.functions;\n    s.variables = this.variables;\n    s.modules = this.modules;\n    return s;\n  }\n\n  lookupVariable(name: string) {\n    return this.lookup(\"variables\", name) as AssignmentNode;\n  }\n\n  lookupModule(name: string) {\n    return this.lookup(\"modules\", name) as ModuleDeclarationStmt;\n  }\n\n  lookupFunction(name: string) {\n    return this.lookup(\"functions\", name) as FunctionDeclarationStmt;\n  }\n\n  private lookup(\n    x: KeysOfType<Scope, Map<any, any>>,\n    name: string,\n    visited: WeakMap<Scope, boolean> = new WeakMap()\n  ): FunctionDeclarationStmt | AssignmentNode | ModuleDeclarationStmt | null {\n    if (visited.has(this)) {\n      return null;\n    }\n    visited.set(this, true);\n    if (this[x].has(name)) {\n      return this[x].get(name) || null;\n    }\n    if (this.parent) {\n      const val = this.parent.lookup(x, name, visited);\n      if (val) {\n        return val;\n      }\n    }\n    for (const ss of this.siblingScopes) {\n      const val = ss.lookup(x, name, visited);\n      if (val) {\n        return val;\n      }\n    }\n    return null;\n  }\n}\n", "import { notStrictEqual } from \"assert\";\nimport AssignmentNode, { AssignmentNodeRole } from \"../ast/AssignmentNode\";\nimport ASTNode from \"../ast/ASTNode\";\nimport ASTVisitor from \"../ast/ASTVisitor\";\nimport ErrorNode from \"../ast/ErrorNode\";\nimport {\n  AnonymousFunctionExpr,\n  ArrayLookupExpr,\n  AssertExpr,\n  BinaryOpExpr,\n  EchoExpr,\n  FunctionCallExpr,\n  GroupingExpr,\n  LcEachExpr,\n  LcForCExpr,\n  LcForExpr,\n  LcIfExpr,\n  LcLetExpr,\n  LetExpr,\n  LiteralExpr,\n  LookupExpr,\n  MemberLookupExpr,\n  RangeExpr,\n  TernaryExpr,\n  UnaryOpExpr,\n  VectorExpr,\n} from \"../ast/expressions\";\nimport ScadFile from \"../ast/ScadFile\";\nimport {\n  BlockStmt,\n  FunctionDeclarationStmt,\n  IfElseStatement,\n  IncludeStmt,\n  ModuleDeclarationStmt,\n  ModuleInstantiationStmt,\n  NoopStmt,\n  Statement,\n  UseStmt,\n} from \"../ast/statements\";\nimport {\n  AnonymousFunctionExprWithScope,\n  BlockStmtWithScope,\n  FunctionDeclarationStmtWithScope,\n  LcForCExprWithScope,\n  LcForExprWithScope,\n  LcLetExprWithScope,\n  LetExprWithScope,\n  ModuleDeclarationStmtWithScope,\n  ModuleInstantiationStmtWithScope,\n  ScadFileWithScope,\n} from \"./nodesWithScopes\";\nimport Scope from \"./Scope\";\n\nexport default class ASTScopePopulator implements ASTVisitor<ASTNode> {\n  nearestScope: Scope;\n  constructor(rootScope: Scope) {\n    this.nearestScope = rootScope;\n  }\n\n  protected copyWithNewNearestScope(newScope: Scope) {\n    return new ASTScopePopulator(newScope);\n  }\n  populate(n: ASTNode) {\n    return n.accept(this);\n  }\n  visitScadFile(n: ScadFile): ASTNode {\n    const sf = new ScadFileWithScope(\n      n.statements.map((stmt) => stmt.accept(this)),\n      n.tokens\n    );\n    sf.scope = this.nearestScope; // we assume the nearest scope is the root scope, since we are processing the scad file\n    return sf;\n  }\n  visitAssignmentNode(n: AssignmentNode): ASTNode {\n    const an = new AssignmentNode(\n      n.name,\n      n.value ? n.value.accept(this) : null,\n      n.role,\n      n.tokens\n    );\n    if (n.name && n.role != AssignmentNodeRole.ARGUMENT_ASSIGNMENT) {\n      this.nearestScope.variables.set(an.name, an);\n    }\n    return an;\n  }\n  visitUnaryOpExpr(n: UnaryOpExpr): ASTNode {\n    return new UnaryOpExpr(n.operation, n.right.accept(this), n.tokens);\n  }\n  visitBinaryOpExpr(n: BinaryOpExpr): ASTNode {\n    return new BinaryOpExpr(\n      n.left.accept(this),\n      n.operation,\n      n.right.accept(this),\n      n.tokens\n    );\n  }\n  visitTernaryExpr(n: TernaryExpr): ASTNode {\n    return new TernaryExpr(\n      n.cond.accept(this),\n      n.ifExpr.accept(this),\n      n.elseExpr.accept(this),\n      n.tokens\n    );\n  }\n  visitArrayLookupExpr(n: ArrayLookupExpr): ASTNode {\n    return new ArrayLookupExpr(\n      n.array.accept(this),\n      n.index.accept(this),\n      n.tokens\n    );\n  }\n  visitLiteralExpr(n: LiteralExpr<any>): ASTNode {\n    return new LiteralExpr<any>(n.value, n.tokens);\n  }\n  visitRangeExpr(n: RangeExpr): ASTNode {\n    return new RangeExpr(\n      n.begin.accept(this),\n      n.step ? n.step.accept(this) : null,\n      n.end.accept(this),\n      n.tokens\n    );\n  }\n  visitVectorExpr(n: VectorExpr): ASTNode {\n    return new VectorExpr(\n      n.children.map((c) => c.accept(this)),\n      n.tokens\n    );\n  }\n  visitLookupExpr(n: LookupExpr): ASTNode {\n    return new LookupExpr(n.name, n.tokens);\n  }\n  visitMemberLookupExpr(n: MemberLookupExpr): ASTNode {\n    return new MemberLookupExpr(n.expr.accept(this), n.member, n.tokens);\n  }\n  visitFunctionCallExpr(n: FunctionCallExpr): ASTNode {\n    return new FunctionCallExpr(\n      n.callee,\n      n.args.map((a) => a.accept(this)) as AssignmentNode[],\n      n.tokens\n    );\n  }\n  visitLetExpr(n: LetExpr): ASTNode {\n    const letExprWithScope = new LetExprWithScope(\n      null as unknown as any,\n      null as unknown as any,\n      n.tokens\n    );\n    letExprWithScope.scope = new Scope();\n    letExprWithScope.scope.parent = this.nearestScope;\n    const copy = this.copyWithNewNearestScope(letExprWithScope.scope);\n    letExprWithScope.args = n.args.map((a) =>\n      a.accept(copy)\n    ) as AssignmentNode[];\n    letExprWithScope.expr = n.expr.accept(copy);\n    for (const a of letExprWithScope.args) {\n      if (a.name) {\n        letExprWithScope.scope.variables.set(a.name, a);\n      }\n    }\n    return letExprWithScope;\n  }\n  visitAssertExpr(n: AssertExpr): ASTNode {\n    return new AssertExpr(\n      n.args.map((a) => a.accept(this)) as AssignmentNode[],\n      n.expr.accept(this),\n      n.tokens\n    );\n  }\n  visitEchoExpr(n: EchoExpr): ASTNode {\n    return new EchoExpr(\n      n.args.map((a) => a.accept(this)) as AssignmentNode[],\n      n.expr.accept(this),\n      n.tokens\n    );\n  }\n  visitLcIfExpr(n: LcIfExpr): ASTNode {\n    return new LcIfExpr(\n      n.cond.accept(this),\n      n.ifExpr.accept(this),\n      n.elseExpr ? n.elseExpr.accept(this) : null,\n      n.tokens\n    );\n  }\n  visitLcEachExpr(n: LcEachExpr): ASTNode {\n    return new LcEachExpr(n.expr.accept(this), n.tokens);\n  }\n  visitLcForExpr(n: LcForExpr): ASTNode {\n    const newNode = new LcForExprWithScope(\n      null as unknown as any,\n      null as unknown as any,\n      n.tokens\n    );\n    newNode.scope = new Scope();\n    newNode.scope.parent = this.nearestScope;\n    const copy = this.copyWithNewNearestScope(newNode.scope);\n    newNode.args = n.args.map((a) => a.accept(copy)) as AssignmentNode[];\n    newNode.expr = n.expr.accept(copy);\n    return newNode;\n  }\n  visitLcForCExpr(n: LcForCExpr): ASTNode {\n    const newNode = new LcForCExprWithScope(\n      null as unknown as any,\n      null as unknown as any,\n      null as unknown as any,\n      null as unknown as any,\n      n.tokens\n    );\n    newNode.scope = new Scope();\n    newNode.scope.parent = this.nearestScope;\n    const copy = this.copyWithNewNearestScope(newNode.scope);\n    newNode.args = n.args.map((a) => a.accept(copy)) as AssignmentNode[];\n    newNode.incrArgs = n.incrArgs.map((a) =>\n      a.accept(copy)\n    ) as AssignmentNode[];\n    newNode.cond = n.cond.accept(copy);\n    newNode.expr = n.expr.accept(copy);\n    return newNode;\n  }\n  visitLcLetExpr(n: LcLetExpr): ASTNode {\n    const lcLetWithScopeExpr = new LcLetExprWithScope(\n      null as unknown as any,\n      null as unknown as any,\n      n.tokens\n    );\n    lcLetWithScopeExpr.scope = new Scope();\n    lcLetWithScopeExpr.scope.parent = this.nearestScope;\n    const copy = this.copyWithNewNearestScope(lcLetWithScopeExpr.scope);\n    lcLetWithScopeExpr.args = n.args.map((a) =>\n      a.accept(copy)\n    ) as AssignmentNode[];\n    lcLetWithScopeExpr.expr = n.expr.accept(copy);\n    return lcLetWithScopeExpr;\n  }\n  visitGroupingExpr(n: GroupingExpr): ASTNode {\n    return new GroupingExpr(n.inner.accept(this), n.tokens);\n  }\n  visitUseStmt(n: UseStmt): ASTNode {\n    return n;\n  }\n  visitIncludeStmt(n: IncludeStmt): ASTNode {\n    return n;\n  }\n  visitModuleInstantiationStmt(n: ModuleInstantiationStmt): ASTNode {\n    if (n.name === \"for\" || n.name === \"intersection_for\") {\n      const inst = new ModuleInstantiationStmtWithScope(\n        n.name,\n        null as unknown as any,\n        null,\n        n.tokens\n      );\n      inst.scope = new Scope();\n      inst.scope.parent = this.nearestScope;\n      const copy = this.copyWithNewNearestScope(inst.scope);\n      inst.args = n.args.map((a) => a.accept(copy)) as AssignmentNode[];\n      inst.child = n.child ? n.child.accept(copy) : null;\n    }\n    const inst = new ModuleInstantiationStmt(\n      n.name,\n      n.args.map((a) => a.accept(this)) as AssignmentNode[],\n      n.child ? n.child.accept(this) : null,\n      n.tokens\n    );\n    inst.tagRoot = n.tagRoot;\n    inst.tagHighlight = n.tagHighlight;\n    inst.tagBackground = n.tagBackground;\n    inst.tagDisabled = n.tagDisabled;\n    return inst;\n  }\n  visitModuleDeclarationStmt(n: ModuleDeclarationStmt): ASTNode {\n    const md = new ModuleDeclarationStmtWithScope(\n      n.name,\n      null as unknown as any,\n      null as unknown as any,\n      n.tokens,\n      n.docComment\n    );\n    this.nearestScope.modules.set(md.name, md);\n    md.scope = new Scope();\n    md.scope.parent = this.nearestScope;\n    const copy = this.copyWithNewNearestScope(md.scope);\n    md.definitionArgs = n.definitionArgs.map((a) =>\n      a.accept(copy)\n    ) as AssignmentNode[];\n    md.stmt = n.stmt.accept(copy);\n    return md;\n  }\n  visitFunctionDeclarationStmt(n: FunctionDeclarationStmt): ASTNode {\n    const fDecl = new FunctionDeclarationStmtWithScope(\n      n.name,\n      null as unknown as any,\n      null as unknown as any,\n      n.tokens,\n      n.docComment\n    );\n    this.nearestScope.functions.set(n.name, fDecl);\n    fDecl.scope = new Scope();\n    fDecl.scope.parent = this.nearestScope;\n    const newPopulator = this.copyWithNewNearestScope(fDecl.scope);\n    fDecl.definitionArgs = n.definitionArgs.map((a) =>\n      a.accept(newPopulator)\n    ) as AssignmentNode[];\n    fDecl.expr = n.expr.accept(newPopulator);\n    return fDecl;\n  }\n  visitAnonymousFunctionExpr(n: AnonymousFunctionExpr): ASTNode {\n    const fDecl = new AnonymousFunctionExprWithScope(\n      null as unknown as any,\n      null as unknown as any,\n      n.tokens\n    );\n    fDecl.scope = new Scope();\n    fDecl.scope.parent = this.nearestScope;\n    const newPopulator = this.copyWithNewNearestScope(fDecl.scope);\n    fDecl.definitionArgs = n.definitionArgs.map((a) =>\n      a.accept(newPopulator)\n    ) as AssignmentNode[];\n    fDecl.expr = n.expr.accept(newPopulator);\n    return fDecl;\n  }\n  visitBlockStmt(n: BlockStmt): ASTNode {\n    const blk = new BlockStmtWithScope(null as unknown as any, n.tokens);\n    blk.scope = new Scope();\n    blk.scope.parent = this.nearestScope;\n    blk.children = n.children.map((c) =>\n      c.accept(this.copyWithNewNearestScope(blk.scope))\n    ) as Statement[];\n    return blk;\n  }\n  visitNoopStmt(n: NoopStmt): ASTNode {\n    return new NoopStmt(n.tokens);\n  }\n  visitIfElseStatement(n: IfElseStatement): ASTNode {\n    return new IfElseStatement(\n      n.cond.accept(this),\n      n.thenBranch.accept(this),\n      n.elseBranch ? n.elseBranch.accept(this) : null,\n      n.tokens\n    );\n  }\n  visitErrorNode(n: ErrorNode): ASTNode {\n    return new ErrorNode(n.tokens);\n  }\n}\n", "import { readFileSync } from \"fs\";\nimport { join } from \"path\";\nimport ScadFile from \"../ast/ScadFile\";\nimport CodeFile from \"../CodeFile\";\nimport ParsingHelper from \"../ParsingHelper\";\nimport ASTScopePopulator from \"../semantic/ASTScopePopulator\";\nimport Scope from \"../semantic/Scope\";\n\nexport default class PreludeUtil {\n  private static _cachedPreludeScope: Scope | null = null;\n  public static get preludeScope() {\n    if (!this._cachedPreludeScope) {\n      const preludeLocation = join(__dirname, \"prelude.scad\");\n      let [ast, ec] = ParsingHelper.parseFile(\n        new CodeFile(preludeLocation, readFileSync(preludeLocation, \"utf8\"))\n      );\n      ec.throwIfAny();\n      this._cachedPreludeScope = new Scope();\n      const pop = new ASTScopePopulator(this._cachedPreludeScope);\n      if(!ast) {\n        throw new Error(\"prelude ast is null\");\n      }\n      ast = ast.accept(pop) as ScadFile;\n    }\n\n    return this._cachedPreludeScope;\n  }\n}\n", "import AssignmentNode, { AssignmentNodeRole } from \"../ast/AssignmentNode\";\nimport ASTNode from \"../ast/ASTNode\";\nimport {\n  FunctionDeclarationStmt,\n  ModuleDeclarationStmt,\n} from \"../ast/statements\";\nimport ASTAssembler from \"../ASTAssembler\";\nimport CodeSpan from \"../CodeSpan\";\nimport LiteralToken from \"../LiteralToken\";\nimport Token from \"../Token\";\n\nexport enum SymbolKind {\n  MODULE,\n  FUNCTION,\n  VARIABLE,\n}\n\n/**\n * Generates a symbol tree for the outline view in vscode.\n * It uses AST assembler to walk down the tree and determine the full range of a symbol.\n */\nexport default class ASTSymbolLister<SymType> extends ASTAssembler<Token[]> {\n  constructor(\n    public makeSymbol: (\n      name: string,\n      kind: SymbolKind,\n      fullRange: CodeSpan,\n      nameRange: CodeSpan,\n      children: SymType[]\n    ) => SymType\n  ) {\n    super();\n  }\n\n  /**\n   * Returns the node at pinpointLocation and populates bottomUpHierarchy.\n   * @param n The AST (or AST fragment) to search through.\n   */\n  doList(n: ASTNode): SymType[] {\n    n.accept(this);\n    return this.symbolsAtCurrentDepth;\n  }\n\n  private symbolsAtCurrentDepth: SymType[] = [];\n\n  protected processAssembledNode(\n    t: (Token | (() => Token[]))[],\n    self: ASTNode\n  ): Token[] {\n    let currKind: SymbolKind | null = null;\n    let currName: LiteralToken<string> | null = null;\n    if (self instanceof FunctionDeclarationStmt) {\n      currKind = SymbolKind.FUNCTION;\n      currName = self.tokens.name as LiteralToken<string>;\n    } else if (self instanceof ModuleDeclarationStmt) {\n      currKind = SymbolKind.MODULE;\n      currName = self.tokens.name as LiteralToken<string>;\n    } else if (\n      self instanceof AssignmentNode &&\n      self.role === AssignmentNodeRole.VARIABLE_DECLARATION\n    ) {\n      currKind = SymbolKind.VARIABLE;\n      currName = self.tokens.name as LiteralToken<string>;\n    }\n    const newArr: Token[] = [];\n    for (const m of t) {\n      if (typeof m === \"function\") {\n        newArr.push(...m());\n      } else {\n        newArr.push(m);\n      }\n    }\n    if (currKind != null && currName != null) {\n      let savedSymbols = this.symbolsAtCurrentDepth;\n      this.symbolsAtCurrentDepth = [];\n\n      const childrenSymbols = this.symbolsAtCurrentDepth;\n      this.symbolsAtCurrentDepth = savedSymbols; // restore the symbols\n      this.symbolsAtCurrentDepth.push(\n        this.makeSymbol(\n          currName.value,\n          currKind,\n          CodeSpan.combine(...newArr.map((t) => t.span)),\n          currName.span,\n          childrenSymbols\n        )\n      );\n      return newArr;\n    } else {\n      return newArr;\n    }\n  }\n}\n", "import {\n  AssignmentNode,\n  DocComment,\n  FunctionDeclarationStmt,\n  ModuleDeclarationStmt,\n} from \"..\";\nimport CompletionType from \"./CompletionType\";\n\nexport type Declaration =\n  | AssignmentNode\n  | ModuleDeclarationStmt\n  | FunctionDeclarationStmt;\n\nexport default class CompletionSymbol {\n  constructor(\n    public type: CompletionType,\n    public name: string,\n    public decl?: Declaration\n  ) {}\n}\n", "enum CompletionType {\n  VARIABLE,\n  FUNCTION,\n  MODULE,\n  KEYWORD,\n  FILE,\n  DIRECTORY,\n}\n\nexport default CompletionType;\n", "import ScadFileProvider, { WithExportedScopes } from \"./ScadFileProvider\";\nimport ScadFile from \"../ast/ScadFile\";\nimport { UseStmt, IncludeStmt } from \"../ast/statements\";\nimport { promises as fs } from \"fs\";\nimport * as os from \"os\";\nimport * as path from \"path\";\nimport ErrorCollector from \"../ErrorCollector\";\nimport CodeError from \"../errors/CodeError\";\nimport CodeLocation from \"../CodeLocation\";\n\nexport class IncludedFileNotFoundError extends CodeError {\n  constructor(pos: CodeLocation, filename: string) {\n    super(pos, `Included file '${filename} not found.'`);\n  }\n}\n\nexport class UsedFileNotFoundError extends CodeError {\n  constructor(pos: CodeLocation, filename: string) {\n    super(pos, `Used file '${filename} not found.'`);\n  }\n}\n\nexport default class IncludeResolver<T extends WithExportedScopes> {\n  constructor(private provider: ScadFileProvider<T>) {}\n  /**\n   * Finds all file includes and returns paths to them\n   * @param f\n   */\n  async resolveIncludes(f: ScadFile, ec: ErrorCollector) {\n    if (!f.span.start.file) {\n      throw new Error(\"file in pos is null\");\n    }\n    const includes: string[] = [];\n    for (const stmt of f.statements) {\n      if (stmt instanceof IncludeStmt) {\n        const filePath = await this.locateScadFile(\n          f.span.start.file.path,\n          stmt.filename\n        );\n        if (!filePath) {\n          ec.reportError(\n            new IncludedFileNotFoundError(\n              stmt.tokens.filename.span.start,\n              stmt.filename\n            )\n          );\n          continue;\n        }\n        includes.push(filePath);\n      }\n    }\n    return Promise.all(\n      includes.map((incl) => this.provider.provideScadFile(incl))\n    );\n  }\n\n  /**\n   * Finds all file uses and returns paths to them.\n   * Uses do not export to parent scopes and do not execute statements inside of the used files.\n   * @param f\n   */\n  async resolveUses(f: ScadFile, ec: ErrorCollector) {\n    if(!f.span.start.file) {\n      throw new Error(\"file in pos is null\");\n    }\n    const uses: string[] = [];\n    for (const stmt of f.statements) {\n      if (stmt instanceof UseStmt) {\n        const filePath = await this.locateScadFile(\n          f.span.start.file.path,\n          stmt.filename\n        );\n        if (!filePath) {\n          ec.reportError(\n            new UsedFileNotFoundError(stmt.tokens.filename.span.start, stmt.filename)\n          );\n          continue;\n        }\n        uses.push(filePath);\n      }\n    }\n    return Promise.all(uses.map((incl) => this.provider.provideScadFile(incl)));\n  }\n\n  async locateScadFile(parent: string, relativePath: string) {\n    const searchDirs = [path.dirname(parent), ...IncludeResolver.includeDirs];\n    for (const dir of searchDirs) {\n      const resultingPath = path.resolve(dir, relativePath);\n      try {\n        if ((await fs.stat(resultingPath)).isFile()) {\n          return resultingPath;\n        }\n      } catch (e) {}\n    }\n    return null;\n  }\n\n  private static _includeDirsCache: string[] | null = null;\n\n  static get includeDirs() {\n    if (!this._includeDirsCache) {\n      this._includeDirsCache = [];\n      const ENV_SEP = os.platform() === \"win32\" ? \";\" : \":\";\n      this._includeDirsCache.push(\n        ...(process.env.OPENSCADPATH || \"\").split(ENV_SEP)\n      );\n      if (os.platform() === \"win32\") {\n        // TODO: add my documents path\n        // TODO: add installation directory\n      }\n      if (os.platform() === \"linux\") {\n        this._includeDirsCache.push(\n          path.join(os.homedir(), \".local/share/OpenSCAD/libraries\")\n        );\n        this._includeDirsCache.push(\"/usr/share/openscad/libraries\");\n      }\n      if (os.platform() === \"darwin\") {\n        this._includeDirsCache.push(\n          path.join(os.homedir(), \"Documents/OpenSCAD/libraries\")\n        );\n        //TODO: add installation directory\n      }\n    }\n    return this._includeDirsCache;\n  }\n}\n", "import CompletionProvider from \"./CompletionProvider\";\nimport CompletionSymbol from \"./CompletionSymbol\";\nimport * as path from \"path\";\nimport { promises as fs } from \"fs\";\nimport CompletionType from \"./CompletionType\";\nimport IncludeResolver from \"./IncludeResolver\";\nimport ASTNode from \"../ast/ASTNode\";\nimport CodeLocation from \"../CodeLocation\";\n/**\n * FilenameCompletionProvider provides completions to the include<> and use<> statements.\n */\nexport default class FilenameCompletionProvider implements CompletionProvider {\n  textOnly = true;\n  exclusive = true;\n  /**\n   * Determines whether we are in a include<> or use<> statement\n   * @param ast\n   * @param loc\n   */\n  shouldActivate(ast: ASTNode, loc: CodeLocation): boolean {\n    return this.getExistingPath(ast, loc) != null;\n  }\n\n  async getSymbolsAtLocation(\n    ast: ASTNode,\n    locM: CodeLocation\n  ): Promise<CompletionSymbol[]> {\n    const loc = new CodeLocation(locM.file, locM.char, locM.line, locM.col);\n    let existingPath = this.getExistingPath(ast, loc) || \"\";\n    let searchDirs: string[] = [];\n    if (path.isAbsolute(existingPath)) {\n      searchDirs = [path.dirname(existingPath)];\n    } else {\n      searchDirs = IncludeResolver.includeDirs.map((id) =>\n        path.join(id, path.dirname(existingPath))\n      );\n    }\n    let output: CompletionSymbol[] = [];\n\n    for (const sd of searchDirs) {\n      try {\n        const filenames = (await fs.readdir(sd)).filter((p) =>\n          p.startsWith(path.basename(existingPath))\n        );\n\n        output = [\n          ...output,\n          ...((\n            await Promise.all(\n              filenames.map(async (f) => {\n                const stat = await fs.stat(path.join(sd, f));\n                if (stat.isDirectory()) {\n                  return new CompletionSymbol(CompletionType.DIRECTORY, f);\n                }\n                if (stat.isFile() && f.endsWith(\".scad\")) {\n                  return new CompletionSymbol(CompletionType.FILE, f);\n                }\n                return null;\n              })\n            )\n          ).filter((s) => !!s) as CompletionSymbol[]),\n        ];\n      } catch (e) {\n        console.error(\"filed to find in dir\", sd, e);\n      }\n    }\n\n    return output;\n  }\n\n  /**\n   * Obtains the part of the included path the user has already entered\n   * @param ast the ast to search\n   * @param loc the location where the user is typing\n   * @returns the part of the included path the user has already entered\n   */\n  getExistingPath(ast: ASTNode, loc: CodeLocation): string | null {\n    let charPos = loc.char;\n    let linesLimit = 5;\n    let stage = 0;\n    let existingFilename = \"\";\n    let isFirst = true;\n    if(!loc.file) {\n      throw new Error(\"No file in CodeLocation\");\n    }\n    while (true) {\n      if (charPos <= 0 || linesLimit <= 0) {\n        return null;\n      }\n      const char = loc.file.code[charPos];\n      if (char === \"\\n\") {\n        linesLimit--;\n      }\n      if (!isFirst && char === \">\") {\n        return null;\n      }\n\n      if (!isFirst && stage === 0 && char === \"<\") {\n        stage++;\n        existingFilename = loc.file.code.substring(charPos + 1, loc.char + 1);\n      } else if (\n        stage === 1 &&\n        char !== \" \" &&\n        char !== \"\\t\" &&\n        char !== \"\\r\" &&\n        char !== \"\\n\"\n      ) {\n        if (\n          loc.file.code.substring(charPos - \"use\".length + 1, charPos + 1) ===\n          \"use\"\n        ) {\n          if (existingFilename.endsWith(\">\")) {\n            return existingFilename.slice(0, -1);\n          }\n          return existingFilename;\n        }\n        if (\n          loc.file.code.substring(\n            charPos - \"include\".length + 1,\n            charPos + 1\n          ) === \"include\"\n        ) {\n          if (existingFilename.endsWith(\">\")) {\n            return existingFilename.slice(0, -1);\n          }\n          return existingFilename;\n        }\n        return null;\n      }\n      isFirst = false;\n      charPos--;\n    }\n  }\n}\n", "import CompletionProvider from \"./CompletionProvider\";\nimport CompletionSymbol from \"./CompletionSymbol\";\nimport ASTNode from \"../ast/ASTNode\";\nimport CodeLocation from \"../CodeLocation\";\nimport keywords from \"../keywords\";\nimport CompletionType from \"./CompletionType\";\n\nexport default class KeywordsCompletionProvider implements CompletionProvider {\n  textOnly = true;\n  exclusive = false;\n  shouldActivate(ast: ASTNode, loc: CodeLocation): boolean {\n    return true;\n  }\n  async getSymbolsAtLocation(\n    ast: ASTNode,\n    loc: CodeLocation\n  ): Promise<CompletionSymbol[]> {\n    return Object.keys(keywords).map(\n      (kwrd) => new CompletionSymbol(CompletionType.KEYWORD, kwrd)\n    );\n  }\n}\n", "import ASTNode from \"../ast/ASTNode\";\nimport ASTPinpointer from \"../ASTPinpointer\";\nimport CodeLocation from \"../CodeLocation\";\nimport CompletionProvider from \"./CompletionProvider\";\nimport CompletionSymbol from \"./CompletionSymbol\";\nimport CompletionType from \"./CompletionType\";\nimport NodeWithScope from \"./NodeWithScope\";\nimport Scope from \"./Scope\";\n\nexport default class ScopeSymbolCompletionProvider\n  implements CompletionProvider\n{\n  textOnly = false;\n  exclusive = false;\n  shouldActivate(ast: ASTNode, loc: CodeLocation): boolean {\n    return true;\n  }\n  async getSymbolsAtLocation(\n    ast: ASTNode,\n    loc: CodeLocation\n  ): Promise<CompletionSymbol[]> {\n    const pp = new ASTPinpointer(loc);\n    pp.doPinpoint(ast);\n    let symbols: CompletionSymbol[] = [];\n    const scopesToShow: Scope[] = [];\n    for (const h of pp.bottomUpHierarchy) {\n      const hh: NodeWithScope = h as NodeWithScope;\n      if (\"scope\" in hh && hh.scope instanceof Scope) {\n        scopesToShow.push(hh.scope);\n        scopesToShow.push(...hh.scope.siblingScopes);\n      }\n    }\n    for (const scope of scopesToShow) {\n      for (const v of scope.variables) {\n        symbols.push(\n          new CompletionSymbol(CompletionType.VARIABLE, v[1].name, v[1])\n        );\n      }\n      for (const f of scope.functions) {\n        symbols.push(\n          new CompletionSymbol(CompletionType.FUNCTION, f[1].name, f[1])\n        );\n      }\n      for (const m of scope.modules) {\n        symbols.push(\n          new CompletionSymbol(CompletionType.MODULE, m[1].name, m[1])\n        );\n      }\n    }\n\n    return symbols;\n  }\n}\n", "import ASTNode from \"../ast/ASTNode\";\nimport CodeLocation from \"../CodeLocation\";\nimport CompletionProvider from \"./CompletionProvider\";\nimport FilenameCompletionProvider from \"./FilenameCompletionProvider\";\nimport KeywordsCompletionProvider from \"./KeywordsCompletionProvider\";\nimport ScopeSymbolCompletionProvider from \"./ScopeSymbolCompletionProvider\";\nimport CompletionSymbol from \"./CompletionSymbol\";\n\nexport default class CompletionUtil {\n  static completionProviders: CompletionProvider[] = [\n    new FilenameCompletionProvider(),\n    new KeywordsCompletionProvider(),\n    new ScopeSymbolCompletionProvider(),\n  ];\n  static async getSymbolsAtLocation(\n    ast: ASTNode,\n    loc: CodeLocation\n  ): Promise<CompletionSymbol[]> {\n    let symbols: CompletionSymbol[] = [];\n    for (const cp of this.completionProviders) {\n      if (!cp.textOnly && !ast) continue;\n      if (cp.shouldActivate(ast, loc)) {\n        symbols = [...symbols, ...(await cp.getSymbolsAtLocation(ast, loc))];\n        if (cp.exclusive) {\n          break;\n        }\n      }\n    }\n    return symbols;\n  }\n}\n", "import AssignmentNode from \"../ast/AssignmentNode\";\nimport { FunctionCallExpr, LookupExpr } from \"../ast/expressions\";\nimport {\n  FunctionDeclarationStmt,\n  ModuleDeclarationStmt,\n  ModuleInstantiationStmt,\n} from \"../ast/statements\";\n\n/**\n * Represents a resolved lookup expression. It can either\n * point to an assignment node, or to a named function declaration.\n * \n * resolvedDeclaration must be set by the instantiating class.\n */\nexport class ResolvedLookupExpr extends LookupExpr {\n  resolvedDeclaration!: AssignmentNode | FunctionDeclarationStmt;\n}\n\nexport class ResolvedModuleInstantiationStmt extends ModuleInstantiationStmt {\n  resolvedDeclaration!: ModuleDeclarationStmt;\n}\n", "import CodeLocation from \"../CodeLocation\";\nimport CodeError from \"../errors/CodeError\";\n\nexport class UnresolvedFunctionError extends CodeError {\n  constructor(pos: CodeLocation, functionName: string) {\n    super(pos, `Unresolved function '${functionName}'.`);\n  }\n}\n\nexport class UnresolvedModuleError extends CodeError {\n  constructor(pos: CodeLocation, functionName: string) {\n    super(pos, `Unresolved module '${functionName}'.`);\n  }\n}\n\nexport class UnresolvedVariableError extends CodeError {\n  constructor(pos: CodeLocation, functionName: string) {\n    super(pos, `Unresolved variable '${functionName}'.`);\n  }\n}\n", "import AssignmentNode from \"../ast/AssignmentNode\";\nimport ASTNode from \"../ast/ASTNode\";\nimport {\n  AnonymousFunctionExpr,\n  FunctionCallExpr,\n  LcForCExpr,\n  LcForExpr,\n  LcLetExpr,\n  LetExpr,\n  LookupExpr,\n} from \"../ast/expressions\";\nimport ScadFile from \"../ast/ScadFile\";\nimport {\n  BlockStmt,\n  FunctionDeclarationStmt,\n  ModuleDeclarationStmt,\n  ModuleInstantiationStmt,\n} from \"../ast/statements\";\nimport ASTMutator from \"../ASTMutator\";\nimport ErrorCollector from \"../ErrorCollector\";\nimport NodeWithScope from \"./NodeWithScope\";\nimport {\n  ResolvedLookupExpr,\n  ResolvedModuleInstantiationStmt,\n} from \"./resolvedNodes\";\nimport Scope from \"./Scope\";\nimport {\n  UnresolvedFunctionError,\n  UnresolvedModuleError,\n  UnresolvedVariableError,\n} from \"./unresolvedSymbolErrors\";\n\nexport default class SymbolResolver extends ASTMutator {\n  constructor(\n    private errorCollector: ErrorCollector,\n    /** \n     * Represents the scope where the resolver has descended.\n     * It initially is null, but the resolver should encounter a NodeWithScope \n     * and set this to the scope of that node.\n     */\n    public currentScope: Scope | null = null,\n    public isInCallee: boolean = false\n  ) {\n    super();\n  }\n\n  visitLookupExpr(n: LookupExpr): ASTNode {\n    if(! this.currentScope) {\n      throw new Error(\"currentScope cannot be null when resolving lookup\");\n    }\n    const resolved = new ResolvedLookupExpr(n.name, n.tokens);\n    resolved.resolvedDeclaration = this.currentScope.lookupVariable(n.name);\n    if(this.isInCallee && !resolved.resolvedDeclaration) {\n      resolved.resolvedDeclaration = this.currentScope.lookupFunction(n.name);\n    }\n    if (!resolved.resolvedDeclaration) {\n      this.errorCollector.reportError(\n        new UnresolvedVariableError(n.span.start, n.name)\n      );\n      return n;\n    }\n    return resolved;\n  }\n\n  visitModuleInstantiationStmt(n: ModuleInstantiationStmt): ASTNode {\n    if(! this.currentScope) {\n      throw new Error(\"currentScope cannot be null when resolving module\");\n    }\n    const resolved = new ResolvedModuleInstantiationStmt(\n      n.name,\n      n.args.map((a) => a.accept(this)) as AssignmentNode[],\n      n.child ? n.child.accept(this) : null,\n      n.tokens\n    );\n    resolved.resolvedDeclaration = this.currentScope.lookupModule(n.name);\n    if (!resolved.resolvedDeclaration) {\n      this.errorCollector.reportError(new UnresolvedModuleError(n.span.start, n.name));\n      return n;\n    }\n    return resolved;\n  }\n\n \n  /**\n   * visitFunctionCallExpr switches the SymbolResolver into a special mode where\n   * it falls back to resolving named functions when processing lookup expressions.\n   * This behaviour tries to mimic the behaviour of OpenSCAD's function call resolution,\n   * it is not perfect, since you can abuse this to do things like assign a named function\n   * to a variable which is not allowed in OpenSCAD. So this covers all but the most\n   * pathological cases.\n   * @param n \n   * @returns \n   */\n  visitFunctionCallExpr(n: FunctionCallExpr): ASTNode {\n    return super.visitFunctionCallExpr.call(\n      this.copyWithIsInCallee(),\n      n\n    );\n  }\n\n  // scope handling\n  private copyWithNextScope(s: Scope) {\n    if (!s) {\n      throw new Error(\"Scope cannot be falsy\");\n    }\n    return new SymbolResolver(this.errorCollector, s, this.isInCallee);\n  }\n\n  private copyWithIsInCallee() {\n    return new SymbolResolver(this.errorCollector, this.currentScope, true);\n  }\n\n  visitBlockStmt(n: BlockStmt): ASTNode {\n    return super.visitBlockStmt.call(\n      this.copyWithNextScope((n as unknown as NodeWithScope).scope),\n      n\n    );\n  }\n  visitLetExpr(n: LetExpr): ASTNode {\n    return super.visitLetExpr.call(\n      this.copyWithNextScope((n as unknown as NodeWithScope).scope),\n      n\n    );\n  }\n  visitScadFile(n: ScadFile): ASTNode {\n    return super.visitScadFile.call(\n      this.copyWithNextScope((n as unknown as NodeWithScope).scope),\n      n\n    );\n  }\n  visitFunctionDeclarationStmt(n: FunctionDeclarationStmt): ASTNode {\n    return super.visitFunctionDeclarationStmt.call(\n      this.copyWithNextScope((n as unknown as NodeWithScope).scope),\n      n\n    );\n  }\n  visitModuleDeclarationStmt(n: ModuleDeclarationStmt): ASTNode {\n    return super.visitModuleDeclarationStmt.call(\n      this.copyWithNextScope((n as unknown as NodeWithScope).scope),\n      n\n    );\n  }\n  visitLcLetExpr(n: LcLetExpr): ASTNode {\n    return super.visitLcLetExpr.call(\n      this.copyWithNextScope((n as unknown as NodeWithScope).scope),\n      n\n    );\n  }\n  visitLcForExpr(n: LcForExpr): ASTNode {\n    return super.visitLcForExpr.call(\n      this.copyWithNextScope((n as unknown as NodeWithScope).scope),\n      n\n    );\n  }\n  visitLcForCExpr(n: LcForCExpr): ASTNode {\n    return super.visitLcForCExpr.call(\n      this.copyWithNextScope((n as unknown as NodeWithScope).scope),\n      n\n    );\n  }\n  visitAnonymousFunctionExpr(n: AnonymousFunctionExpr): ASTNode {\n    return super.visitAnonymousFunctionExpr.call(\n      this.copyWithNextScope((n as unknown as NodeWithScope).scope),\n      n\n    );\n  }\n}\n", "import * as path from \"path\";\nimport ASTNode from \"./ast/ASTNode\";\nimport ScadFile from \"./ast/ScadFile\";\nimport ASTPinpointer from \"./ASTPinpointer\";\nimport ASTPrinter from \"./ASTPrinter\";\nimport CodeFile from \"./CodeFile\";\nimport CodeLocation from \"./CodeLocation\";\nimport CodeSpan from \"./CodeSpan\";\nimport FormattingConfiguration from \"./FormattingConfiguration\";\nimport ParsingHelper from \"./ParsingHelper\";\nimport PreludeUtil from \"./prelude/PreludeUtil\";\nimport ASTScopePopulator from \"./semantic/ASTScopePopulator\";\nimport ASTSymbolLister, { SymbolKind } from \"./semantic/ASTSymbolLister\";\nimport CompletionUtil from \"./semantic/CompletionUtil\";\nimport IncludeResolver from \"./semantic/IncludeResolver\";\nimport { ScadFileWithScope } from \"./semantic/nodesWithScopes\";\nimport {\n  ResolvedLookupExpr,\n  ResolvedModuleInstantiationStmt\n} from \"./semantic/resolvedNodes\";\nimport ScadFileProvider, {\n  WithExportedScopes\n} from \"./semantic/ScadFileProvider\";\nimport Scope from \"./semantic/Scope\";\nimport SymbolResolver from \"./semantic/SymbolResolver\";\n\nexport class SolutionFile implements WithExportedScopes {\n  codeFile!: CodeFile;\n  ast: ASTNode|null = null;\n  dependencies!: SolutionFile[];\n  errors!: Error[];\n  includeResolver: IncludeResolver<SolutionFile>;\n\n  includedFiles!: SolutionFile[];\n\n  onlyOwnScope!: Scope;\n\n  constructor(public solutionManager: SolutionManager) {\n    this.includeResolver = new IncludeResolver(this.solutionManager);\n  }\n\n  async parseAndProcess() {\n    let [ast, errors] = ParsingHelper.parseFile(this.codeFile);\n    if (ast) {\n      this.ast = new ASTScopePopulator(new Scope()).populate(ast);\n      this.includedFiles = await this.includeResolver.resolveIncludes(\n        this.ast as ScadFile,\n        errors\n      );\n      const usedFiles = await this.includeResolver.resolveIncludes(\n        this.ast as ScadFile,\n        errors\n      );\n      this.dependencies = [...this.includedFiles, ...usedFiles];\n      this.onlyOwnScope = (this.ast as ScadFileWithScope).scope.copy();\n      (this.ast as ScadFileWithScope).scope.siblingScopes = [\n        ...this.includedFiles.map((f) => f.getExportedScopes()).flat(),\n        ...usedFiles.map((f) => f.getExportedScopes()).flat(),\n        PreludeUtil.preludeScope,\n      ];\n      this.ast = this.ast.accept(new SymbolResolver(errors));\n    }\n    this.errors = errors.errors;\n  }\n  getCompletionsAtLocation(loc: CodeLocation) {\n    return CompletionUtil.getSymbolsAtLocation(this.ast!, loc);\n  }\n\n  getSymbols<SymType>(\n    makeSymbol: (\n      name: string,\n      kind: SymbolKind,\n      fullRange: CodeSpan,\n      nameRange: CodeSpan,\n      children: SymType[]\n    ) => SymType\n  ) {\n    const l = new ASTSymbolLister<SymType>(makeSymbol);\n    return l.doList(this.ast!);\n  }\n\n  getFormatted() {\n    return new ASTPrinter(new FormattingConfiguration()).visitScadFile(\n      this.ast as ScadFile\n    );\n  }\n\n  getExportedScopes(): Scope[] {\n    return [\n      this.onlyOwnScope,\n      ...this.includedFiles.map((f) => f.getExportedScopes()).flat(),\n    ];\n  }\n  getSymbolDeclaration(loc: CodeLocation) {\n    const pp = new ASTPinpointer(loc).doPinpoint(this.ast!);\n    if (\n      pp instanceof ResolvedLookupExpr ||\n      pp instanceof ResolvedModuleInstantiationStmt\n    ) {\n      return pp.resolvedDeclaration;\n    }\n    return null;\n  }\n  getSymbolDeclarationLocation(loc: CodeLocation): CodeLocation | null {\n    const decl = this.getSymbolDeclaration(loc);\n    if (decl) {\n      return decl.tokens.name ? decl.tokens.name.span.start : null;\n    }\n    return null;\n  }\n}\n\nexport default class SolutionManager implements ScadFileProvider<SolutionFile> {\n  openedFiles: Map<string, SolutionFile> = new Map();\n  allFiles: Map<string, SolutionFile> = new Map();\n  notReadyFiles: Map<string, Promise<SolutionFile>> = new Map();\n\n  /**\n   * Returns a registered solution file for a given path. It supports getting files which have not been fully processed yet.\n   * @param filePath\n   */\n  async getFile(filePath: string) {\n    if (!path.isAbsolute(filePath)) {\n      throw new Error(\"Path must be absolute and normalized.\");\n    }\n    let file = this.allFiles.get(filePath);\n    if (file) {\n      return file;\n    }\n    return await this.notReadyFiles.get(filePath);\n  }\n\n  async notifyNewFileOpened(filePath: string, contents: string) {\n    if (!path.isAbsolute(filePath)) {\n      throw new Error(\"Path must be absolute and normalized.\");\n    }\n    const cFile = new CodeFile(filePath, contents);\n\n    this.openedFiles.set(filePath, await this.attachSolutionFile(cFile));\n  }\n\n  async notifyFileChanged(filePath: string, contents: string) {\n    if (!path.isAbsolute(filePath)) {\n      throw new Error(\"Path must be absolute and normalized.\");\n    }\n    const cFile = new CodeFile(filePath, contents);\n    let sf = this.openedFiles.get(filePath);\n    if (!sf) {\n      if (this.notReadyFiles.has(filePath)) {\n        sf = await this.notReadyFiles.get(filePath) as SolutionFile;\n      } else {\n        throw new Error(\"No such file\");\n      }\n    }\n    sf.codeFile = cFile;\n    await sf.parseAndProcess();\n  }\n\n  notifyFileClosed(filePath: string) {\n    this.openedFiles.delete(filePath);\n    this.garbageCollect();\n  }\n\n  protected async attachSolutionFile(codeFile: CodeFile) {\n    const solutionFile = new SolutionFile(this);\n    solutionFile.codeFile = codeFile;\n    try {\n      let resolve!: (s: SolutionFile) => void;\n      this.notReadyFiles.set(\n        codeFile.path,\n        new Promise<SolutionFile>((r) => (resolve = r))\n      );\n      await solutionFile.parseAndProcess();\n      resolve(solutionFile);\n      this.allFiles.set(codeFile.path, solutionFile);\n      return solutionFile;\n    } finally {\n      this.notReadyFiles.delete(codeFile.path);\n    }\n  }\n\n  /**\n   * Checks whether a file is already in the solution, and if not it loads it from disk.\n   * @param filePath The dependent-upon file.\n   */\n  async provideScadFile(filePath: string) {\n    let f: SolutionFile | undefined = await this.getFile(filePath);\n    if (f) return f; // the file is already opened or refrenced by antoher\n    return await this.attachSolutionFile(await CodeFile.load(filePath));\n  }\n\n  /**\n   * Removes dependencies that aren't directly or indirectly referenced in any of the open files to free memory.\n   */\n  protected garbageCollect() {\n    const gcMarked = new WeakMap<SolutionFile, boolean>();\n    function markRecursive(f: SolutionFile) {\n      gcMarked.set(f, true);\n      for (const dep of f.dependencies) {\n        if (!gcMarked.has(dep)) {\n          markRecursive(dep);\n        }\n      }\n    }\n    for (const [_, dep] of this.openedFiles) {\n      markRecursive(dep);\n    }\n    for (const [path, f] of this.allFiles) {\n      if (!gcMarked.has(f)) {\n        this.allFiles.delete(path);\n      }\n    }\n  }\n}\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=ASTVisitor.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=DocAnnotationClass.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=CompletionProvider.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=NodeWithScope.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=ScadFileProvider.js.map", "/**\n * @file Automatically generated by barrelsby.\n */\n\nexport { default as ASTAssembler } from \"./ASTAssembler\";\nexport * from \"./ASTAssembler\";\nexport { default as ASTMutator } from \"./ASTMutator\";\nexport * from \"./ASTMutator\";\nexport { default as ASTPinpointer } from \"./ASTPinpointer\";\nexport * from \"./ASTPinpointer\";\nexport { default as ASTPrinter } from \"./ASTPrinter\";\nexport * from \"./ASTPrinter\";\nexport { default as CodeFile } from \"./CodeFile\";\nexport * from \"./CodeFile\";\nexport { default as CodeLocation } from \"./CodeLocation\";\nexport * from \"./CodeLocation\";\nexport { default as ErrorCollector } from \"./ErrorCollector\";\nexport * from \"./ErrorCollector\";\nexport { default as FormattingConfiguration } from \"./FormattingConfiguration\";\nexport * from \"./FormattingConfiguration\";\nexport { default as Lexer } from \"./Lexer\";\nexport * from \"./Lexer\";\nexport { default as LiteralToken } from \"./LiteralToken\";\nexport * from \"./LiteralToken\";\nexport { default as Parser } from \"./Parser\";\nexport * from \"./Parser\";\nexport { default as ParsingHelper } from \"./ParsingHelper\";\nexport * from \"./ParsingHelper\";\nexport { default as SolutionManager } from \"./SolutionManager\";\nexport * from \"./SolutionManager\";\nexport { default as Token } from \"./Token\";\nexport * from \"./Token\";\nexport { default as TokenType } from \"./TokenType\";\nexport * from \"./TokenType\";\nexport * from \"./extraTokens\";\nexport { default as friendlyTokenNames } from \"./friendlyTokenNames\";\nexport * from \"./friendlyTokenNames\";\nexport { default as keywords } from \"./keywords\";\nexport * from \"./keywords\";\nexport { default as ASTNode } from \"./ast/ASTNode\";\nexport * from \"./ast/ASTNode\";\nexport { default as ASTVisitor } from \"./ast/ASTVisitor\";\nexport * from \"./ast/ASTVisitor\";\nexport { default as AssignmentNode } from \"./ast/AssignmentNode\";\nexport * from \"./ast/AssignmentNode\";\nexport { default as ErrorNode } from \"./ast/ErrorNode\";\nexport * from \"./ast/ErrorNode\";\nexport { default as ScadFile } from \"./ast/ScadFile\";\nexport * from \"./ast/ScadFile\";\nexport * from \"./ast/expressions\";\nexport * from \"./ast/statements\";\nexport { default as DocAnnotationClass } from \"./comments/DocAnnotationClass\";\nexport * from \"./comments/DocAnnotationClass\";\nexport { default as DocComment } from \"./comments/DocComment\";\nexport * from \"./comments/DocComment\";\nexport * from \"./comments/annotations\";\nexport { default as CodeError } from \"./errors/CodeError\";\nexport * from \"./errors/CodeError\";\nexport { default as LexingError } from \"./errors/LexingError\";\nexport * from \"./errors/LexingError\";\nexport { default as ParsingError } from \"./errors/ParsingError\";\nexport * from \"./errors/ParsingError\";\nexport * from \"./errors/lexingErrors\";\nexport * from \"./errors/parsingErrors\";\nexport { default as PreludeUtil } from \"./prelude/PreludeUtil\";\nexport * from \"./prelude/PreludeUtil\";\nexport { default as ASTScopePopulator } from \"./semantic/ASTScopePopulator\";\nexport * from \"./semantic/ASTScopePopulator\";\nexport { default as ASTSymbolLister } from \"./semantic/ASTSymbolLister\";\nexport * from \"./semantic/ASTSymbolLister\";\nexport { default as CompletionProvider } from \"./semantic/CompletionProvider\";\nexport * from \"./semantic/CompletionProvider\";\nexport { default as CompletionSymbol } from \"./semantic/CompletionSymbol\";\nexport * from \"./semantic/CompletionSymbol\";\nexport { default as CompletionType } from \"./semantic/CompletionType\";\nexport * from \"./semantic/CompletionType\";\nexport { default as CompletionUtil } from \"./semantic/CompletionUtil\";\nexport * from \"./semantic/CompletionUtil\";\nexport { default as FilenameCompletionProvider } from \"./semantic/FilenameCompletionProvider\";\nexport * from \"./semantic/FilenameCompletionProvider\";\nexport { default as IncludeResolver } from \"./semantic/IncludeResolver\";\nexport * from \"./semantic/IncludeResolver\";\nexport { default as KeywordsCompletionProvider } from \"./semantic/KeywordsCompletionProvider\";\nexport * from \"./semantic/KeywordsCompletionProvider\";\nexport { default as NodeWithScope } from \"./semantic/NodeWithScope\";\nexport * from \"./semantic/NodeWithScope\";\nexport { default as ScadFileProvider } from \"./semantic/ScadFileProvider\";\nexport * from \"./semantic/ScadFileProvider\";\nexport { default as Scope } from \"./semantic/Scope\";\nexport * from \"./semantic/Scope\";\nexport { default as ScopeSymbolCompletionProvider } from \"./semantic/ScopeSymbolCompletionProvider\";\nexport * from \"./semantic/ScopeSymbolCompletionProvider\";\nexport { default as SymbolResolver } from \"./semantic/SymbolResolver\";\nexport * from \"./semantic/SymbolResolver\";\nexport * from \"./semantic/nodesWithScopes\";\nexport * from \"./semantic/resolvedNodes\";\nexport * from \"./semantic/unresolvedSymbolErrors\";\n"],
  "mappings": "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",
  "names": ["AssignmentNodeRole", "TokenType", "path", "mod", "secondParen", "inst", "SymbolKind", "t", "CompletionType", "path"]
}
