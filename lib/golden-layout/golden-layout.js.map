{
  "version": 3,
  "sources": ["../../node_modules/golden-layout/src/ts/errors/external-error.ts", "../../node_modules/golden-layout/src/ts/errors/internal-error.ts", "../../node_modules/golden-layout/src/ts/utils/i18n-strings.ts", "../../node_modules/golden-layout/src/ts/utils/style-constants.ts", "../../node_modules/golden-layout/src/ts/utils/types.ts", "../../node_modules/golden-layout/src/ts/utils/utils.ts", "../../node_modules/golden-layout/src/ts/utils/config-minifier.ts", "../../node_modules/golden-layout/src/ts/config/resolved-config.ts", "../../node_modules/golden-layout/src/ts/config/config.ts", "../../node_modules/golden-layout/src/ts/utils/event-emitter.ts", "../../node_modules/golden-layout/src/ts/container/component-container.ts", "../../node_modules/golden-layout/src/ts/controls/browser-popout.ts", "../../node_modules/golden-layout/src/ts/items/content-item.ts", "../../node_modules/golden-layout/src/ts/items/component-item.ts", "../../node_modules/golden-layout/src/ts/items/component-parentable-item.ts", "../../node_modules/golden-layout/src/ts/utils/drag-listener.ts", "../../node_modules/golden-layout/src/ts/controls/splitter.ts", "../../node_modules/golden-layout/src/ts/items/row-or-column.ts", "../../node_modules/golden-layout/src/ts/items/ground-item.ts", "../../node_modules/golden-layout/src/ts/controls/header-button.ts", "../../node_modules/golden-layout/src/ts/controls/tab.ts", "../../node_modules/golden-layout/src/ts/controls/tabs-container.ts", "../../node_modules/golden-layout/src/ts/controls/header.ts", "../../node_modules/golden-layout/src/ts/items/stack.ts", "../../node_modules/golden-layout/src/ts/controls/drag-proxy.ts", "../../node_modules/golden-layout/src/ts/controls/drag-source.ts", "../../node_modules/golden-layout/src/ts/controls/drop-target-indicator.ts", "../../node_modules/golden-layout/src/ts/controls/transition-indicator.ts", "../../node_modules/golden-layout/src/ts/utils/event-hub.ts", "../../node_modules/golden-layout/src/ts/layout-manager.ts", "../../node_modules/golden-layout/src/ts/virtual-layout.ts", "../../node_modules/golden-layout/src/ts/golden-layout.ts"],
  "sourcesContent": ["/** @public */\nexport abstract class ExternalError extends Error {\n    /** @internal */\n    constructor(public readonly type: string, message: string) {\n        super(message);\n    }\n}\n\n/** @public */\nexport class ConfigurationError extends ExternalError {\n    /** @internal */\n    constructor(message: string, public readonly node?: string) {\n        super('Configuration', message);\n    }\n}\n\n/** @public */\nexport class PopoutBlockedError extends ExternalError {\n    /** @internal */\n    constructor(message: string) {\n        super('PopoutBlocked', message);\n    }\n}\n\n/** @public */\nexport class ApiError extends ExternalError {\n    /** @internal */\n    constructor(message: string) {\n        super('API', message);\n    }\n}\n\n/** @public */\nexport class BindError extends ExternalError {\n    /** @internal */\n    constructor(message: string) {\n        super('Bind', message);\n    }\n}\n", "/** @internal */\nabstract class InternalError extends Error {\n    constructor(type: string, code: string, message?: string) {\n        super(`${type}: ${code}${message === undefined ? '' : ': ' + message}`)\n    }\n}\n\n/** @internal */\nexport class AssertError extends InternalError {\n    constructor(code: string, message?: string) {\n        super('Assert', code, message)\n    }\n}\n\n/** @internal */\nexport class UnreachableCaseError extends InternalError {\n    constructor(code: string, variableValue: never, message?: string) {\n        super('UnreachableCase', code, `${variableValue}${message === undefined ? '' : ': ' + message}`)\n    }\n}\n\n/** @internal */\nexport class UnexpectedNullError extends InternalError {\n    constructor(code: string, message?: string) {\n        super('UnexpectedNull', code, message)\n    }\n}\n\n/** @internal */\nexport class UnexpectedUndefinedError extends InternalError {\n    constructor(code: string, message?: string) {\n        super('UnexpectedUndefined', code, message)\n    }\n}\n", "import { AssertError } from '../errors/internal-error';\n\n/** @public */\nexport const enum I18nStringId {\n    PopoutCannotBeCreatedWithGroundItemConfig,\n    PleaseRegisterAConstructorFunction,\n    ComponentTypeNotRegisteredAndBindComponentEventHandlerNotAssigned,\n    ComponentIsAlreadyRegistered,\n    ComponentIsNotVirtuable,\n    VirtualComponentDoesNotHaveRootHtmlElement,\n    ItemConfigIsNotTypeComponent,\n    InvalidNumberPartInSizeString,\n    UnknownUnitInSizeString,\n    UnsupportedUnitInSizeString,\n}\n\n/** @public */\nexport namespace I18nStrings {\n    /** @internal */\n    let initialised = false;\n\n    /** @internal */\n    interface Info {\n        readonly id: I18nStringId;\n        readonly default: string;\n    }\n\n    /** @internal */\n    type InfosObject = { [id in keyof typeof I18nStringId]: Info };\n\n    /** @internal */\n    const infosObject: InfosObject = {\n        PopoutCannotBeCreatedWithGroundItemConfig: {\n            id: I18nStringId.PopoutCannotBeCreatedWithGroundItemConfig,\n            default: 'Popout cannot be created with ground ItemConfig'\n        },\n        PleaseRegisterAConstructorFunction: {\n            id: I18nStringId.PleaseRegisterAConstructorFunction,\n            default: 'Please register a constructor function'\n        },\n        ComponentTypeNotRegisteredAndBindComponentEventHandlerNotAssigned: {\n            id: I18nStringId.ComponentTypeNotRegisteredAndBindComponentEventHandlerNotAssigned,\n            default: 'Component type not registered and BindComponentEvent handler not assigned',\n        },\n        ComponentIsAlreadyRegistered: {\n            id: I18nStringId.ComponentIsAlreadyRegistered,\n            default: 'Component is already registered',\n        },\n        ComponentIsNotVirtuable: {\n            id: I18nStringId.ComponentIsNotVirtuable,\n            default: 'Component is not virtuable. Requires rootHtmlElement field/getter',\n        },\n        VirtualComponentDoesNotHaveRootHtmlElement: {\n            id: I18nStringId.VirtualComponentDoesNotHaveRootHtmlElement,\n            default: 'Virtual component does not have getter \"rootHtmlElement\"',\n        },\n        ItemConfigIsNotTypeComponent: {\n            id: I18nStringId.ItemConfigIsNotTypeComponent,\n            default: 'ItemConfig is not of type component',\n        },\n\n        InvalidNumberPartInSizeString: {\n            id: I18nStringId.InvalidNumberPartInSizeString,\n            default: 'Invalid number part in size string',\n        },\n        UnknownUnitInSizeString: {\n            id: I18nStringId.UnknownUnitInSizeString,\n            default: 'Unknown unit in size string',\n        },\n        UnsupportedUnitInSizeString: {\n            id: I18nStringId.UnsupportedUnitInSizeString,\n            default: 'Unsupported unit in size string',\n        },\n    }\n\n    export const idCount = Object.keys(infosObject).length;\n    /** @internal */\n    const infos = Object.values(infosObject);\n\n    export function checkInitialise(): void {\n        if (!initialised) {\n            for (let i = 0; i < idCount; i++) {\n                const info = infos[i];\n                if (info.id !== i) {\n                    throw new AssertError('INSI00110', `${i}: ${info.id}`);\n                } else {\n                    i18nStrings[i] = info.default;\n                }\n            }\n        }\n        initialised = true;\n    }\n}\n\n/** @public */\nexport const i18nStrings = new Array<string>(I18nStrings.idCount);\n", "/** @public */\nexport namespace StyleConstants {\n    export const defaultComponentBaseZIndex = 'auto';\n    export const defaultComponentDragZIndex = '32';\n    export const defaultComponentStackMaximisedZIndex = '41';\n}\n", "import { UnreachableCaseError } from '../errors/internal-error';\nimport { StyleConstants } from './style-constants';\n\n/** @internal */\nexport type WidthOrHeightPropertyName = 'width' | 'height';\n\n/** @internal */\nexport namespace WidthOrHeightPropertyName {\n    export const width = 'width';\n    export const height = 'height';\n}\n\n/** @internal */\nexport interface WidthAndHeight {\n    width: number;\n    height: number;\n}\n\n/** @internal */\nexport interface LeftAndTop {\n    left: number;\n    top: number;\n}\n\n/** @public */\nexport type Side = 'top' | 'left' | 'right' | 'bottom';\n/** @public */\nexport namespace Side {\n    export const top = 'top';\n    export const left = 'left';\n    export const right = 'right';\n    export const bottom = 'bottom';\n}\n\n/** @public */\nexport type LogicalZIndex = 'base' | 'drag' | 'stackMaximised';\n/** @public */\nexport namespace LogicalZIndex {\n    export const base = 'base';\n    export const drag = 'drag';\n    export const stackMaximised = 'stackMaximised';\n}\n\n/** @public */\nexport const LogicalZIndexToDefaultMap = {\n    base: StyleConstants.defaultComponentBaseZIndex,\n    drag: StyleConstants.defaultComponentDragZIndex,\n    stackMaximised: StyleConstants.defaultComponentStackMaximisedZIndex,\n}\n\n/** @internal */\nexport interface Rect {\n    left: number,\n    top: number,\n    width: number,\n    height: number,\n}\n\n/** @internal */\nexport interface AreaLinkedRect {\n    x1: number, // left\n    x2: number, // nextLeft\n    y1: number, // top\n    y2: number, // nextTop\n}\n\n/** @public */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type JsonValue = string | number | boolean | null | Json | object | JsonValueArray;\n/** @public */\nexport interface Json {\n    [name: string]: JsonValue;\n}\n/** @public */\nexport type JsonValueArray = Array<JsonValue>\n/** @public */\nexport namespace JsonValue {\n    export function isJson(value: JsonValue): value is Json {\n        return isJsonObject(value);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    export function isJsonObject(value: JsonValue): value is Json | object {\n        return !Array.isArray(value) && value !== null && typeof value === 'object';\n    }\n}\n\n/** @public */\nexport type ItemType = 'ground' | 'row' | 'column' | 'stack' | 'component';\n\n/** @public */\nexport namespace ItemType {\n    export const ground = 'ground';\n    export const row = 'row';\n    export const column = 'column';\n    export const stack = 'stack';\n    export const component = 'component';\n}\n\n/** @public */\nexport type ResponsiveMode = 'none' | 'always' | 'onload';\n/** @public */\nexport namespace ResponsiveMode {\n    export const none = 'none';\n    export const always = 'always';\n    export const onload = 'onload';\n}\n\n/**\n * Length units which can specify the size of a Component Item\n * @public\n */\nexport type SizeUnit = 'px' | '%' | 'fr' | 'em';\n\n/** @public */\nexport enum SizeUnitEnum {\n    Pixel = 'px',\n    Percent = '%',\n    Fractional = 'fr',\n    Em = 'em',\n}\n\n/** @public */\nexport namespace SizeUnitEnum {\n    export function tryParse(value: string) {\n        switch (value) {\n            case SizeUnitEnum.Pixel: return SizeUnitEnum.Pixel;\n            case SizeUnitEnum.Percent: return SizeUnitEnum.Percent;\n            case SizeUnitEnum.Fractional: return SizeUnitEnum.Fractional;\n            case SizeUnitEnum.Em: return SizeUnitEnum.Em;\n            default: return undefined;\n        }\n    }\n\n    export function format(value: SizeUnitEnum) {\n        switch (value) {\n            case SizeUnitEnum.Pixel: return SizeUnitEnum.Pixel;\n            case SizeUnitEnum.Percent: return SizeUnitEnum.Percent;\n            case SizeUnitEnum.Fractional: return SizeUnitEnum.Fractional;\n            case SizeUnitEnum.Em: return SizeUnitEnum.Em;\n            default:\n                throw new UnreachableCaseError('SUEF44998', value);\n        }\n    }\n}\n", "import { WidthAndHeight } from './types';\n\n/** @internal */\nexport function numberToPixels(value: number): string {\n    return value.toString(10) + 'px';\n}\n\n/** @internal */\nexport function pixelsToNumber(value: string): number {\n    const numberStr = value.replace(\"px\", \"\");\n    return parseFloat(numberStr);\n}\n\n/** @internal */\nexport interface SplitStringAtFirstNonNumericCharResult {\n    numericPart: string;\n    firstNonNumericCharPart: string;\n}\n\n/** @internal */\nexport function splitStringAtFirstNonNumericChar(value: string): SplitStringAtFirstNonNumericCharResult {\n    value = value.trimStart();\n\n    const length = value.length;\n    if (length === 0) {\n        return { numericPart: '', firstNonNumericCharPart: '' }\n    } else {\n        let firstNonDigitPartIndex = length;\n        let gotDecimalPoint = false;\n        for (let i = 0; i < length; i++) {\n            const char = value[i];\n            if (!isDigit(char)) {\n                if (char !== '.') {\n                    firstNonDigitPartIndex = i;\n                    break;\n                } else {\n                    if (gotDecimalPoint) {\n                        firstNonDigitPartIndex = i;\n                        break;\n                    } else {\n                        gotDecimalPoint = true;\n                    }\n                }\n            }\n        }\n        const digitsPart = value.substring(0, firstNonDigitPartIndex);\n        const firstNonDigitPart = value.substring(firstNonDigitPartIndex).trim();\n\n        return { numericPart: digitsPart, firstNonNumericCharPart: firstNonDigitPart };\n    }\n}\n\n/** @internal */\nexport function isDigit(char: string) {\n    return char >= '0' && char <= '9';\n}\n\n/** @internal */\nexport function getElementWidth(element: HTMLElement): number {\n    return element.offsetWidth;\n}\n\n/** @internal */\nexport function setElementWidth(element: HTMLElement, width: number): void {\n    const widthAsPixels = numberToPixels(width);\n    element.style.width = widthAsPixels;\n}\n\n/** @internal */\nexport function getElementHeight(element: HTMLElement): number {\n    return element.offsetHeight;\n}\n\n/** @internal */\nexport function setElementHeight(element: HTMLElement, height: number): void {\n    const heightAsPixels = numberToPixels(height);\n    element.style.height = heightAsPixels;\n}\n\n/** @internal */\nexport function getElementWidthAndHeight(element: HTMLElement): WidthAndHeight {\n    return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n    };\n}\n\n/** @internal */\nexport function setElementDisplayVisibility(element: HTMLElement, visible: boolean): void {\n    if (visible) {\n        element.style.display = '';\n    } else {\n        element.style.display = 'none';\n    }\n}\n\n/** @internal */\nexport function ensureElementPositionAbsolute(element: HTMLElement): void {\n    const absolutePosition = 'absolute';\n    if (element.style.position !== absolutePosition) {\n        element.style.position = absolutePosition;\n    }\n}\n\n/**\n * Replacement for JQuery $.extend(target, obj)\n * @internal\n*/\nexport function extend(target: Record<string, unknown>, obj: Record<string, unknown>): Record<string, unknown> {\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            target[key] = obj[key];\n        }\n    }\n    return target;\n}\n\n/**\n * Replacement for JQuery $.extend(true, target, obj)\n * @internal\n*/\nexport function deepExtend(target: Record<string, unknown>, obj: Record<string, unknown> | undefined): Record<string, unknown> {\n    if (obj !== undefined) {\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                const value = obj[key];\n                const existingTarget = target[key];\n                target[key] = deepExtendValue(existingTarget, value);\n            }\n        }\n    }\n\n    return target;\n}\n\n/** @internal */\nexport function deepExtendValue(existingTarget: unknown, value: unknown): unknown {\n    if (typeof value !== 'object') {\n        return value;\n    } else {\n        if (Array.isArray(value)) {\n            const length = value.length;\n            const targetArray = new Array<unknown>(length);\n            for (let i = 0; i < length; i++) {\n                const element = value[i];\n                targetArray[i] = deepExtendValue({}, element);\n            }\n            return targetArray;\n        } else {\n            if (value === null) {\n                return null;\n            } else {\n                const valueObj = value as Record<string, unknown>;\n                if (existingTarget === undefined) {\n                    return deepExtend({}, valueObj); // overwrite\n                } else {\n                    if (typeof existingTarget !== \"object\") {\n                        return deepExtend({}, valueObj); // overwrite\n                    } else {\n                        if (Array.isArray(existingTarget)) {\n                            return deepExtend({}, valueObj); // overwrite\n                        } else {\n                            if (existingTarget === null) {\n                                return deepExtend({}, valueObj); // overwrite\n                            } else {\n                                const existingTargetObj = existingTarget as Record<string, unknown>;\n                                return deepExtend(existingTargetObj, valueObj); // merge\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n/** @internal */\nexport function removeFromArray<T>(item: T, array: T[]): void {\n    const index = array.indexOf(item);\n\n    if (index === -1) {\n        throw new Error('Can\\'t remove item from array. Item is not in the array');\n    }\n\n    array.splice(index, 1);\n}\n\n/** @internal */\nexport function getUniqueId(): string {\n    return (Math.random() * 1000000000000000)\n        .toString(36)\n        .replace('.', '');\n}\n\n/** @internal */\nexport function getErrorMessage(e: unknown): string {\n    if (e instanceof Error) {\n        return e.message;\n    } else {\n        if (typeof e === 'string') {\n            return e;\n        } else {\n            return 'Unknown Error';\n        }\n    }\n}\n", "/**\n * Minifies and unminifies configs by replacing frequent keys\n * and values with one letter substitutes. Config options must\n * retain array position/index, add new options at the end.\n * @internal\n*/\n\nexport namespace ConfigMinifier {\n\n    export type YY = 'id' | 'title';\n    export const enum XX {\n        id = 'id'\n    }\n    const keys: readonly string[] = [\n        'settings',\n        'hasHeaders',\n        'constrainDragToContainer',\n        'selectionEnabled',\n        'dimensions',\n        'borderWidth',\n        'minItemHeight',\n        'minItemWidth',\n        'headerHeight',\n        'dragProxyWidth',\n        'dragProxyHeight',\n        'labels',\n        'close',\n        'maximise',\n        'minimise',\n        'popout',\n        'content',\n        'componentType',\n        'componentState',\n        'id',\n        'width',\n        'type',\n        'height',\n        'isClosable',\n        'title',\n        'popoutWholeStack',\n        'openPopouts',\n        'parentId',\n        'activeItemIndex',\n        'reorderEnabled',\n        'borderGrabWidth',\n\n\n\n\n        //Maximum 36 entries, do not cross this line!\n    ];\n\n    const values: readonly (boolean | string)[] = [\n        true,\n        false,\n        'row',\n        'column',\n        'stack',\n        'component',\n        'close',\n        'maximise',\n        'minimise',\n        'open in new window'\n    ];\n\n    export function checkInitialise(): void {\n        if (keys.length > 36) {\n            throw new Error('Too many keys in config minifier map');\n        }\n    }\n\n    export function translateObject(from: Record<string, unknown>, minify: boolean): Record<string, unknown> {\n        const to: Record<string, unknown> = {};\n        for (const key in from) {\n            if (from.hasOwnProperty(key)) { // In case something has extended Object prototypes\n                let translatedKey: string;\n                if (minify) {\n                    translatedKey = minifyKey(key);\n                } else {\n                    translatedKey = unminifyKey(key);\n                }\n\n                const fromValue = from[key];\n                to[translatedKey] = translateValue(fromValue, minify);\n            }\n        }\n\n        return to;\n    }\n\n    function translateArray(from: unknown[], minify: boolean) {\n        const length = from.length;\n        const to = new Array<unknown>(length);\n        for (let i = 0; i < length; i++) {\n            // In original code, array indices were numbers and not translated\n            const fromValue = from[i];\n            to[i] = translateValue(fromValue, minify);\n        }\n        return to;\n    }\n\n    function translateValue(from: unknown, minify: boolean) {\n        if (typeof from === 'object') {\n            if (from === null) {\n                return null;\n            } else {\n                if (Array.isArray(from)) {\n                    return translateArray(from, minify);\n                } else {\n                    return translateObject(from as Record<string, unknown>, minify);\n                }\n            }\n        } else {\n            if (minify) {\n                return minifyValue(from);\n            } else {\n                return unminifyValue(from);\n            }\n        }\n    }\n\n    function minifyKey(value: string) {\n        /**\n         * If a value actually is a single character, prefix it\n         * with ___ to avoid mistaking it for a minification code\n         */\n        if (typeof value === 'string' && value.length === 1) {\n            return '___' + value;\n        }\n    \n        const index = indexOfKey(value);\n    \n        /**\n         * value not found in the dictionary, return it unmodified\n         */\n        if (index === -1) {\n            return value;\n    \n            /**\n             * value found in dictionary, return its base36 counterpart\n             */\n        } else {\n            return index.toString(36);\n        }\n    }\n\n    function unminifyKey(key: string) {\n        /**\n         * value is a single character. Assume that it's a translation\n         * and return the original value from the dictionary\n         */\n        if (key.length === 1) {\n            return keys[parseInt(key, 36)];\n        }\n    \n        /**\n         * value originally was a single character and was prefixed with ___\n         * to avoid mistaking it for a translation. Remove the prefix\n         * and return the original character\n         */\n        if (key.substr(0, 3) === '___') {\n            return key[3];\n        }\n        /**\n         * value was not minified\n         */\n        return key;\n    }\n\n    function minifyValue(value: unknown) {\n        /**\n         * If a value actually is a single character, prefix it\n         * with ___ to avoid mistaking it for a minification code\n         */\n        if (typeof value === 'string' && value.length === 1) {\n            return '___' + value;\n        }\n    \n        const index = indexOfValue(value);\n    \n        /**\n         * value not found in the dictionary, return it unmodified\n         */\n        if (index === -1) {\n            return value;\n    \n            /**\n             * value found in dictionary, return its base36 counterpart\n             */\n        } else {\n            return index.toString(36);\n        }\n    }\n\n    function unminifyValue(value: unknown) {\n        /**\n         * value is a single character. Assume that it's a translation\n         * and return the original value from the dictionary\n         */\n        if (typeof value === 'string' && value.length === 1) {\n            return values[parseInt(value, 36)];\n        }\n\n        /**\n         * value originally was a single character and was prefixed with ___\n         * to avoid mistaking it for a translation. Remove the prefix\n         * and return the original character\n         */\n        if (typeof value === 'string' && value.substr(0, 3) === '___') {\n            return value[3];\n        }\n        /**\n         * value was not minified\n         */\n        return value;\n    }\n\n    function indexOfKey(key: string) {\n        for (let i = 0; i < keys.length; i++) {\n            if (keys[i] === key) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    function indexOfValue(value: unknown) {\n        for (let i = 0; i < values.length; i++) {\n            if (values[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n", "import { AssertError, UnreachableCaseError } from '../errors/internal-error';\nimport { ConfigMinifier } from '../utils/config-minifier';\nimport { ItemType, JsonValue, ResponsiveMode, Side, SizeUnitEnum } from '../utils/types';\nimport { deepExtendValue } from '../utils/utils';\n\n/** @public */\nexport interface ResolvedItemConfig {\n    // see ItemConfig for comments\n    readonly type: ItemType;\n    readonly content: readonly ResolvedItemConfig[];\n    readonly size: number;\n    readonly sizeUnit: SizeUnitEnum;\n    readonly minSize: number | undefined;\n    readonly minSizeUnit: SizeUnitEnum;\n    // id no longer specifies whether an Item is maximised.  This is now done by HeaderItemConfig.maximised\n    readonly id: string;\n    readonly isClosable: boolean;\n}\n\n/** @public */\nexport namespace ResolvedItemConfig {\n    export const defaults: ResolvedItemConfig = {\n        type: ItemType.ground, // not really default but need something\n        content: [],\n        size: 1,\n        sizeUnit: SizeUnitEnum.Fractional,\n        minSize: undefined,\n        minSizeUnit: SizeUnitEnum.Pixel,\n        id: '',\n        isClosable: true,\n    } as const;\n\n    /** Creates a copy of the original ResolvedItemConfig using an alternative content if specified */\n    export function createCopy(original: ResolvedItemConfig, content?: ResolvedItemConfig[]): ResolvedItemConfig {\n        switch (original.type) {\n            case ItemType.ground:\n            case ItemType.row:\n            case ItemType.column:\n                return ResolvedRowOrColumnItemConfig.createCopy(original as ResolvedRowOrColumnItemConfig,\n                    content as ResolvedRowOrColumnItemConfig.ChildItemConfig[]);\n\n            case ItemType.stack:\n                return ResolvedStackItemConfig.createCopy(original as ResolvedStackItemConfig, content as ResolvedComponentItemConfig[]);\n\n            case ItemType.component:\n                return ResolvedComponentItemConfig.createCopy(original as ResolvedComponentItemConfig);\n\n            default:\n                throw new UnreachableCaseError('CICC91354', original.type, 'Invalid Config Item type specified');\n        }\n    }\n\n    export function createDefault(type: ItemType): ResolvedItemConfig {\n        switch (type) {\n            case ItemType.ground:\n                throw new AssertError('CICCDR91562'); // Get default root from LayoutConfig\n            case ItemType.row:\n            case ItemType.column:\n                return ResolvedRowOrColumnItemConfig.createDefault(type);\n\n            case ItemType.stack:\n                return ResolvedStackItemConfig.createDefault();\n\n            case ItemType.component:\n                return ResolvedComponentItemConfig.createDefault();\n\n            default:\n                throw new UnreachableCaseError('CICCDD91563', type, 'Invalid Config Item type specified');\n        }\n    }\n\n    export function isComponentItem(itemConfig: ResolvedItemConfig): itemConfig is ResolvedComponentItemConfig {\n        return itemConfig.type === ItemType.component;\n    }\n\n    export function isStackItem(itemConfig: ResolvedItemConfig): itemConfig is ResolvedStackItemConfig {\n        return itemConfig.type === ItemType.stack;\n    }\n\n    /** @internal */\n    export function isGroundItem(itemConfig: ResolvedItemConfig): itemConfig is ResolvedGroundItemConfig {\n        return itemConfig.type === ItemType.ground;\n    }\n}\n\n// Stack or Component\n/** @public */\nexport interface ResolvedHeaderedItemConfig extends ResolvedItemConfig {\n    header: ResolvedHeaderedItemConfig.Header | undefined; // undefined means get header settings from LayoutConfig\n    readonly maximised: boolean;\n}\n\n/** @public */\nexport namespace ResolvedHeaderedItemConfig {\n    export const defaultMaximised = false;\n\n    export interface Header {\n        // undefined means get property value from LayoutConfig\n        readonly show: false | Side | undefined;\n        readonly popout: false | string | undefined;\n        readonly maximise: false | string | undefined;\n        readonly close: string | undefined;\n        readonly minimise: string | undefined;\n        readonly tabDropdown: false | string | undefined;\n    }\n\n    export namespace Header {\n        export function createCopy(original: Header | undefined, show?: false | Side): Header | undefined {\n            if (original === undefined) {\n                return undefined;\n            } else {\n                return {\n                    show: show ?? original.show,\n                    popout: original.popout,\n                    close: original.close,\n                    maximise: original.maximise,\n                    minimise: original.minimise,\n                    tabDropdown: original.tabDropdown,\n                }\n            }\n        }\n    }\n}\n\n/** @public */\nexport interface ResolvedStackItemConfig extends ResolvedHeaderedItemConfig {\n    readonly type: 'stack';\n    readonly content: ResolvedComponentItemConfig[];\n    /** The index of the active item in the Stack.  Only undefined if the Stack is empty. */\n    readonly activeItemIndex: number | undefined;\n}\n\n/** @public */\nexport namespace ResolvedStackItemConfig {\n    export const defaultActiveItemIndex = 0;\n\n    export function createCopy(original: ResolvedStackItemConfig, content?: ResolvedComponentItemConfig[]): ResolvedStackItemConfig {\n        const result: ResolvedStackItemConfig = {\n            type: original.type,\n            content: content !== undefined ? copyContent(content) : copyContent(original.content),\n            size: original.size,\n            sizeUnit: original.sizeUnit,\n            minSize: original.minSize,\n            minSizeUnit: original.minSizeUnit,\n            id: original.id,\n            maximised: original.maximised,\n            isClosable: original.isClosable,\n            activeItemIndex: original.activeItemIndex,\n            header: ResolvedHeaderedItemConfig.Header.createCopy(original.header),\n        }\n        return result;\n    }\n\n    export function copyContent(original: ResolvedComponentItemConfig[]): ResolvedComponentItemConfig[] {\n        const count = original.length;\n        const result = new Array<ResolvedComponentItemConfig>(count);\n        for (let i = 0; i < count; i++) {\n            result[i] = ResolvedItemConfig.createCopy(original[i]) as ResolvedComponentItemConfig;\n        }\n        return result;\n    }\n\n    export function createDefault(): ResolvedStackItemConfig {\n        const result: ResolvedStackItemConfig = {\n            type: ItemType.stack,\n            content: [],\n            size: ResolvedItemConfig.defaults.size,\n            sizeUnit: ResolvedItemConfig.defaults.sizeUnit,\n            minSize: ResolvedItemConfig.defaults.minSize,\n            minSizeUnit: ResolvedItemConfig.defaults.minSizeUnit,\n            id: ResolvedItemConfig.defaults.id,\n            maximised: ResolvedHeaderedItemConfig.defaultMaximised,\n            isClosable: ResolvedItemConfig.defaults.isClosable,\n            activeItemIndex: defaultActiveItemIndex,\n            header: undefined,\n        }\n        return result;\n    }\n}\n\n/** @public */\nexport interface ResolvedComponentItemConfig extends ResolvedHeaderedItemConfig {\n    // see ComponentItemConfig for comments\n    readonly type: 'component';\n    readonly content: [];\n    readonly title: string;\n    readonly reorderEnabled: boolean; // Takes precedence over LayoutConfig.reorderEnabled.\n    /**\n     * The name of the component as specified in layout.registerComponent. Mandatory if type is 'component'.\n     */\n    readonly componentType: JsonValue;\n    readonly componentState?: JsonValue;\n}\n\n/** @public */\nexport namespace ResolvedComponentItemConfig {\n    export const defaultReorderEnabled = true;\n\n    export function resolveComponentTypeName(itemConfig: ResolvedComponentItemConfig): string | undefined {\n        const componentType = itemConfig.componentType;\n        if (typeof componentType === 'string') {\n            return componentType;\n        } else {\n            return undefined;\n        }\n    }\n\n    export function createCopy(original: ResolvedComponentItemConfig): ResolvedComponentItemConfig {\n        const result: ResolvedComponentItemConfig = {\n            type: original.type,\n            content: [],\n            size: original.size,\n            sizeUnit: original.sizeUnit,\n            minSize: original.minSize,\n            minSizeUnit: original.minSizeUnit,\n            id: original.id,\n            maximised: original.maximised,\n            isClosable: original.isClosable,\n            reorderEnabled: original.reorderEnabled,\n            title: original.title,\n            header: ResolvedHeaderedItemConfig.Header.createCopy(original.header),\n            componentType: original.componentType,\n            componentState: deepExtendValue(undefined, original.componentState) as JsonValue,\n        }\n        return result;\n    }\n\n    export function createDefault(componentType: JsonValue = '', componentState?: JsonValue, title = ''): ResolvedComponentItemConfig {\n        const result: ResolvedComponentItemConfig = {\n            type: ItemType.component,\n            content: [],\n            size: ResolvedItemConfig.defaults.size,\n            sizeUnit: ResolvedItemConfig.defaults.sizeUnit,\n            minSize: ResolvedItemConfig.defaults.minSize,\n            minSizeUnit: ResolvedItemConfig.defaults.minSizeUnit,\n            id: ResolvedItemConfig.defaults.id,\n            maximised: ResolvedHeaderedItemConfig.defaultMaximised,\n            isClosable: ResolvedItemConfig.defaults.isClosable,\n            reorderEnabled: ResolvedComponentItemConfig.defaultReorderEnabled,\n            title,\n            header: undefined,\n            componentType,\n            componentState,\n        }\n        return result;\n    }\n\n    export function copyComponentType(componentType: JsonValue): JsonValue {\n        return deepExtendValue({}, componentType) as JsonValue\n    }\n}\n\n/** Base for Root or RowOrColumn ItemConfigs\n * @public\n */\nexport interface ResolvedRowOrColumnItemConfig extends ResolvedItemConfig {\n    readonly type: 'row' | 'column';\n    /** Note that RowOrColumn ResolvedItemConfig contents, can contain ComponentItem itemConfigs.  However\n     * when ContentItems are created, these ComponentItem itemConfigs will create a Stack with a child ComponentItem.\n     */\n    readonly content: readonly (ResolvedRowOrColumnItemConfig | ResolvedStackItemConfig | ResolvedComponentItemConfig)[];\n}\n\n/** @public */\nexport namespace ResolvedRowOrColumnItemConfig {\n    export type ChildItemConfig = ResolvedRowOrColumnItemConfig | ResolvedStackItemConfig | ResolvedComponentItemConfig;\n\n    export function isChildItemConfig(itemConfig: ResolvedItemConfig): itemConfig is ChildItemConfig {\n        switch (itemConfig.type) {\n            case ItemType.row:\n            case ItemType.column:\n            case ItemType.stack:\n            case ItemType.component:\n                return true;\n            case ItemType.ground:\n                return false;\n            default:\n                throw new UnreachableCaseError('CROCOSPCICIC13687', itemConfig.type);\n        }\n    }\n\n    export function createCopy(original: ResolvedRowOrColumnItemConfig, content?: ChildItemConfig[]): ResolvedRowOrColumnItemConfig {\n        const result: ResolvedRowOrColumnItemConfig = {\n            type: original.type,\n            content: content !== undefined ? copyContent(content) : copyContent(original.content),\n            size: original.size,\n            sizeUnit: original.sizeUnit,\n            minSize: original.minSize,\n            minSizeUnit: original.minSizeUnit,\n            id: original.id,\n            isClosable: original.isClosable,\n        }\n        return result;\n    }\n\n    export function copyContent(original: readonly ChildItemConfig[]): ChildItemConfig[] {\n        const count = original.length;\n        const result = new Array<ChildItemConfig>(count);\n        for (let i = 0; i < count; i++) {\n            result[i] = ResolvedItemConfig.createCopy(original[i]) as ChildItemConfig;\n        }\n        return result;\n    }\n\n    export function createDefault(type: 'row' | 'column'): ResolvedRowOrColumnItemConfig {\n        const result: ResolvedRowOrColumnItemConfig = {\n            type,\n            content: [],\n            size: ResolvedItemConfig.defaults.size,\n            sizeUnit: ResolvedItemConfig.defaults.sizeUnit,\n            minSize: ResolvedItemConfig.defaults.minSize,\n            minSizeUnit: ResolvedItemConfig.defaults.minSizeUnit,\n            id: ResolvedItemConfig.defaults.id,\n            isClosable: ResolvedItemConfig.defaults.isClosable,\n        }\n        return result;\n    }\n}\n\n/**\n * RootItemConfig is the topmost ResolvedItemConfig specified by the user.\n * Note that it does not have a corresponding contentItem.  It specifies the one and only child of the Ground ContentItem\n * Note that RootItemConfig can be an ComponentItem itemConfig.  However when the Ground ContentItem's child is created\n * a ComponentItem itemConfig will create a Stack with a child ComponentItem.\n * @public\n*/\nexport type ResolvedRootItemConfig = ResolvedRowOrColumnItemConfig | ResolvedStackItemConfig | ResolvedComponentItemConfig;\n\n/** @public */\nexport namespace ResolvedRootItemConfig {\n    export function createCopy(config: ResolvedRootItemConfig): ResolvedRootItemConfig {\n        return ResolvedItemConfig.createCopy(config) as ResolvedRootItemConfig;\n    }\n\n    export function isRootItemConfig(itemConfig: ResolvedItemConfig): itemConfig is ResolvedRootItemConfig {\n        switch (itemConfig.type) {\n            case ItemType.row:\n            case ItemType.column:\n            case ItemType.stack:\n            case ItemType.component:\n                return true;\n            case ItemType.ground:\n                return false;\n            default:\n                throw new UnreachableCaseError('CROCOSPCICIC13687', itemConfig.type);\n        }\n    }\n}\n\n/** @internal */\nexport interface ResolvedGroundItemConfig extends ResolvedItemConfig {\n    readonly type: 'ground';\n    readonly size: 100,\n    readonly sizeUnit: SizeUnitEnum.Percent,\n    readonly minSize: 0,\n    readonly minSizeUnit: SizeUnitEnum.Pixel,\n    readonly id: '',\n    readonly isClosable: false,\n    readonly title: '',\n    readonly reorderEnabled: false,\n}\n\n/** @internal */\nexport namespace ResolvedGroundItemConfig {\n    export function create(rootItemConfig: ResolvedRootItemConfig | undefined):ResolvedGroundItemConfig {\n        const content = rootItemConfig === undefined ? [] : [rootItemConfig];\n        return {\n            type: ItemType.ground,\n            content,\n            size: 100,\n            sizeUnit: SizeUnitEnum.Percent,\n            minSize: 0,\n            minSizeUnit: SizeUnitEnum.Pixel,\n            id: '',\n            isClosable: false,\n            title: '',\n            reorderEnabled: false,\n        }\n    }\n}\n\n/** @public */\nexport interface ResolvedLayoutConfig {\n    readonly root: ResolvedRootItemConfig | undefined;\n    readonly openPopouts: ResolvedPopoutLayoutConfig[];\n    readonly dimensions: ResolvedLayoutConfig.Dimensions;\n    readonly settings: ResolvedLayoutConfig.Settings;\n    readonly header: ResolvedLayoutConfig.Header;\n    readonly resolved: true,\n}\n\n/** @public */\nexport namespace ResolvedLayoutConfig {\n    export interface Settings {\n        // see Config.Settings for comments\n        readonly constrainDragToContainer: boolean;\n        readonly reorderEnabled: boolean; // also in ResolvedItemConfig which takes precedence\n        readonly popoutWholeStack: boolean;\n        readonly blockedPopoutsThrowError: boolean;\n        /** @deprecated Will be removed in version 3. */\n        readonly closePopoutsOnUnload: boolean;\n        readonly responsiveMode: ResponsiveMode;\n        readonly tabOverlapAllowance: number;\n        readonly reorderOnTabMenuClick: boolean;\n        readonly tabControlOffset: number;\n        readonly popInOnClose: boolean;\n    }\n\n    export namespace Settings {\n        export const defaults: ResolvedLayoutConfig.Settings = {\n            constrainDragToContainer: true,\n            reorderEnabled: true,\n            popoutWholeStack: false,\n            blockedPopoutsThrowError: true,\n            closePopoutsOnUnload: true,\n            responsiveMode: ResponsiveMode.none, // was onload\n            tabOverlapAllowance: 0,\n            reorderOnTabMenuClick: true,\n            tabControlOffset: 10,\n            popInOnClose: false,\n        } as const;\n\n        export function createCopy(original: Settings): Settings {\n            return {\n                constrainDragToContainer: original.constrainDragToContainer,\n                reorderEnabled: original.reorderEnabled,\n                popoutWholeStack: original.popoutWholeStack,\n                blockedPopoutsThrowError: original.blockedPopoutsThrowError,\n                closePopoutsOnUnload: original.closePopoutsOnUnload,\n                responsiveMode: original.responsiveMode,\n                tabOverlapAllowance: original.tabOverlapAllowance,\n                reorderOnTabMenuClick: original.reorderOnTabMenuClick,\n                tabControlOffset: original.tabControlOffset,\n                popInOnClose: original.popInOnClose,\n            }\n        }\n    }\n\n    export interface Dimensions {\n        // see LayoutConfig.Dimensions for comments\n        readonly borderWidth: number;\n        readonly borderGrabWidth: number,\n        readonly defaultMinItemHeight: number;\n        readonly defaultMinItemHeightUnit: SizeUnitEnum;\n        readonly defaultMinItemWidth: number;\n        readonly defaultMinItemWidthUnit: SizeUnitEnum;\n        readonly headerHeight: number;\n        readonly dragProxyWidth: number;\n        readonly dragProxyHeight: number;\n    }\n\n    export namespace Dimensions {\n        export function createCopy(original: Dimensions): Dimensions {\n            return {\n                borderWidth: original.borderWidth,\n                borderGrabWidth: original.borderGrabWidth,\n                defaultMinItemHeight: original.defaultMinItemHeight,\n                defaultMinItemHeightUnit: original.defaultMinItemHeightUnit,\n                defaultMinItemWidth: original.defaultMinItemWidth,\n                defaultMinItemWidthUnit: original.defaultMinItemWidthUnit,\n                headerHeight: original.headerHeight,\n                dragProxyWidth: original.dragProxyWidth,\n                dragProxyHeight: original.dragProxyHeight,\n            }\n        }\n\n        export const defaults: ResolvedLayoutConfig.Dimensions = {\n            borderWidth: 5,\n            borderGrabWidth: 5,\n            defaultMinItemHeight: 0,\n            defaultMinItemHeightUnit: SizeUnitEnum.Pixel,\n            defaultMinItemWidth: 10,\n            defaultMinItemWidthUnit: SizeUnitEnum.Pixel,\n            headerHeight: 20,\n            dragProxyWidth: 300,\n            dragProxyHeight: 200\n        } as const;\n    }\n\n    export interface Header {\n        readonly show: false | Side;\n        readonly popout: false | string;\n        readonly dock: string;\n        readonly maximise: false | string;\n        readonly minimise: string;\n        readonly close: false | string;\n        readonly tabDropdown: false | string;\n    }\n\n    export namespace Header {\n        export function createCopy(original: Header): Header {\n            return {\n                show: original.show,\n                popout: original.popout,\n                dock: original.dock,\n                close: original.close,\n                maximise: original.maximise,\n                minimise: original.minimise,\n                tabDropdown: original.tabDropdown,\n            }\n        }\n\n        export const defaults: ResolvedLayoutConfig.Header = {\n            show: Side.top,\n            popout: 'open in new window',\n            dock: 'dock',\n            maximise: 'maximise',\n            minimise: 'minimise',\n            close: 'close',\n            tabDropdown: 'additional tabs'\n        } as const;\n    }\n\n    export function isPopout(config: ResolvedLayoutConfig): config is ResolvedPopoutLayoutConfig {\n        return 'parentId' in config;\n    }\n\n    export function createDefault(): ResolvedLayoutConfig {\n        const result: ResolvedLayoutConfig = {\n            root: undefined,\n            openPopouts: [],\n            dimensions: ResolvedLayoutConfig.Dimensions.defaults,\n            settings: ResolvedLayoutConfig.Settings.defaults,\n            header: ResolvedLayoutConfig.Header.defaults,\n            resolved: true,\n        }\n        return result;\n    }\n\n    export function createCopy(config: ResolvedLayoutConfig): ResolvedLayoutConfig {\n        if (isPopout(config)) {\n            return ResolvedPopoutLayoutConfig.createCopy(config);\n        } else {\n            const result: ResolvedLayoutConfig = {\n                root: config.root === undefined ? undefined : ResolvedRootItemConfig.createCopy(config.root),\n                openPopouts: ResolvedLayoutConfig.copyOpenPopouts(config.openPopouts),\n                settings: ResolvedLayoutConfig.Settings.createCopy(config.settings),\n                dimensions: ResolvedLayoutConfig.Dimensions.createCopy(config.dimensions),\n                header: ResolvedLayoutConfig.Header.createCopy(config.header),\n                resolved: config.resolved,\n            }\n            return result;\n        }\n    }\n\n    export function copyOpenPopouts(original: ResolvedPopoutLayoutConfig[]): ResolvedPopoutLayoutConfig[] {\n        const count = original.length;\n        const result = new Array<ResolvedPopoutLayoutConfig>(count);\n        for (let i = 0; i < count; i++) {\n            result[i] = ResolvedPopoutLayoutConfig.createCopy(original[i]);\n        }\n        return result;\n    }\n\n    /**\n     * Takes a GoldenLayout configuration object and\n     * replaces its keys and values recursively with\n     * one letter counterparts\n     */\n    export function minifyConfig(layoutConfig: ResolvedLayoutConfig): ResolvedLayoutConfig {\n        return ConfigMinifier.translateObject(layoutConfig, true) as ResolvedLayoutConfig;\n    }\n\n    /**\n     * Takes a configuration Object that was previously minified\n     * using minifyConfig and returns its original version\n     */\n    export function unminifyConfig(minifiedConfig: ResolvedLayoutConfig): ResolvedLayoutConfig {\n        return ConfigMinifier.translateObject(minifiedConfig, false) as ResolvedLayoutConfig;\n    }\n}\n\n/** @public */\nexport interface ResolvedPopoutLayoutConfig extends ResolvedLayoutConfig {\n    readonly parentId: string | null;\n    readonly indexInParent: number | null;\n    readonly window: ResolvedPopoutLayoutConfig.Window;\n}\n\n/** @public */\nexport namespace ResolvedPopoutLayoutConfig {\n    export interface Window {\n        readonly width: number | null,\n        readonly height: number | null,\n        readonly left: number | null,\n        readonly top: number | null,\n    }\n\n    export namespace Window {\n        export function createCopy(original: Window): Window {\n            return {\n                width: original.width,\n                height: original.height,\n                left: original.left,\n                top: original.top,\n            }\n        }\n\n        export const defaults: ResolvedPopoutLayoutConfig.Window = {\n            width: null,\n            height: null,\n            left: null,\n            top: null,\n        } as const;\n    }\n\n    export function createCopy(original: ResolvedPopoutLayoutConfig): ResolvedPopoutLayoutConfig {\n        const result: ResolvedPopoutLayoutConfig = {\n            root: original.root === undefined ? undefined : ResolvedRootItemConfig.createCopy(original.root),\n            openPopouts: ResolvedLayoutConfig.copyOpenPopouts(original.openPopouts),\n            settings: ResolvedLayoutConfig.Settings.createCopy(original.settings),\n            dimensions: ResolvedLayoutConfig.Dimensions.createCopy(original.dimensions),\n            header: ResolvedLayoutConfig.Header.createCopy(original.header),\n            parentId: original.parentId,\n            indexInParent: original.indexInParent,\n            window: ResolvedPopoutLayoutConfig.Window.createCopy(original.window),\n            resolved: original.resolved,\n        }\n        return result;\n    }\n}\n", "import { ConfigurationError } from '../errors/external-error';\nimport { AssertError, UnexpectedUndefinedError, UnreachableCaseError } from '../errors/internal-error';\nimport { I18nStringId, i18nStrings } from '../utils/i18n-strings';\nimport { ItemType, JsonValue, ResponsiveMode, Side, SizeUnitEnum } from '../utils/types';\nimport { deepExtendValue, splitStringAtFirstNonNumericChar } from '../utils/utils';\nimport {\n    ResolvedComponentItemConfig,\n    ResolvedHeaderedItemConfig,\n    ResolvedItemConfig,\n    ResolvedLayoutConfig,\n    ResolvedPopoutLayoutConfig,\n    ResolvedRootItemConfig,\n    ResolvedRowOrColumnItemConfig,\n    ResolvedStackItemConfig\n} from \"./resolved-config\";\n\n/** @public */\nexport interface ItemConfig {\n    /**\n     * The type of the item. Possible values are 'row', 'column', 'stack', 'component'.\n     */\n    type: ItemType;\n\n    /**\n     * An array of configurations for items that will be created as children of this item.\n     */\n    content?: ItemConfig[];\n\n    /**\n     * The width of this item, relative to the other children of its parent in percent\n     * @deprecated use {@link (ItemConfig:interface).size} instead\n     */\n    width?: number;\n\n    /**\n     * The minimum width of this item in pixels\n     * CAUTION - Not tested - do not use\n     * @deprecated use {@link (ItemConfig:interface).minSize} instead\n     */\n    minWidth?: number;\n\n    /**\n     * The height of this item, relative to the other children of its parent in percent\n     * @deprecated use {@link (ItemConfig:interface).size} instead\n     */\n    height?: number;\n\n    /**\n     * The minimum height of this item in pixels\n     * CAUTION - Not tested - do not use\n     * @deprecated use {@link (ItemConfig:interface).minSize} instead\n     */\n    minHeight?: number;\n\n    /**\n     * The size of this item.\n     * For rows, it specifies height. For columns, it specifies width.\n     * Has format \\<number\\>\\<{@link SizeUnit}\\>. Currently only supports units `fr` and `%`.\n     *\n     * Space is first proportionally allocated to items with sizeUnit `%`.\n     * If there is any space left over (less than 100% allocated), then the\n     * remainder is allocated to the items with unit `fr` according to the fractional size.\n     * If more than 100% is allocated, then an extra 50% is allocated to items with unit `fr` and\n     * is allocated to each item according to its fractional size. All item sizes are then adjusted\n     * to bring the total back to 100%\n     */\n    size?: string;\n\n    /**\n     * The size of this item.\n     * For rows, it specifies height. For columns, it specifies width.\n     * Has format <number><sizeUnit>. Currently only supports units `px`\n     */\n    minSize?: string;\n\n    /**\n     * A string that can be used to identify a ContentItem.\n     * Do NOT assign an array.  This only exists for legacy purposes.  If an array is assigned, the first element\n     * will become the id.\n     */\n    id?: string;\n\n    /**\n     * Determines if the item is closable. If false, the x on the items tab will be hidden and container.close()\n     * will return false\n     * Default: true\n     */\n    isClosable?: boolean;\n\n    /**\n     * The title of the item as displayed on its tab and on popout windows\n     * Default: componentType.toString() or ''\n     * @deprecated only Component has a title\n     */\n    title?: string;\n}\n\n/** @public */\nexport namespace ItemConfig {\n    /** @internal */\n    export const enum SizeWidthHeightSpecificationType {\n        None,\n        Size,\n        WidthOrHeight,\n    }\n\n    /** @internal */\n    export function resolve(itemConfig: ItemConfig, rowAndColumnChildLegacySizeDefault: boolean): ResolvedItemConfig {\n        switch (itemConfig.type) {\n            case ItemType.ground:\n                throw new ConfigurationError('ItemConfig cannot specify type ground', JSON.stringify(itemConfig));\n            case ItemType.row:\n            case ItemType.column:\n                return RowOrColumnItemConfig.resolve(itemConfig as RowOrColumnItemConfig, rowAndColumnChildLegacySizeDefault);\n\n            case ItemType.stack:\n                return StackItemConfig.resolve(itemConfig as StackItemConfig, rowAndColumnChildLegacySizeDefault);\n\n            case ItemType.component:\n                return ComponentItemConfig.resolve(itemConfig as ComponentItemConfig, rowAndColumnChildLegacySizeDefault);\n\n            default:\n                throw new UnreachableCaseError('UCUICR55499', itemConfig.type);\n        }\n    }\n\n    /** @internal */\n    export function resolveContent(content: ItemConfig[] | undefined): ResolvedItemConfig[] {\n        if (content === undefined) {\n            return [];\n        } else {\n            const count = content.length;\n            const result = new Array<ResolvedItemConfig>(count);\n            for (let i = 0; i < count; i++) {\n                result[i] = ItemConfig.resolve(content[i], false);\n            }\n            return result;\n        }\n    }\n\n    /** @internal */\n    export function resolveId(id: string | string[] | undefined): string {\n        if (id === undefined) {\n            return ResolvedItemConfig.defaults.id;\n        } else {\n            if (Array.isArray(id)) {\n                if (id.length === 0) {\n                    return ResolvedItemConfig.defaults.id;\n                } else {\n                    return id[0];\n                }\n            } else {\n                return id;\n            }\n        }\n    }\n\n    /** @internal */\n    export function resolveSize(\n        size: string | undefined,\n        width: number | undefined,\n        height: number | undefined,\n        rowAndColumnChildLegacySizeDefault: boolean):\n    SizeWithUnit {\n        // Remove support for rowAndColumnChildLegacySizeDefault in a major version release\n\n        if (size !== undefined) {\n            return parseSize(size, [SizeUnitEnum.Percent, SizeUnitEnum.Fractional]);\n        } else {\n            if (width !== undefined || height !== undefined) {\n                if (width !== undefined) {\n                    return { size: width, sizeUnit: SizeUnitEnum.Percent };\n                } else {\n                    if (height !== undefined) {\n                        return { size: height, sizeUnit: SizeUnitEnum.Percent };\n                    } else {\n                        throw new UnexpectedUndefinedError('CRS33390');\n                    }\n                }\n            } else {\n                if (rowAndColumnChildLegacySizeDefault) {\n                    return { size: 50, sizeUnit: SizeUnitEnum.Percent };\n                } else {\n                    return { size: ResolvedItemConfig.defaults.size, sizeUnit: ResolvedItemConfig.defaults.sizeUnit };\n                }\n            }\n        }\n    }\n\n    /** @internal */\n    export function resolveMinSize(minSize: string | undefined, minWidth: number | undefined, minHeight: number | undefined): UndefinableSizeWithUnit {\n        if (minSize !== undefined) {\n            return parseSize(minSize, [SizeUnitEnum.Pixel]);\n        } else {\n            const minWidthDefined = minWidth !== undefined;\n            const minHeightDefined = minHeight !== undefined;\n            if (minWidthDefined || minHeightDefined) {\n                if (minWidthDefined) {\n                    return { size: minWidth, sizeUnit: SizeUnitEnum.Pixel };\n                } else {\n                    return { size: minHeight, sizeUnit: SizeUnitEnum.Pixel };\n                }\n            } else {\n                return { size: ResolvedItemConfig.defaults.minSize, sizeUnit: ResolvedItemConfig.defaults.minSizeUnit };\n            }\n        }\n    }\n\n    /** @internal */\n    export function calculateSizeWidthHeightSpecificationType(config: ItemConfig): SizeWidthHeightSpecificationType {\n        if (config.size !== undefined) {\n            return SizeWidthHeightSpecificationType.Size;\n        } else {\n            if (config.width !== undefined || config.height !== undefined) {\n                return SizeWidthHeightSpecificationType.WidthOrHeight;\n            } else {\n                return SizeWidthHeightSpecificationType.None;\n            }\n        }\n    }\n\n    export function isGround(config: ItemConfig): config is ItemConfig {\n        return config.type === ItemType.ground;\n    }\n    export function isRow(config: ItemConfig): config is ItemConfig {\n        return config.type === ItemType.row;\n    }\n    export function isColumn(config: ItemConfig): config is ItemConfig {\n        return config.type === ItemType.column;\n    }\n    export function isStack(config: ItemConfig): config is ItemConfig {\n        return config.type === ItemType.stack;\n    }\n    export function isComponent(config: ItemConfig): config is ComponentItemConfig {\n        return config.type === ItemType.component;\n    }\n}\n\n// Stack or Component\n/** @public */\nexport interface HeaderedItemConfig extends ItemConfig {\n    /** @deprecated use {@link (HeaderedItemConfig:namespace).(Header:interface).show} instead */\n    hasHeaders?: boolean;\n    header?: HeaderedItemConfig.Header;\n    maximised?: boolean;\n}\n\n/** @public */\nexport namespace HeaderedItemConfig {\n    const legacyMaximisedId = '__glMaximised';\n\n    export interface Header {\n        show?: false | Side;\n        popout?: false | string;\n        dock?: false | string;\n        maximise?: false | string;\n        close?: string;\n        minimise?: string;\n        tabDropdown?: false | string;\n    }\n\n    export namespace Header {\n        export function resolve(header: Header | undefined, hasHeaders: boolean | undefined): ResolvedHeaderedItemConfig.Header | undefined {\n            if (header === undefined && hasHeaders === undefined) {\n                return undefined;\n            } else {\n                const result: ResolvedHeaderedItemConfig.Header = {\n                    show: header?.show ?? (hasHeaders === undefined ? undefined : hasHeaders ? ResolvedLayoutConfig.Header.defaults.show : false),\n                    popout: header?.popout,\n                    maximise: header?.maximise,\n                    close: header?.close,\n                    minimise: header?.minimise,\n                    tabDropdown: header?.tabDropdown,\n                }\n                return result;\n            }\n        }\n    }\n\n    /** @internal */\n    export function resolveIdAndMaximised(config: HeaderedItemConfig): { id: string, maximised: boolean} {\n        let id: string;\n        // To support legacy configs with Id saved as an array of string, assign config.id to a type which includes string array\n        let legacyId: string | string[] | undefined = config.id;\n        let legacyMaximised = false;\n        if (legacyId === undefined) {\n            id = ResolvedItemConfig.defaults.id;\n        } else {\n            if (Array.isArray(legacyId)) {\n                const idx = legacyId.findIndex((id) => id === legacyMaximisedId)\n                if (idx > 0) {\n                    legacyMaximised = true;\n                    legacyId = legacyId.splice(idx, 1);\n                }\n                if (legacyId.length > 0) {\n                    id = legacyId[0];\n                } else {\n                    id = ResolvedItemConfig.defaults.id;\n                }\n            } else {\n                id = legacyId;\n            }\n        }\n\n        let maximised: boolean;\n        if (config.maximised !== undefined) {\n            maximised = config.maximised;\n        } else {\n            maximised = legacyMaximised;\n        }\n\n        return { id, maximised }\n    }\n}\n\n/** @public */\nexport interface StackItemConfig extends HeaderedItemConfig {\n    type: 'stack';\n    content: ComponentItemConfig[];\n    /** The index of the item in content which is to be active*/\n    activeItemIndex?: number;\n}\n\n/** @public */\nexport namespace StackItemConfig {\n    /** @internal */\n    export function resolve(itemConfig: StackItemConfig, rowAndColumnChildLegacySizeDefault: boolean): ResolvedStackItemConfig {\n        const { id, maximised } = HeaderedItemConfig.resolveIdAndMaximised(itemConfig);\n        const { size, sizeUnit } = ItemConfig.resolveSize(itemConfig.size, itemConfig.width, itemConfig.height, rowAndColumnChildLegacySizeDefault);\n        const { size: minSize, sizeUnit: minSizeUnit } = ItemConfig.resolveMinSize(itemConfig.minSize, itemConfig.minWidth, itemConfig.minHeight);\n\n        const result: ResolvedStackItemConfig = {\n            type: ItemType.stack,\n            content: resolveContent(itemConfig.content),\n            size,\n            sizeUnit,\n            minSize,\n            minSizeUnit,\n            id,\n            maximised,\n            isClosable: itemConfig.isClosable ?? ResolvedItemConfig.defaults.isClosable,\n            activeItemIndex: itemConfig.activeItemIndex ?? ResolvedStackItemConfig.defaultActiveItemIndex,\n            header: HeaderedItemConfig.Header.resolve(itemConfig.header, itemConfig.hasHeaders),\n        };\n        return result;\n    }\n\n    /** @internal */\n    export function fromResolved(resolvedConfig: ResolvedStackItemConfig): StackItemConfig {\n        const result: StackItemConfig = {\n            type: ItemType.stack,\n            content: fromResolvedContent(resolvedConfig.content),\n            size: formatSize(resolvedConfig.size, resolvedConfig.sizeUnit),\n            minSize: formatUndefinableSize(resolvedConfig.minSize, resolvedConfig.minSizeUnit),\n            id: resolvedConfig.id,\n            maximised: resolvedConfig.maximised,\n            isClosable: resolvedConfig.isClosable,\n            activeItemIndex: resolvedConfig.activeItemIndex,\n            header: ResolvedHeaderedItemConfig.Header.createCopy(resolvedConfig.header),\n        };\n\n        return result;\n    }\n\n    /** @internal */\n    function resolveContent(content: ComponentItemConfig[] | undefined): ResolvedComponentItemConfig[] {\n        if (content === undefined) {\n            return [];\n        } else {\n            const count = content.length;\n            const result = new Array<ResolvedComponentItemConfig>(count);\n            for (let i = 0; i < count; i++) {\n                const childItemConfig = content[i];\n                const itemConfig = ItemConfig.resolve(childItemConfig, false);\n                if (!ResolvedItemConfig.isComponentItem(itemConfig)) {\n                    throw new AssertError('UCUSICRC91114', JSON.stringify(itemConfig));\n                } else {\n                    result[i] = itemConfig;\n                }\n            }\n            return result;\n        }\n    }\n\n    /** @internal */\n    function fromResolvedContent(resolvedContent: ResolvedComponentItemConfig[]): ComponentItemConfig[] {\n        const count = resolvedContent.length;\n        const result = new Array<ComponentItemConfig>(count);\n        for (let i = 0; i < count; i++) {\n            const resolvedContentConfig = resolvedContent[i];\n            result[i] = ComponentItemConfig.fromResolved(resolvedContentConfig);\n        }\n        return result;\n    }\n}\n\n/** @public */\nexport interface ComponentItemConfig extends HeaderedItemConfig {\n    type: 'component';\n    readonly content?: [];\n\n    /**\n     * The title of the item as displayed on its tab and on popout windows\n     * Default: componentType.toString() or ''\n     */\n    title?: string;\n\n    /**\n     * The type of the component.\n     * @deprecated use {@link (ComponentItemConfig:interface).componentType} instead\n     */\n    componentName?: string;\n\n    /**\n     * The type of the component.\n     * `componentType` must be of type `string` if it is registered with any of the following functions:\n     * * {@link (GoldenLayout:class).registerComponent} (deprecated)\n     * * {@link (GoldenLayout:class).registerComponentConstructor}\n     * * {@link (GoldenLayout:class).registerComponentFactoryFunction}\n     */\n    componentType: JsonValue;\n    /**\n     * The state information with which a component will be initialised with.\n     * Will be passed to the component constructor function and will be the value returned by\n     * container.initialState.\n     */\n    componentState?: JsonValue;\n\n    /**\n     * Default: true\n     */\n    reorderEnabled?: boolean;  // Takes precedence over LayoutConfig.reorderEnabled.\n}\n\n/** @public */\nexport namespace ComponentItemConfig {\n    /** @internal */\n    export function resolve(itemConfig: ComponentItemConfig, rowAndColumnChildLegacySizeDefault: boolean): ResolvedComponentItemConfig {\n        let componentType: JsonValue | undefined = itemConfig.componentType;\n        if (componentType === undefined) {\n            componentType = itemConfig.componentName;\n        }\n        if (componentType === undefined) {\n            throw new Error('ComponentItemConfig.componentType is undefined');\n        } else {\n            const { id, maximised } = HeaderedItemConfig.resolveIdAndMaximised(itemConfig);\n            let title: string;\n            if (itemConfig.title === undefined || itemConfig.title === '') {\n                title = ComponentItemConfig.componentTypeToTitle(componentType);\n            } else {\n                title = itemConfig.title;\n            }\n            const { size, sizeUnit } = ItemConfig.resolveSize(itemConfig.size, itemConfig.width, itemConfig.height, rowAndColumnChildLegacySizeDefault);\n            const { size: minSize, sizeUnit: minSizeUnit } = ItemConfig.resolveMinSize(itemConfig.minSize, itemConfig.minWidth, itemConfig.minHeight);\n            const result: ResolvedComponentItemConfig = {\n                type: itemConfig.type,\n                content: [],\n                size,\n                sizeUnit,\n                minSize,\n                minSizeUnit,\n                id,\n                maximised,\n                isClosable: itemConfig.isClosable ?? ResolvedItemConfig.defaults.isClosable,\n                reorderEnabled: itemConfig.reorderEnabled ?? ResolvedComponentItemConfig.defaultReorderEnabled,\n                title,\n                header: HeaderedItemConfig.Header.resolve(itemConfig.header, itemConfig.hasHeaders),\n                componentType,\n                componentState: itemConfig.componentState ?? {},\n            };\n            return result;\n        }\n    }\n\n    /** @internal */\n    export function fromResolved(resolvedConfig: ResolvedComponentItemConfig): ComponentItemConfig {\n        const result: ComponentItemConfig = {\n            type: ItemType.component,\n            size: formatSize(resolvedConfig.size, resolvedConfig.sizeUnit),\n            minSize: formatUndefinableSize(resolvedConfig.minSize, resolvedConfig.minSizeUnit),\n            id: resolvedConfig.id,\n            maximised: resolvedConfig.maximised,\n            isClosable: resolvedConfig.isClosable,\n            reorderEnabled: resolvedConfig.reorderEnabled,\n            title: resolvedConfig.title,\n            header: ResolvedHeaderedItemConfig.Header.createCopy(resolvedConfig.header),\n            componentType: resolvedConfig.componentType,\n            componentState: deepExtendValue(undefined, resolvedConfig.componentState) as JsonValue,\n        }\n\n        return result;\n    }\n\n    export function componentTypeToTitle(componentType: JsonValue): string {\n        const componentTypeType = typeof componentType;\n        switch (componentTypeType) {\n            case 'string': return componentType as string;\n            case 'number': return (componentType as number).toString();\n            case 'boolean': return (componentType as boolean).toString();\n            default: return '';\n        }\n    }\n}\n\n// RowOrColumn\n/** @public */\nexport interface RowOrColumnItemConfig extends ItemConfig {\n    type: 'row' | 'column';\n    content: (RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig)[];\n}\n\n/** @public */\nexport namespace RowOrColumnItemConfig {\n    export type ChildItemConfig = RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig;\n\n    export function isChildItemConfig(itemConfig: ItemConfig): itemConfig is ChildItemConfig {\n        switch (itemConfig.type) {\n            case ItemType.row:\n            case ItemType.column:\n            case ItemType.stack:\n            case ItemType.component:\n                return true;\n            case ItemType.ground:\n                return false;\n            default:\n                throw new UnreachableCaseError('UROCOSPCICIC13687', itemConfig.type);\n        }\n    }\n\n    /** @internal */\n    export function resolve(itemConfig: RowOrColumnItemConfig, rowAndColumnChildLegacySizeDefault: boolean): ResolvedRowOrColumnItemConfig {\n        const { size, sizeUnit } = ItemConfig.resolveSize(itemConfig.size, itemConfig.width, itemConfig.height, rowAndColumnChildLegacySizeDefault);\n        const { size: minSize, sizeUnit: minSizeUnit } = ItemConfig.resolveMinSize(itemConfig.minSize, itemConfig.minWidth, itemConfig.minHeight);\n        const result: ResolvedRowOrColumnItemConfig = {\n            type: itemConfig.type,\n            content: RowOrColumnItemConfig.resolveContent(itemConfig.content),\n            size,\n            sizeUnit,\n            minSize,\n            minSizeUnit,\n            id: ItemConfig.resolveId(itemConfig.id),\n            isClosable: itemConfig.isClosable ?? ResolvedItemConfig.defaults.isClosable,\n        }\n        return result;\n    }\n\n    /** @internal */\n    export function fromResolved(resolvedConfig: ResolvedRowOrColumnItemConfig): RowOrColumnItemConfig {\n        const result: RowOrColumnItemConfig = {\n            type: resolvedConfig.type,\n            content: fromResolvedContent(resolvedConfig.content),\n            size: formatSize(resolvedConfig.size, resolvedConfig.sizeUnit),\n            minSize: formatUndefinableSize(resolvedConfig.minSize, resolvedConfig.minSizeUnit),\n            id: resolvedConfig.id,\n            isClosable: resolvedConfig.isClosable,\n        }\n\n        return result;\n    }\n\n    /** @internal */\n    export function resolveContent(content: ChildItemConfig[] | undefined): ResolvedRowOrColumnItemConfig.ChildItemConfig[] {\n        if (content === undefined) {\n            return [];\n        } else {\n            const count = content.length;\n            const childItemConfigs = new Array<RowOrColumnItemConfig.ChildItemConfig>(count);\n            let widthOrHeightSpecifiedAtLeastOnce = false;\n            let sizeSpecifiedAtLeastOnce = false;\n            for (let i = 0; i < count; i++) {\n                const childItemConfig = content[i];\n                if (!RowOrColumnItemConfig.isChildItemConfig(childItemConfig)) {\n                    throw new ConfigurationError('ItemConfig is not Row, Column or Stack', childItemConfig);\n                } else {\n                    if (!sizeSpecifiedAtLeastOnce) {\n                        const sizeWidthHeightSpecificationType = ItemConfig.calculateSizeWidthHeightSpecificationType(childItemConfig);\n                        switch (sizeWidthHeightSpecificationType) {\n                            case ItemConfig.SizeWidthHeightSpecificationType.None:\n                                break;\n                            case ItemConfig.SizeWidthHeightSpecificationType.WidthOrHeight:\n                                widthOrHeightSpecifiedAtLeastOnce = true;\n                                break;\n                            case ItemConfig.SizeWidthHeightSpecificationType.Size:\n                                sizeSpecifiedAtLeastOnce = true;\n                                break;\n                            default:\n                                throw new UnreachableCaseError('ROCICRC87556', sizeWidthHeightSpecificationType);\n                        }\n                    }\n                    childItemConfigs[i] = childItemConfig;\n                }\n            }\n\n            let legacySizeDefault: boolean;\n            if (sizeSpecifiedAtLeastOnce) {\n                legacySizeDefault = false;\n            } else {\n                if (widthOrHeightSpecifiedAtLeastOnce) {\n                    legacySizeDefault = true;\n                } else {\n                    legacySizeDefault = false;\n                }\n            }\n\n            const result = new Array<ResolvedRowOrColumnItemConfig.ChildItemConfig>(count);\n            for (let i = 0; i < count; i++) {\n                const childItemConfig = childItemConfigs[i];\n                const resolvedChildItemConfig = ItemConfig.resolve(childItemConfig, legacySizeDefault);\n                if (!ResolvedRowOrColumnItemConfig.isChildItemConfig(resolvedChildItemConfig)) {\n                    throw new AssertError('UROCOSPIC99512', JSON.stringify(resolvedChildItemConfig));\n                } else {\n                    result[i] = resolvedChildItemConfig;\n                }\n            }\n            return result;\n        }\n    }\n\n    /** @internal */\n    function fromResolvedContent(resolvedContent: readonly ResolvedRowOrColumnItemConfig.ChildItemConfig[]): RowOrColumnItemConfig.ChildItemConfig[] {\n        const count = resolvedContent.length;\n        const result = new Array<RowOrColumnItemConfig.ChildItemConfig>(count);\n        for (let i = 0; i < count; i++) {\n            const resolvedContentConfig = resolvedContent[i];\n            const type = resolvedContentConfig.type;\n            let contentConfig: RowOrColumnItemConfig.ChildItemConfig;\n            switch (type) {\n                case ItemType.row:\n                case ItemType.column:\n                    contentConfig = RowOrColumnItemConfig.fromResolved(resolvedContentConfig);\n                    break;\n                case ItemType.stack:\n                    contentConfig = StackItemConfig.fromResolved(resolvedContentConfig);\n                    break;\n                case ItemType.component:\n                    contentConfig = ComponentItemConfig.fromResolved(resolvedContentConfig);\n                    break;\n                default:\n                    throw new UnreachableCaseError('ROCICFRC44797', type);\n            }\n            result[i] = contentConfig;\n        }\n        return result;\n    }\n}\n\n/** @public */\nexport type RootItemConfig = RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig;\n\n/** @public */\nexport namespace RootItemConfig {\n    export function isRootItemConfig(itemConfig: ItemConfig): itemConfig is RootItemConfig {\n        switch (itemConfig.type) {\n            case ItemType.row:\n            case ItemType.column:\n            case ItemType.stack:\n            case ItemType.component:\n                return true;\n            case ItemType.ground:\n                return false;\n            default:\n                throw new UnreachableCaseError('URICIR23687', itemConfig.type);\n        }\n    }\n\n    /** @internal */\n    export function resolve(itemConfig: RootItemConfig | undefined): ResolvedRootItemConfig | undefined {\n        if (itemConfig === undefined) {\n            return undefined;\n        } else {\n            const result = ItemConfig.resolve(itemConfig, false);\n            if (!ResolvedRootItemConfig.isRootItemConfig(result)) {\n                throw new ConfigurationError('ItemConfig is not Row, Column or Stack', JSON.stringify(itemConfig));\n            } else {\n                return result;\n            }\n        }\n    }\n\n    /** @internal */\n    export function fromResolvedOrUndefined(resolvedItemConfig: ResolvedRootItemConfig | undefined): RootItemConfig | undefined {\n        if (resolvedItemConfig === undefined) {\n            return undefined;\n        } else {\n            const type = resolvedItemConfig.type;\n            switch (type) {\n                case ItemType.row:\n                case ItemType.column:\n                    return RowOrColumnItemConfig.fromResolved(resolvedItemConfig);\n                case ItemType.stack:\n                    return StackItemConfig.fromResolved(resolvedItemConfig);\n                case ItemType.component:\n                    return ComponentItemConfig.fromResolved(resolvedItemConfig);\n                default:\n                    throw new UnreachableCaseError('RICFROU89921', type);\n            }\n        }\n    }\n}\n\n/** @public */\nexport interface LayoutConfig {\n    root: RootItemConfig | undefined;\n    /** @deprecated Use {@link (LayoutConfig:interface).root} */\n    content?: (RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig)[];\n    openPopouts?: PopoutLayoutConfig[];\n    dimensions?: LayoutConfig.Dimensions;\n    settings?: LayoutConfig.Settings;\n    /** @deprecated use {@link (LayoutConfig:interface).header} instead */\n    labels?: LayoutConfig.Labels;\n    header?: LayoutConfig.Header;\n}\n\n/** Use to specify LayoutConfig with defaults or deserialise a LayoutConfig.\n * Deserialisation will handle backwards compatibility.\n * Note that LayoutConfig should be used for serialisation (not LayoutConfig)\n * @public\n */\nexport namespace LayoutConfig {\n    export interface Settings {\n        /**\n         * @deprecated use ${@link (LayoutConfig:namespace).(Header:interface).show} instead\n         */\n        hasHeaders?: boolean;\n\n        /**\n         * Constrains the area in which items can be dragged to the layout's container. Will be set to false\n         * automatically when layout.createDragSource() is called.\n         * Default: true\n         */\n        constrainDragToContainer?: boolean;\n\n        /**\n         * If true, the user can re-arrange the layout by dragging items by their tabs to the desired location.\n         * Can be overridden by ItemConfig.reorderEnabled for specific ItemConfigs\n         * Default: true\n         */\n        reorderEnabled?: boolean;\n\n        /**\n         * Decides what will be opened in a new window if the user clicks the popout icon. If true the entire stack will\n         * be transferred to the new window, if false only the active component will be opened.\n         * Default: false\n         */\n        popoutWholeStack?: boolean;\n\n        /**\n         * Specifies if an error is thrown when a popout is blocked by the browser (e.g. by opening it programmatically).\n         * If false, the popout call will fail silently.\n         * Default: true\n         */\n        blockedPopoutsThrowError?: boolean;\n\n        /**\n         * Specifies if all popouts should be closed when the page that created them is closed. Popouts don't have a\n         * strong dependency on their parent and can exist on their own, but can be quite annoying to close by hand. In\n         * addition, any changes made to popouts won't be stored after the parent is closed.\n         * Default: true\n         * @deprecated Will be removed in version 3.\n         */\n        closePopoutsOnUnload?: boolean;\n\n        /**\n         * Specifies if the popout icon should be displayed in the header-bar.\n         * @deprecated use {@link (LayoutConfig:namespace).(Header:interface).popout} instead\n         */\n        showPopoutIcon?: boolean;\n\n        /**\n         * Specifies if the maximise icon should be displayed in the header-bar.\n         * @deprecated use {@link (LayoutConfig:namespace).(Header:interface).maximise} instead\n         */\n        showMaximiseIcon?: boolean;\n\n        /**\n         * Specifies if the close icon should be displayed in the header-bar.\n         * @deprecated use {@link (LayoutConfig:namespace).(Header:interface).close} instead\n         */\n        showCloseIcon?: boolean;\n\n        /**\n         * Specifies Responsive Mode (more info needed).\n         * Default: none\n         */\n        responsiveMode?: ResponsiveMode;\n\n        /**\n         * Specifies Maximum pixel overlap per tab.\n         * Default: 0\n         */\n        tabOverlapAllowance?: number;\n\n        /**\n         *\n         * Default: true\n         */\n        reorderOnTabMenuClick?: boolean;\n\n        /**\n         * Default: 10\n         */\n        tabControlOffset?: number;\n\n        /**\n         * Specifies whether to pop in elements when closing a popout window.\n         * Default: false\n         */\n        popInOnClose?: boolean;\n    }\n\n    export namespace Settings {\n        export function resolve(settings: Settings | undefined): ResolvedLayoutConfig.Settings {\n            const result: ResolvedLayoutConfig.Settings = {\n                constrainDragToContainer: settings?.constrainDragToContainer ?? ResolvedLayoutConfig.Settings.defaults.constrainDragToContainer,\n                reorderEnabled: settings?.reorderEnabled ?? ResolvedLayoutConfig.Settings.defaults.reorderEnabled,\n                popoutWholeStack: settings?.popoutWholeStack ?? ResolvedLayoutConfig.Settings.defaults.popoutWholeStack,\n                blockedPopoutsThrowError: settings?.blockedPopoutsThrowError ?? ResolvedLayoutConfig.Settings.defaults.blockedPopoutsThrowError,\n                closePopoutsOnUnload: settings?.closePopoutsOnUnload ?? ResolvedLayoutConfig.Settings.defaults.closePopoutsOnUnload,\n                responsiveMode: settings?.responsiveMode ?? ResolvedLayoutConfig.Settings.defaults.responsiveMode,\n                tabOverlapAllowance: settings?.tabOverlapAllowance ?? ResolvedLayoutConfig.Settings.defaults.tabOverlapAllowance,\n                reorderOnTabMenuClick: settings?.reorderOnTabMenuClick ?? ResolvedLayoutConfig.Settings.defaults.reorderOnTabMenuClick,\n                tabControlOffset: settings?.tabControlOffset ?? ResolvedLayoutConfig.Settings.defaults.tabControlOffset,\n                popInOnClose: settings?.popInOnClose ?? ResolvedLayoutConfig.Settings.defaults.popInOnClose,\n            }\n            return result;\n        }\n    }\n\n    export interface Dimensions {\n        /**\n         * The width of the borders between the layout items in pixel. Please note: The actual draggable area is wider\n         * than the visible one, making it safe to set this to small values without affecting usability.\n         * Default: 5\n         */\n        borderWidth?: number;\n\n        /**\n         * Default: 15\n         */\n        borderGrabWidth?: number,\n\n        /**\n         * The minimum height an item can be resized to (in pixel).\n         * @deprecated use {@link (LayoutConfig:namespace).(Dimensions:interface).defaultMinItemHeight} instead\n         */\n        minItemHeight?: number;\n\n        /**\n         * The minimum height an item can be resized to.\n         * Default: 0\n         */\n        defaultMinItemHeight?: string;\n\n        /**\n         * The minimum width an item can be resized to (in pixel).\n         * @deprecated use {@link (LayoutConfig:namespace).(Dimensions:interface).defaultMinItemWidth} instead\n         */\n        minItemWidth?: number;\n\n        /**\n         * The minimum width an item can be resized to.\n         * Default: 10px\n         */\n        defaultMinItemWidth?: string;\n\n        /**\n         * The height of the header elements in pixel. This can be changed, but your theme's header css needs to be\n         * adjusted accordingly.\n         * Default: 20\n         */\n        headerHeight?: number;\n\n        /**\n         * The width of the element that appears when an item is dragged (in pixel).\n         * Default: 300\n         */\n        dragProxyWidth?: number;\n\n        /**\n         * The height of the element that appears when an item is dragged (in pixel).\n         * Default: 200\n         */\n        dragProxyHeight?: number;\n    }\n\n    export namespace Dimensions {\n        /** @internal */\n        export function resolve(dimensions: Dimensions | undefined): ResolvedLayoutConfig.Dimensions {\n            const { size: defaultMinItemHeight, sizeUnit: defaultMinItemHeightUnit } = Dimensions.resolveDefaultMinItemHeight(dimensions);\n            const { size: defaultMinItemWidth, sizeUnit: defaultMinItemWidthUnit } = Dimensions.resolveDefaultMinItemWidth(dimensions);\n            const result: ResolvedLayoutConfig.Dimensions = {\n                borderWidth: dimensions?.borderWidth ?? ResolvedLayoutConfig.Dimensions.defaults.borderWidth,\n                borderGrabWidth: dimensions?.borderGrabWidth ?? ResolvedLayoutConfig.Dimensions.defaults.borderGrabWidth,\n                defaultMinItemHeight,\n                defaultMinItemHeightUnit,\n                defaultMinItemWidth,\n                defaultMinItemWidthUnit,\n                headerHeight: dimensions?.headerHeight ?? ResolvedLayoutConfig.Dimensions.defaults.headerHeight,\n                dragProxyWidth: dimensions?.dragProxyWidth ?? ResolvedLayoutConfig.Dimensions.defaults.dragProxyWidth,\n                dragProxyHeight: dimensions?.dragProxyHeight ?? ResolvedLayoutConfig.Dimensions.defaults.dragProxyHeight,\n            }\n            return result;\n        }\n\n        /** @internal */\n        export function fromResolved(resolvedDimensions: ResolvedLayoutConfig.Dimensions): Dimensions {\n            const result: Dimensions = {\n                borderWidth: resolvedDimensions.borderWidth,\n                borderGrabWidth: resolvedDimensions.borderGrabWidth,\n                defaultMinItemHeight: formatSize(resolvedDimensions.defaultMinItemHeight, resolvedDimensions.defaultMinItemHeightUnit),\n                defaultMinItemWidth: formatSize(resolvedDimensions.defaultMinItemWidth, resolvedDimensions.defaultMinItemWidthUnit),\n                headerHeight: resolvedDimensions.headerHeight,\n                dragProxyWidth: resolvedDimensions.dragProxyWidth,\n                dragProxyHeight: resolvedDimensions.dragProxyHeight,\n            };\n\n            return result;\n        }\n\n        /** @internal */\n        export function resolveDefaultMinItemHeight(dimensions: Dimensions | undefined): SizeWithUnit {\n            const height = dimensions?.defaultMinItemHeight;\n            if (height === undefined) {\n                return { size: ResolvedLayoutConfig.Dimensions.defaults.defaultMinItemHeight, sizeUnit: ResolvedLayoutConfig.Dimensions.defaults.defaultMinItemHeightUnit };\n            } else {\n                return parseSize(height, [SizeUnitEnum.Pixel]);\n            }\n        }\n\n        /** @internal */\n        export function resolveDefaultMinItemWidth(dimensions: Dimensions | undefined): SizeWithUnit {\n            const width = dimensions?.defaultMinItemWidth;\n            if (width === undefined) {\n                return { size: ResolvedLayoutConfig.Dimensions.defaults.defaultMinItemWidth, sizeUnit: ResolvedLayoutConfig.Dimensions.defaults.defaultMinItemWidthUnit };\n            } else {\n                return parseSize(width, [SizeUnitEnum.Pixel]);\n            }\n        }\n    }\n\n    export interface Labels {\n        /**\n         * @deprecated use {@link (LayoutConfig:namespace).(Header:interface).close} instead\n         */\n        close?: string;\n\n        /**\n         * @deprecated use {@link (LayoutConfig:namespace).(Header:interface).maximise} instead\n         */\n        maximise?: string;\n\n        /**\n         * @deprecated use {@link (LayoutConfig:namespace).(Header:interface).minimise} instead\n         */\n        minimise?: string;\n\n        /**\n         * @deprecated use {@link (LayoutConfig:namespace).(Header:interface).popin} instead\n         */\n        popin?: string;\n\n        /**\n         * @deprecated use {@link (LayoutConfig:namespace).(Header:interface).popout} instead\n         */\n        popout?: string;\n\n        /**\n         * @deprecated use {@link (LayoutConfig:namespace).(Header:interface).tabDropdown} instead\n         */\n        tabDropdown?: string;\n    }\n\n    export interface Header {\n        /**\n         * Specifies whether header should be displayed, and if so, on which side.\n         * If false, the layout will be displayed with splitters only.\n         * Default: 'top'\n         */\n        show?: false | Side;\n        /**\n         * The tooltip text that appears when hovering over the popout icon or false if popout button not displayed.\n         * Default: 'open in new window'\n         */\n        popout?: false | string;\n        /**\n         * The tooltip text that appears when hovering over the popin icon.\n         * Default: 'pop in'\n         */\n        popin?: string;\n        /**\n         * The tooltip text that appears when hovering over the maximise icon or false if maximised button not displayed.\n         * Default: 'maximise'\n         */\n        maximise?: false | string;\n        /**\n         * The tooltip text that appears when hovering over the close icon.\n         * Default: 'close'\n         */\n        close?: false | string;\n        /**\n         * The tooltip text that appears when hovering over the minimise icon.\n         * Default: 'minimise'\n         */\n        minimise?: string;\n        /**\n         *\n         * Default: 'additional tabs'\n         */\n        tabDropdown?: false | string;\n    }\n\n    export namespace Header {\n        /** @internal */\n        export function resolve(header: Header | undefined,\n            settings: LayoutConfig.Settings | undefined, labels: LayoutConfig.Labels | undefined\n        ): ResolvedLayoutConfig.Header {\n            let show: false | Side;\n            if (header?.show !== undefined) {\n                show = header.show;\n            } else {\n                if (settings !== undefined && settings.hasHeaders !== undefined) {\n                    show = settings.hasHeaders ? ResolvedLayoutConfig.Header.defaults.show : false;\n                } else {\n                    show = ResolvedLayoutConfig.Header.defaults.show;\n                }\n            }\n            const result: ResolvedLayoutConfig.Header = {\n                show,\n                popout: header?.popout ?? labels?.popout ??\n                    (settings?.showPopoutIcon === false ? false : ResolvedLayoutConfig.Header.defaults.popout),\n                dock: header?.popin ?? labels?.popin ?? ResolvedLayoutConfig.Header.defaults.dock,\n                maximise: header?.maximise ?? labels?.maximise ??\n                    (settings?.showMaximiseIcon === false ? false : ResolvedLayoutConfig.Header.defaults.maximise),\n                close: header?.close ?? labels?.close ??\n                    (settings?.showCloseIcon === false ? false : ResolvedLayoutConfig.Header.defaults.close),\n                minimise: header?.minimise ?? labels?.minimise ?? ResolvedLayoutConfig.Header.defaults.minimise,\n                tabDropdown: header?.tabDropdown ?? labels?.tabDropdown ?? ResolvedLayoutConfig.Header.defaults.tabDropdown,\n            }\n            return result;\n        }\n    }\n\n    export function isPopout(config: LayoutConfig): config is PopoutLayoutConfig {\n        return 'parentId' in config || 'indexInParent' in config || 'window' in config;\n    }\n\n    /** @internal */\n    export function resolve(layoutConfig: LayoutConfig): ResolvedLayoutConfig {\n        if (isPopout(layoutConfig)) {\n            return PopoutLayoutConfig.resolve(layoutConfig);\n        } else {\n            let root: RootItemConfig | undefined;\n            if (layoutConfig.root !== undefined) {\n                root = layoutConfig.root;\n            } else {\n                if (layoutConfig.content !== undefined && layoutConfig.content.length > 0) {\n                    root = layoutConfig.content[0];\n                } else {\n                    root = undefined;\n                }\n            }\n            const config: ResolvedLayoutConfig = {\n                resolved: true,\n                root: RootItemConfig.resolve(root),\n                openPopouts: LayoutConfig.resolveOpenPopouts(layoutConfig.openPopouts),\n                dimensions: LayoutConfig.Dimensions.resolve(layoutConfig.dimensions),\n                settings: LayoutConfig.Settings.resolve(layoutConfig.settings),\n                header: LayoutConfig.Header.resolve(layoutConfig.header, layoutConfig.settings, layoutConfig.labels),\n            }\n            return config;\n        }\n    }\n\n    export function fromResolved(config: ResolvedLayoutConfig): LayoutConfig {\n        const result: LayoutConfig = {\n            root: RootItemConfig.fromResolvedOrUndefined(config.root),\n            openPopouts: PopoutLayoutConfig.fromResolvedArray(config.openPopouts),\n            settings: ResolvedLayoutConfig.Settings.createCopy(config.settings),\n            dimensions: LayoutConfig.Dimensions.fromResolved(config.dimensions),\n            header: ResolvedLayoutConfig.Header.createCopy(config.header),\n        };\n        return result;\n    }\n\n    export function isResolved(configOrResolvedConfig: ResolvedLayoutConfig | LayoutConfig): configOrResolvedConfig is ResolvedLayoutConfig {\n        const config = configOrResolvedConfig as ResolvedLayoutConfig;\n        return config.resolved !== undefined && (config.resolved === true);\n    }\n\n    /** @internal */\n    export function resolveOpenPopouts(popoutConfigs: PopoutLayoutConfig[] | undefined): ResolvedPopoutLayoutConfig[] {\n        if (popoutConfigs === undefined) {\n            return [];\n        } else {\n            const count = popoutConfigs.length;\n            const result = new Array<ResolvedPopoutLayoutConfig>(count);\n            for (let i = 0; i < count; i++) {\n                result[i] = PopoutLayoutConfig.resolve(popoutConfigs[i]);\n            }\n            return result;\n        }\n    }\n}\n\n/** @public */\nexport interface PopoutLayoutConfig extends LayoutConfig {\n    /** The id of the element the item will be appended to on popIn\n    * If null, append to topmost layout element\n    */\n    parentId: string | null | undefined;\n    /** The position of this element within its parent\n    * If null, position is last\n    */\n    indexInParent: number | null | undefined;\n    /** @deprecated use {@link (PopoutLayoutConfig:interface).window} */\n    dimensions: PopoutLayoutConfig.Dimensions | undefined; // for backwards compatibility\n    window: PopoutLayoutConfig.Window | undefined;\n}\n\n/** @public */\nexport namespace PopoutLayoutConfig {\n    // Previous versions kept window information in Dimensions key.  Only use for backwards compatibility\n    /** @deprecated use {@link (PopoutLayoutConfig:namespace).(Window:interface)} */\n    export interface Dimensions extends LayoutConfig.Dimensions {\n        /** @deprecated use {@link (PopoutLayoutConfig:namespace).(Window:interface).width} */\n        width?: number | null,\n        /** @deprecated use {@link (PopoutLayoutConfig:namespace).(Window:interface).height} */\n        height?: number | null,\n        /** @deprecated use {@link (PopoutLayoutConfig:namespace).(Window:interface).left} */\n        left?: number | null,\n        /** @deprecated use {@link (PopoutLayoutConfig:namespace).(Window:interface).top} */\n        top?: number | null,\n    }\n\n    export interface Window {\n        width?: number,\n        height?: number,\n        left?: number,\n        top?: number,\n    }\n\n    export namespace Window {\n        /** @internal */\n        export function resolve(window: Window | undefined,\n            dimensions: Dimensions | undefined): ResolvedPopoutLayoutConfig.Window\n        {\n            let result: ResolvedPopoutLayoutConfig.Window;\n            const defaults = ResolvedPopoutLayoutConfig.Window.defaults;\n            if (window !== undefined) {\n                result = {\n                    width: window.width ?? defaults.width,\n                    height: window.height ?? defaults.height,\n                    left: window.left ?? defaults.left,\n                    top: window.top ?? defaults.top,\n                }\n            } else {\n                result = {\n                    width: dimensions?.width ?? defaults.width,\n                    height: dimensions?.height ?? defaults.height,\n                    left: dimensions?.left ?? defaults.left,\n                    top: dimensions?.top ?? defaults.top,\n                }\n            }\n            return result;\n        }\n\n        /** @internal */\n        export function fromResolved(resolvedWindow: ResolvedPopoutLayoutConfig.Window): Window {\n            const result: Window = {\n                width: resolvedWindow.width === null ? undefined : resolvedWindow.width,\n                height: resolvedWindow.height === null ? undefined : resolvedWindow.height,\n                left: resolvedWindow.left === null ? undefined : resolvedWindow.left,\n                top: resolvedWindow.top === null ? undefined : resolvedWindow.top,\n            }\n\n            return result;\n        }\n    }\n\n    /** @internal */\n    export function resolve(popoutConfig: PopoutLayoutConfig): ResolvedPopoutLayoutConfig {\n        let root: RootItemConfig | undefined;\n        if (popoutConfig.root !== undefined) {\n            root = popoutConfig.root;\n        } else {\n            if (popoutConfig.content !== undefined && popoutConfig.content.length > 0) {\n                root = popoutConfig.content[0];\n            } else {\n                root = undefined;\n            }\n        }\n\n        const config: ResolvedPopoutLayoutConfig = {\n            root: RootItemConfig.resolve(root),\n            openPopouts: LayoutConfig.resolveOpenPopouts(popoutConfig.openPopouts),\n            dimensions: LayoutConfig.Dimensions.resolve(popoutConfig.dimensions),\n            settings: LayoutConfig.Settings.resolve(popoutConfig.settings),\n            header: LayoutConfig.Header.resolve(popoutConfig.header, popoutConfig.settings, popoutConfig.labels),\n            parentId: popoutConfig.parentId ?? null,\n            indexInParent: popoutConfig.indexInParent ?? null,\n            window: PopoutLayoutConfig.Window.resolve(popoutConfig.window, popoutConfig.dimensions),\n            resolved: true,\n        }\n        return config;\n    }\n\n    /** @internal */\n    export function fromResolved(resolvedConfig: ResolvedPopoutLayoutConfig): PopoutLayoutConfig {\n        const result: PopoutLayoutConfig = {\n            root: RootItemConfig.fromResolvedOrUndefined(resolvedConfig.root),\n            openPopouts: fromResolvedArray(resolvedConfig.openPopouts),\n            dimensions: LayoutConfig.Dimensions.fromResolved(resolvedConfig.dimensions),\n            settings: ResolvedLayoutConfig.Settings.createCopy(resolvedConfig.settings),\n            header: ResolvedLayoutConfig.Header.createCopy(resolvedConfig.header),\n            parentId: resolvedConfig.parentId,\n            indexInParent: resolvedConfig.indexInParent,\n            window: PopoutLayoutConfig.Window.fromResolved(resolvedConfig.window),\n        }\n\n        return result;\n    }\n\n    /** @internal */\n    export function fromResolvedArray(resolvedArray: ResolvedPopoutLayoutConfig[]): PopoutLayoutConfig[] {\n        const resolvedOpenPopoutCount = resolvedArray.length;\n        const result = new Array<PopoutLayoutConfig>(resolvedOpenPopoutCount);\n        for (let i = 0; i < resolvedOpenPopoutCount; i++) {\n            const resolvedOpenPopout = resolvedArray[i];\n            result[i] = PopoutLayoutConfig.fromResolved(resolvedOpenPopout);\n        }\n\n        return result;\n    }\n}\n\n/** @internal */\nexport interface SizeWithUnit {\n    size: number;\n    sizeUnit: SizeUnitEnum;\n}\n\n/** @internal */\nexport interface UndefinableSizeWithUnit {\n    size: number | undefined;\n    sizeUnit: SizeUnitEnum;\n}\n\n/** @internal */\nexport function parseSize(sizeString: string, allowableSizeUnits: readonly SizeUnitEnum[]): SizeWithUnit {\n    const { numericPart: digitsPart, firstNonNumericCharPart: firstNonDigitPart } = splitStringAtFirstNonNumericChar(sizeString);\n    const size = Number.parseInt(digitsPart, 10);\n    if (isNaN(size)) {\n        throw new ConfigurationError(`${i18nStrings[I18nStringId.InvalidNumberPartInSizeString]}: ${sizeString}`);\n    } else {\n        const sizeUnit = SizeUnitEnum.tryParse(firstNonDigitPart);\n        if (sizeUnit === undefined) {\n            throw new ConfigurationError(`${i18nStrings[I18nStringId.UnknownUnitInSizeString]}: ${sizeString}`)\n        } else {\n            if (!allowableSizeUnits.includes(sizeUnit)) {\n                throw new ConfigurationError(`${i18nStrings[I18nStringId.UnsupportedUnitInSizeString]}: ${sizeString}`)\n            } else {\n                return { size, sizeUnit };\n            }\n        }\n    }\n}\n\n/** @internal */\nexport function formatSize(size: number, sizeUnit: SizeUnitEnum) {\n    return size.toString(10) + SizeUnitEnum.format(sizeUnit);\n}\n\n/** @internal */\nexport function formatUndefinableSize(size: number| undefined, sizeUnit: SizeUnitEnum) {\n    if (size === undefined) {\n        return undefined;\n    } else {\n        return size.toString(10) + SizeUnitEnum.format(sizeUnit);\n    }\n}\n\n/** @public @deprecated - use {@link (LayoutConfig:interface)} */\nexport type Config = LayoutConfig;\n", "import { BrowserPopout } from '../controls/browser-popout';\nimport { Tab } from '../controls/tab';\nimport { ComponentItem } from '../items/component-item';\n\n/**\n * A generic and very fast EventEmitter implementation. On top of emitting the actual event it emits an\n * {@link (EventEmitter:namespace).ALL_EVENT} event for every event triggered. This allows to hook into it and proxy events forwards\n * @public\n */\nexport class EventEmitter {\n    /** @internal */\n    private _allEventSubscriptions: EventEmitter.UnknownCallback[] = [];\n    /** @internal */\n    private _subscriptionsMap = new Map<string, EventEmitter.UnknownCallback[]>();\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    tryBubbleEvent(name: string, args: unknown[]): void {\n        // overridden by ContentItem\n    }\n\n    /**\n     * Emit an event and notify listeners\n     *\n     * @param eventName - The name of the event\n     * @param args - Additional arguments that will be passed to the listener\n     */\n    emit<K extends keyof EventEmitter.EventParamsMap>(eventName: K, ...args: EventEmitter.EventParamsMap[K]): void {\n        let subcriptions = this._subscriptionsMap.get(eventName);\n\n        if (subcriptions !== undefined) {\n            subcriptions = subcriptions.slice();\n            for (let i = 0; i < subcriptions.length; i++) {\n                const subscription = subcriptions[i];\n                subscription(...args);\n            }\n        }\n\n        this.emitAllEvent(eventName, args);\n        this.tryBubbleEvent(eventName, args);\n    }\n\n    /** @internal */\n    emitUnknown(eventName: string, ...args: EventEmitter.UnknownParams): void {\n        let subs = this._subscriptionsMap.get(eventName);\n\n        if (subs !== undefined) {\n            subs = subs.slice();\n            for (let i = 0; i < subs.length; i++) {\n                subs[i](...args);\n            }\n        }\n\n        this.emitAllEvent(eventName, args);\n        this.tryBubbleEvent(eventName, args);\n    }\n\n    /* @internal **/\n    emitBaseBubblingEvent<K extends keyof EventEmitter.EventParamsMap>(eventName: K): void {\n        const event = new EventEmitter.BubblingEvent(eventName, this);\n        this.emitUnknown(eventName, event);\n    }\n\n    /** @internal */\n    emitUnknownBubblingEvent(eventName: string): void {\n        const event = new EventEmitter.BubblingEvent(eventName, this);\n        this.emitUnknown(eventName, event);\n    }\n\n    /**\n     * Removes a listener for an event.\n     * @param eventName - The name of the event\n     * @param callback - The previously registered callback method (optional)\n     */\n    removeEventListener<K extends keyof EventEmitter.EventParamsMap>(eventName: K, callback: EventEmitter.Callback<K>): void {\n        const unknownCallback = callback as EventEmitter.UnknownCallback;\n        this.removeUnknownEventListener(eventName, unknownCallback);\n    }\n\n    off<K extends keyof EventEmitter.EventParamsMap>(eventName: K, callback: EventEmitter.Callback<K>): void {\n        this.removeEventListener(eventName, callback);\n    }\n\n    /**\n     * Alias for off\n     */\n    unbind = this.removeEventListener;\n\n    /**\n     * Alias for emit\n     */\n    trigger = this.emit;\n\n    /**\n     * Listen for events\n     *\n     * @param eventName - The name of the event to listen to\n     * @param callback - The callback to execute when the event occurs\n     */\n    addEventListener<K extends keyof EventEmitter.EventParamsMap>(eventName: K, callback: EventEmitter.Callback<K>): void {\n        const unknownCallback = callback as EventEmitter.UnknownCallback;\n        this.addUnknownEventListener(eventName, unknownCallback);\n    }\n\n    on<K extends keyof EventEmitter.EventParamsMap>(eventName: K, callback: EventEmitter.Callback<K>): void {\n        this.addEventListener(eventName, callback);\n    }\n\n    /** @internal */\n    private addUnknownEventListener(eventName: string, callback: EventEmitter.UnknownCallback): void {\n        if (eventName === EventEmitter.ALL_EVENT) {\n            this._allEventSubscriptions.push(callback);\n        } else {\n            let subscriptions = this._subscriptionsMap.get(eventName);\n            if (subscriptions !== undefined) {\n                subscriptions.push(callback);\n            } else {\n                subscriptions = [callback];\n                this._subscriptionsMap.set(eventName, subscriptions);\n            }\n        }\n    }\n\n    /** @internal */\n    private removeUnknownEventListener(eventName: string, callback: EventEmitter.UnknownCallback): void {\n        if (eventName === EventEmitter.ALL_EVENT) {\n            this.removeSubscription(eventName, this._allEventSubscriptions, callback);\n        } else {\n            const subscriptions = this._subscriptionsMap.get(eventName);\n            if (subscriptions === undefined) {\n                throw new Error('No subscribtions to unsubscribe for event ' + eventName);\n            } else {\n                this.removeSubscription(eventName, subscriptions, callback);\n            }\n        }\n    }\n\n    /** @internal */\n    private removeSubscription(eventName: string, subscriptions: EventEmitter.UnknownCallback[], callback: EventEmitter.UnknownCallback) {\n        const idx = subscriptions.indexOf(callback);\n        if (idx < 0) {\n            throw new Error('Nothing to unbind for ' + eventName);\n        } else {\n            subscriptions.splice(idx, 1);\n        }\n    }\n\n    /** @internal */\n    private emitAllEvent(eventName: string, args: unknown[]) {\n        const allEventSubscriptionsCount = this._allEventSubscriptions.length;\n        if (allEventSubscriptionsCount > 0) {\n            const unknownArgs = args.slice() as EventEmitter.UnknownParams;\n            unknownArgs.unshift(eventName);\n\n            const allEventSubcriptions = this._allEventSubscriptions.slice();\n\n            for (let i = 0; i < allEventSubscriptionsCount; i++) {\n                allEventSubcriptions[i](...unknownArgs);\n            }\n        }\n    }\n}\n\n/** @public */\nexport namespace EventEmitter {\n    /**\n     * The name of the event that's triggered for every event\n     */\n    export const ALL_EVENT = '__all';\n\n    export const headerClickEventName = 'stackHeaderClick';\n    export const headerTouchStartEventName = 'stackHeaderTouchStart';\n\n    /** @internal */\n    export type UnknownCallback = (this: void, ...args: UnknownParams) => void;\n    export type Callback<K extends keyof EventEmitter.EventParamsMap> = (this: void, ...args: EventParamsMap[K]) => void;\n\n    export interface EventParamsMap {\n        \"__all\": UnknownParams;\n        \"activeContentItemChanged\": ComponentItemParam;\n        \"close\": NoParams;\n        \"closed\": NoParams;\n        \"destroy\": NoParams;\n        \"drag\": DragParams;\n        \"dragStart\": DragStartParams;\n        \"dragStop\": DragStopParams;\n        \"hide\": NoParams;\n        \"initialised\": NoParams;\n        \"itemDropped\": ComponentItemParam;\n        \"maximised\": NoParams;\n        \"minimised\": NoParams;\n        \"open\": NoParams;\n        \"popIn\": NoParams;\n        \"resize\": NoParams;\n        \"show\": NoParams;\n        /** @deprecated - use show instead */\n        \"shown\": NoParams;\n        \"stateChanged\": NoParams;\n        \"tab\": TabParam;\n        \"tabCreated\": TabParam;\n        \"titleChanged\": StringParam;\n        \"windowClosed\": PopoutParam;\n        \"windowOpened\": PopoutParam;\n        \"beforeComponentRelease\": BeforeComponentReleaseParams;\n        \"beforeItemDestroyed\": BubblingEventParam;\n        \"itemCreated\": BubblingEventParam;\n        \"itemDestroyed\": BubblingEventParam;\n        \"focus\": BubblingEventParam;\n        \"blur\": BubblingEventParam;\n        \"stackHeaderClick\": ClickBubblingEventParam;\n        \"stackHeaderTouchStart\": TouchStartBubblingEventParam;\n        \"userBroadcast\": UnknownParams;\n    }\n\n    export type UnknownParams = unknown[];\n    export type NoParams = [];\n    export type UnknownParam = [unknown];\n    export type PopoutParam = [BrowserPopout];\n    export type ComponentItemParam = [ComponentItem];\n    export type TabParam = [Tab];\n    export type BubblingEventParam = [EventEmitter.BubblingEvent]\n    export type StringParam = [string];\n    export type DragStartParams = [originalX: number, originalY: number];\n    export type DragStopParams = [event: PointerEvent | undefined];\n    export type DragParams = [offsetX: number, offsetY: number, event: PointerEvent];\n    export type BeforeComponentReleaseParams = [component: unknown];\n    export type ClickBubblingEventParam = [ClickBubblingEvent];\n    export type TouchStartBubblingEventParam = [TouchStartBubblingEvent];\n\n    export class BubblingEvent {\n        /** @internal */\n        private _isPropagationStopped = false;\n\n        get name(): string { return this._name; }\n        get target(): EventEmitter { return this._target; }\n        /** @deprecated Use {@link (EventEmitter:namespace).(BubblingEvent:class).target} instead */\n        get origin(): EventEmitter { return this._target; }\n        get isPropagationStopped(): boolean { return this._isPropagationStopped; }\n\n        /** @internal */\n        constructor(\n            /** @internal */\n            private readonly _name: string,\n            /** @internal */\n            private readonly _target: EventEmitter) {\n        }\n\n        stopPropagation(): void {\n            this._isPropagationStopped = true;\n        }\n    }\n\n    export class ClickBubblingEvent extends BubblingEvent {\n        get mouseEvent(): MouseEvent { return this._mouseEvent; }\n\n        /** @internal */\n        constructor(name: string, target: EventEmitter,\n            /** @internal */\n            private readonly _mouseEvent: MouseEvent\n        ) {\n            super(name, target);\n        }\n    }\n\n    export class TouchStartBubblingEvent extends BubblingEvent {\n        get touchEvent(): TouchEvent { return this._touchEvent; }\n\n        /** @internal */\n        constructor(name: string, target: EventEmitter,\n            /** @internal */\n            private readonly _touchEvent: TouchEvent\n        ) {\n            super(name, target);\n        }\n    }\n}\n", "import { ComponentItemConfig, ItemConfig } from '../config/config';\nimport { ResolvedComponentItemConfig } from '../config/resolved-config';\nimport { Tab } from '../controls/tab';\nimport { AssertError, UnexpectedNullError } from '../errors/internal-error';\nimport { ComponentItem } from '../items/component-item';\nimport { ContentItem } from '../items/content-item';\nimport { LayoutManager } from '../layout-manager';\nimport { EventEmitter } from '../utils/event-emitter';\nimport { JsonValue, LogicalZIndex, LogicalZIndexToDefaultMap } from '../utils/types';\nimport { deepExtend, setElementHeight, setElementWidth } from '../utils/utils';\n\n/** @public */\nexport class ComponentContainer extends EventEmitter {\n    /** @internal */\n    private _componentType: JsonValue;\n    /** @internal */\n    private _boundComponent: ComponentContainer.BindableComponent;\n    /** @internal */\n    private _width: number;\n    /** @internal */\n    private _height: number;\n    /** @internal */\n    private _isClosable;\n    /** @internal */\n    private _initialState: JsonValue | undefined;\n    /** @internal */\n    private _state: JsonValue | undefined;\n    /** @internal */\n    private _visible;\n    /** @internal */\n    private _isShownWithZeroDimensions;\n    /** @internal */\n    private _tab: Tab;\n    /** @internal */\n    private _stackMaximised = false;\n    /** @internal */\n    private _logicalZIndex: LogicalZIndex;\n\n    stateRequestEvent: ComponentContainer.StateRequestEventHandler | undefined;\n    virtualRectingRequiredEvent: ComponentContainer.VirtualRectingRequiredEvent | undefined;\n    virtualVisibilityChangeRequiredEvent: ComponentContainer.VirtualVisibilityChangeRequiredEvent | undefined;\n    virtualZIndexChangeRequiredEvent: ComponentContainer.VirtualZIndexChangeRequiredEvent | undefined;\n\n    get width(): number { return this._width; }\n    get height(): number { return this._height; }\n    get parent(): ComponentItem { return this._parent; }\n    /** @internal @deprecated use {@link (ComponentContainer:class).componentType} */\n    get componentName(): JsonValue { return this._componentType; }\n    get componentType(): JsonValue { return this._componentType; }\n    get virtual(): boolean { return this._boundComponent.virtual; }\n    get component(): ComponentContainer.Component { return this._boundComponent.component; }\n    get tab(): Tab { return this._tab; }\n    get title(): string { return this._parent.title; }\n    get layoutManager(): LayoutManager { return this._layoutManager; }\n    get isHidden(): boolean { return !this._visible; }\n    get visible(): boolean { return this._visible; }\n    get state(): JsonValue | undefined { return this._state; }\n    /** Return the initial component state */\n    get initialState(): JsonValue | undefined { return this._initialState; }\n    /** The inner DOM element where the container's content is intended to live in */\n    get element(): HTMLElement { return this._element; }\n\n    /** @internal */\n    constructor(\n        /** @internal */\n        private readonly _config: ResolvedComponentItemConfig,\n        /** @internal */\n        private readonly _parent: ComponentItem,\n        /** @internal */\n        private readonly _layoutManager: LayoutManager,\n        /** @internal */\n        private readonly _element: HTMLElement,\n        /** @internal */\n        private readonly _updateItemConfigEvent: ComponentContainer.UpdateItemConfigEventHandler,\n        /** @internal */\n        private readonly _showEvent: ComponentContainer.ShowEventHandler,\n        /** @internal */\n        private readonly _hideEvent: ComponentContainer.HideEventHandler,\n        /** @internal */\n        private readonly _focusEvent: ComponentContainer.FocusEventHandler,\n        /** @internal */\n        private readonly _blurEvent: ComponentContainer.BlurEventHandler,\n    ) {\n        super();\n\n        this._width = 0;\n        this._height = 0;\n        this._visible = true;\n        this._isShownWithZeroDimensions = true;\n\n        this._componentType = _config.componentType;\n        this._isClosable = _config.isClosable;\n        this._initialState = _config.componentState;\n        this._state = this._initialState;\n\n        this._boundComponent = this.layoutManager.bindComponent(this, _config);\n\n        this.updateElementPositionPropertyFromBoundComponent();\n    }\n\n    /** @internal */\n    destroy(): void {\n        this.releaseComponent();\n        this.stateRequestEvent = undefined;\n        this.emit('destroy');\n    }\n\n    /** @deprecated use {@link (ComponentContainer:class).element } */\n    getElement(): HTMLElement {\n        return this._element;\n    }\n\n    /**\n     * Hides the container's component item (and hence, the container) if not already hidden.\n     * Emits hide event prior to hiding the container.\n     */\n    hide(): void {\n        this._hideEvent();\n    }\n\n    /**\n     * Shows the container's component item (and hence, the container) if not visible.\n     * Emits show event prior to hiding the container.\n     */\n    show(): void {\n        this._showEvent();\n    }\n\n    /**\n     * Focus this component in Layout.\n     */\n    focus(suppressEvent = false): void {\n        this._focusEvent(suppressEvent);\n    }\n\n    /**\n     * Remove focus from this component in Layout.\n     */\n    blur(suppressEvent = false): void {\n        this._blurEvent(suppressEvent);\n    }\n\n    /**\n     * Set the size from within the container. Traverses up\n     * the item tree until it finds a row or column element\n     * and resizes its items accordingly.\n     *\n     * If this container isn't a descendant of a row or column\n     * it returns false\n     * @param width - The new width in pixel\n     * @param height - The new height in pixel\n     *\n     * @returns resizeSuccesful\n     *\n     * @internal\n     */\n    setSize(width: number, height: number): boolean {\n        let ancestorItem: ContentItem | null = this._parent;\n        if (ancestorItem.isColumn || ancestorItem.isRow || ancestorItem.parent === null) {\n            throw new AssertError('ICSSPRC', 'ComponentContainer cannot have RowColumn Parent');\n        } else {\n            let ancestorChildItem: ContentItem;\n            do {\n                ancestorChildItem = ancestorItem;\n                ancestorItem = ancestorItem.parent;\n            } while (ancestorItem !== null && !ancestorItem.isColumn && !ancestorItem.isRow);\n\n            if (ancestorItem === null) {\n                // no Row or Column found\n                return false;\n            } else {\n                // ancestorItem is Row or Column\n                const direction = ancestorItem.isColumn ? 'height' : 'width';\n                const currentSize = this[direction];\n                if (currentSize === null) {\n                    throw new UnexpectedNullError('ICSSCS11194');\n                } else {\n                    const newSize = direction === 'height' ? height : width;\n\n                    const totalPixel = currentSize * (1 / (ancestorChildItem.size / 100));\n                    const percentage = (newSize / totalPixel) * 100;\n                    const delta = (ancestorChildItem.size - percentage) / (ancestorItem.contentItems.length - 1);\n\n                    for (let i = 0; i < ancestorItem.contentItems.length; i++) {\n                        const ancestorItemContentItem = ancestorItem.contentItems[i];\n                        if (ancestorItemContentItem === ancestorChildItem) {\n                            ancestorItemContentItem.size = percentage;\n                        } else {\n                            ancestorItemContentItem.size += delta;\n                        }\n                    }\n\n                    ancestorItem.updateSize(false);\n\n                    return true;\n                }\n            }\n        }\n    }\n\n    /**\n     * Closes the container if it is closable. Can be called by\n     * both the component within at as well as the contentItem containing\n     * it. Emits a close event before the container itself is closed.\n     */\n    close(): void {\n        if (this._isClosable) {\n            this.emit('close');\n            this._parent.close();\n        }\n    }\n\n    /** Replaces component without affecting layout */\n    replaceComponent(itemConfig: ComponentItemConfig): void {\n        this.releaseComponent();\n\n        if (!ItemConfig.isComponent(itemConfig)) {\n            throw new Error('ReplaceComponent not passed a component ItemConfig')\n        } else {\n            const config = ComponentItemConfig.resolve(itemConfig, false);\n            this._initialState = config.componentState;\n            this._state = this._initialState;\n            this._componentType = config.componentType;\n\n            this._updateItemConfigEvent(config);\n\n            this._boundComponent = this.layoutManager.bindComponent(this, config);\n            this.updateElementPositionPropertyFromBoundComponent();\n\n            if (this._boundComponent.virtual) {\n                if (this.virtualVisibilityChangeRequiredEvent !== undefined) {\n                    this.virtualVisibilityChangeRequiredEvent(this, this._visible);\n                }\n                if (this.virtualRectingRequiredEvent !== undefined) {\n                    this._layoutManager.fireBeforeVirtualRectingEvent(1);\n                    try {\n                        this.virtualRectingRequiredEvent(this, this._width, this._height);\n                    } finally {\n                        this._layoutManager.fireAfterVirtualRectingEvent();\n                    }\n                }\n                this.setBaseLogicalZIndex();\n            }\n\n            this.emit('stateChanged');\n        }\n    }\n\n    /**\n     * Returns the initial component state or the latest passed in setState()\n     * @returns state\n     * @deprecated Use {@link (ComponentContainer:class).initialState}\n     */\n    getState(): JsonValue | undefined {\n        return this._state;\n    }\n\n    /**\n     * Merges the provided state into the current one\n     * @deprecated Use {@link (ComponentContainer:class).stateRequestEvent}\n     */\n    extendState(state: Record<string, unknown>): void {\n        const extendedState = deepExtend(this._state as Record<string, unknown>, state);\n        this.setState(extendedState as JsonValue);\n    }\n\n    /**\n     * Sets the component state\n     * @deprecated Use {@link (ComponentContainer:class).stateRequestEvent}\n     */\n    setState(state: JsonValue): void {\n        this._state = state;\n        this._parent.emitBaseBubblingEvent('stateChanged');\n    }\n\n    /**\n     * Set's the components title\n     */\n    setTitle(title: string): void {\n        this._parent.setTitle(title);\n    }\n\n    /** @internal */\n    setTab(tab: Tab): void {\n        this._tab = tab;\n        this.emit('tab', tab)\n    }\n\n    /** @internal */\n    setVisibility(value: boolean): void {\n        if (this._boundComponent.virtual) {\n            if (this.virtualVisibilityChangeRequiredEvent !== undefined) {\n                this.virtualVisibilityChangeRequiredEvent(this, value);\n            }\n        }\n\n        if (value) {\n            if (!this._visible) {\n                this._visible = true;\n                if (this._height === 0 && this._width === 0) {\n                    this._isShownWithZeroDimensions = true;\n                } else {\n                    this._isShownWithZeroDimensions = false;\n                    this.setSizeToNodeSize(this._width, this._height, true);\n                    this.emitShow();\n                }\n            } else {\n                if (this._isShownWithZeroDimensions && (this._height !== 0 || this._width !== 0)) {\n                    this._isShownWithZeroDimensions = false;\n                    this.setSizeToNodeSize(this._width, this._height, true);\n                    this.emitShow();\n                }\n            }\n        } else {\n            if (this._visible) {\n                this._visible = false;\n                this._isShownWithZeroDimensions = false;\n                this.emitHide();\n            }\n        }\n    }\n\n    setBaseLogicalZIndex(): void {\n        this.setLogicalZIndex(LogicalZIndex.base);\n    }\n\n    setLogicalZIndex(logicalZIndex: LogicalZIndex): void {\n        if (logicalZIndex !== this._logicalZIndex) {\n            this._logicalZIndex = logicalZIndex;\n\n            this.notifyVirtualZIndexChangeRequired();\n        }\n    }\n\n    /**\n     * Set the container's size, but considered temporary (for dragging)\n     * so don't emit any events.\n     * @internal\n     */\n    enterDragMode(width: number, height: number): void {\n        this._width = width;\n        this._height = height;\n        setElementWidth(this._element, width);\n        setElementHeight(this._element, height);\n\n        this.setLogicalZIndex(LogicalZIndex.drag);\n\n        this.drag();\n    }\n\n    /** @internal */\n    exitDragMode(): void {\n        this.setBaseLogicalZIndex();\n    }\n\n    /** @internal */\n    enterStackMaximised(): void {\n        this._stackMaximised = true;\n        this.setLogicalZIndex(LogicalZIndex.stackMaximised);\n    }\n\n    /** @internal */\n    exitStackMaximised(): void {\n        this.setBaseLogicalZIndex();\n        this._stackMaximised = false;\n    }\n\n    /** @internal */\n    drag(): void {\n        if (this._boundComponent.virtual) {\n            if (this.virtualRectingRequiredEvent !== undefined) {\n                this._layoutManager.fireBeforeVirtualRectingEvent(1);\n                try {\n                    this.virtualRectingRequiredEvent(this, this._width, this._height);\n                } finally {\n                    this._layoutManager.fireAfterVirtualRectingEvent();\n                }\n            }\n        }\n    }\n\n    /**\n     * Sets the container's size. Called by the container's component item.\n     * To instead set the size programmatically from within the component itself,\n     * use the public setSize method\n     * @param width - in px\n     * @param height - in px\n     * @param force - set even if no change\n     * @internal\n     */\n    setSizeToNodeSize(width: number, height: number, force: boolean): void {\n        if (width !== this._width || height !== this._height || force) {\n            this._width = width;\n            this._height = height;\n            setElementWidth(this._element, width);\n            setElementHeight(this._element, height);\n\n            if (this._boundComponent.virtual) {\n                this.addVirtualSizedContainerToLayoutManager();\n            } else {\n                this.emit('resize');\n                this.checkShownFromZeroDimensions();\n            }\n        }\n    }\n\n    /** @internal */\n    notifyVirtualRectingRequired(): void {\n        if (this.virtualRectingRequiredEvent !== undefined) {\n            this.virtualRectingRequiredEvent(this, this._width, this._height);\n            this.emit('resize');\n            this.checkShownFromZeroDimensions();\n        }\n    }\n\n    /** @internal */\n    private notifyVirtualZIndexChangeRequired(): void {\n        if (this.virtualZIndexChangeRequiredEvent !== undefined) {\n            const logicalZIndex = this._logicalZIndex;\n            const defaultZIndex = LogicalZIndexToDefaultMap[logicalZIndex];\n            this.virtualZIndexChangeRequiredEvent(this, logicalZIndex, defaultZIndex);\n        }\n    }\n\n    /** @internal */\n    private updateElementPositionPropertyFromBoundComponent() {\n        if (this._boundComponent.virtual) {\n            this._element.style.position = 'static';\n        } else {\n            this._element.style.position = ''; // set it back to attribute value\n        }\n    }\n\n    /** @internal */\n    private addVirtualSizedContainerToLayoutManager() {\n        this._layoutManager.beginVirtualSizedContainerAdding();\n        try {\n            this._layoutManager.addVirtualSizedContainer(this);\n        } finally {\n            this._layoutManager.endVirtualSizedContainerAdding();\n        }\n    }\n\n    /** @internal */\n    private checkShownFromZeroDimensions() {\n        if (this._isShownWithZeroDimensions && (this._height !== 0 || this._width !== 0)) {\n            this._isShownWithZeroDimensions = false;\n            this.emitShow();\n        }\n    }\n\n    /** @internal */\n    private emitShow(): void {\n        this.emit('shown');\n        this.emit('show');\n    }\n\n    /** @internal */\n    private emitHide(): void {\n        this.emit('hide');\n    }\n\n    /** @internal */\n    private releaseComponent() {\n        if (this._stackMaximised) {\n            this.exitStackMaximised();\n        }\n        this.emit('beforeComponentRelease', this._boundComponent.component);\n        this.layoutManager.unbindComponent(this, this._boundComponent.virtual, this._boundComponent.component);\n    }\n}\n\n/** @public @deprecated use {@link ComponentContainer} */\nexport type ItemContainer = ComponentContainer;\n\n/** @public */\nexport namespace ComponentContainer {\n    export type Component = unknown;\n\n    export interface BindableComponent {\n        component: Component;\n        virtual: boolean;\n    }\n\n    export type StateRequestEventHandler = (this: void) => JsonValue | undefined;\n    export type VirtualRectingRequiredEvent = (this: void, container: ComponentContainer, width: number, height: number) => void;\n    export type VirtualVisibilityChangeRequiredEvent = (this: void, container: ComponentContainer, visible: boolean) => void;\n    export type VirtualZIndexChangeRequiredEvent =\n        (this: void, container: ComponentContainer, logicalZIndex: LogicalZIndex, defaultZIndex: string) => void;\n    /** @internal */\n    export type ShowEventHandler = (this: void) => void;\n    /** @internal */\n    export type HideEventHandler = (this: void) => void;\n    /** @internal */\n    export type FocusEventHandler = (this: void, suppressEvent: boolean) => void;\n    /** @internal */\n    export type BlurEventHandler = (this: void, suppressEvent: boolean) => void;\n    /** @internal */\n    export type UpdateItemConfigEventHandler = (itemConfig: ResolvedComponentItemConfig) => void;\n}\n", "import { ResolvedLayoutConfig, ResolvedPopoutLayoutConfig } from '../config/resolved-config';\nimport { PopoutBlockedError } from '../errors/external-error';\nimport { UnexpectedNullError, UnexpectedUndefinedError } from '../errors/internal-error';\nimport { ContentItem } from '../items/content-item';\nimport { LayoutManager } from '../layout-manager';\nimport { EventEmitter } from '../utils/event-emitter';\nimport { Rect } from '../utils/types';\nimport { deepExtend, getErrorMessage, getUniqueId } from '../utils/utils';\n\n/**\n * Pops a content item out into a new browser window.\n * This is achieved by\n *\n *    - Creating a new configuration with the content item as root element\n *    - Serializing and minifying the configuration\n *    - Opening the current window's URL with the configuration as a GET parameter\n *    - GoldenLayout when opened in the new window will look for the GET parameter\n *      and use it instead of the provided configuration\n * @public\n */\n\nexport class BrowserPopout extends EventEmitter {\n    /** @internal */\n    private _popoutWindow: Window | null;\n    /** @internal */\n    private _isInitialised;\n    /** @internal */\n    private _checkReadyInterval: ReturnType<typeof setTimeout> | undefined;\n\n    /**\n     * @param _config - GoldenLayout item config\n     * @param _initialWindowSize - A map with width, height, top and left\n     * @internal\n     */\n    constructor(\n        /** @internal */\n        private _config: ResolvedPopoutLayoutConfig,\n        /** @internal */\n        private _initialWindowSize: Rect,\n        /** @internal */\n        private _layoutManager: LayoutManager,\n    ) {\n        super();\n\n        this._isInitialised = false;\n        this._popoutWindow = null;\n        this.createWindow();\n    }\n\n    toConfig(): ResolvedPopoutLayoutConfig {\n        if (this._isInitialised === false) {\n            throw new Error('Can\\'t create config, layout not yet initialised');\n        }\n\n        const glInstance = this.getGlInstance();\n        const glInstanceConfig = glInstance.saveLayout();\n\n        let left: number | null;\n        let top: number | null;\n        if (this._popoutWindow === null) {\n            left = null;\n            top = null;\n        } else {\n            left = this._popoutWindow.screenX ?? this._popoutWindow.screenLeft;\n            top = this._popoutWindow.screenY ?? this._popoutWindow.screenTop;\n        }\n\n        const window: ResolvedPopoutLayoutConfig.Window = {\n            width: this.getGlInstance().width,\n            height: this.getGlInstance().height,\n            left,\n            top,\n        };\n\n        const config: ResolvedPopoutLayoutConfig = {\n            root: glInstanceConfig.root,\n            openPopouts: glInstanceConfig.openPopouts,\n            settings: glInstanceConfig.settings,\n            dimensions: glInstanceConfig.dimensions,\n            header: glInstanceConfig.header,\n            window,\n            parentId: this._config.parentId,\n            indexInParent: this._config.indexInParent,\n            resolved: true,\n        };\n\n        return config;\n    }\n\n    getGlInstance(): LayoutManager {\n        if (this._popoutWindow === null) {\n            throw new UnexpectedNullError('BPGGI24693');\n        }\n        return this._popoutWindow.__glInstance;\n    }\n\n    /**\n     * Retrieves the native BrowserWindow backing this popout.\n     * Might throw an UnexpectedNullError exception when the window is not initialized yet.\n     * @public\n     */\n    getWindow(): Window {\n        if (this._popoutWindow === null) {\n            throw new UnexpectedNullError('BPGW087215');\n        }\n        return this._popoutWindow;\n    }\n\n    close(): void {\n        if (this.getGlInstance()) {\n            this.getGlInstance().closeWindow();\n        } else {\n            try {\n                this.getWindow().close();\n            } catch (e) {\n                //\n            }\n        }\n    }\n\n    /**\n     * Returns the popped out item to its original position. If the original\n     * parent isn't available anymore it falls back to the layout's topmost element\n     */\n    popIn(): void {\n        let parentItem: ContentItem;\n        let index = this._config.indexInParent;\n\n        if (!this._config.parentId) {\n            return;\n        }\n\n        /*\n        * The deepExtend call seems a bit pointless, but it's crucial to\n        * copy the config returned by this.getGlInstance().toConfig()\n        * onto a new object. Internet Explorer keeps the references\n        * to objects on the child window, resulting in the following error\n        * once the child window is closed:\n        *\n        * The callee (server [not server application]) is not available and disappeared\n        */\n        const glInstanceLayoutConfig = this.getGlInstance().saveLayout();\n        const copiedGlInstanceLayoutConfig = deepExtend({}, glInstanceLayoutConfig) as ResolvedLayoutConfig;\n        const copiedRoot = copiedGlInstanceLayoutConfig.root;\n        if (copiedRoot === undefined) {\n            throw new UnexpectedUndefinedError('BPPIR19998');\n        }\n        const groundItem = this._layoutManager.groundItem;\n        if (groundItem === undefined) {\n            throw new UnexpectedUndefinedError('BPPIG34972');\n        }\n        parentItem = groundItem.getItemsByPopInParentId(this._config.parentId)[0];\n\n        /*\n        * Fallback if parentItem is not available. Either add it to the topmost\n        * item or make it the topmost item if the layout is empty\n        */\n        if (!parentItem) {\n            if (groundItem.contentItems.length > 0) {\n                parentItem = groundItem.contentItems[0];\n            } else {\n                parentItem = groundItem;\n            }\n            index = 0;\n        }\n\n        const newContentItem = this._layoutManager.createAndInitContentItem(copiedRoot, parentItem);\n\n        parentItem.addChild(newContentItem, index);\n        if (this._layoutManager.layoutConfig.settings.popInOnClose) {\n            this._onClose();\n        } else {\n            this.close();\n        }\n    }\n\n    /**\n     * Creates the URL and window parameter\n     * and opens a new window\n     * @internal\n     */\n    private createWindow(): void {\n        const url = this.createUrl();\n\n        /**\n         * Bogus title to prevent re-usage of existing window with the\n         * same title. The actual title will be set by the new window's\n         * GoldenLayout instance if it detects that it is in subWindowMode\n         */\n        const target = Math.floor(Math.random() * 1000000).toString(36);\n\n        /**\n         * The options as used in the window.open string\n         */\n        const features = this.serializeWindowFeatures({\n            width: this._initialWindowSize.width,\n            height: this._initialWindowSize.height,\n            innerWidth: this._initialWindowSize.width,\n            innerHeight: this._initialWindowSize.height,\n            menubar: 'no',\n            toolbar: 'no',\n            location: 'no',\n            personalbar: 'no',\n            resizable: 'yes',\n            scrollbars: 'no',\n            status: 'no'\n        });\n\n        this._popoutWindow = globalThis.open(url, target, features);\n\n        if (!this._popoutWindow) {\n            if (this._layoutManager.layoutConfig.settings.blockedPopoutsThrowError === true) {\n                const error = new PopoutBlockedError('Popout blocked');\n                throw error;\n            } else {\n                return;\n            }\n        }\n\n        this._popoutWindow.addEventListener('load', () => this.positionWindow(), { passive: true })\n        this._popoutWindow.addEventListener('beforeunload', () => {\n            if (this._layoutManager.layoutConfig.settings.popInOnClose) {\n                this.popIn();\n            } else {\n                this._onClose();\n            }\n        }, { passive: true })\n\n        /**\n         * Polling the childwindow to find out if GoldenLayout has been initialised\n         * doesn't seem optimal, but the alternatives - adding a callback to the parent\n         * window or raising an event on the window object - both would introduce knowledge\n         * about the parent to the child window which we'd rather avoid\n         */\n        this._checkReadyInterval = setInterval(() => this.checkReady(), 10);\n    }\n\n    /** @internal */\n    private checkReady() {\n        if (this._popoutWindow === null) {\n            throw new UnexpectedNullError('BPCR01844');\n        } else {\n            if (this._popoutWindow.__glInstance && this._popoutWindow.__glInstance.isInitialised) {\n                this.onInitialised();\n                if (this._checkReadyInterval !== undefined) {\n                    clearInterval(this._checkReadyInterval);\n                    this._checkReadyInterval = undefined;\n                }\n            }\n        }\n    }\n\n    /**\n     * Serialises a map of key:values to a window options string\n     *\n     * @param windowOptions -\n     *\n     * @returns serialised window options\n     * @internal\n     */\n    private serializeWindowFeatures(windowOptions: Record<string, string | number>): string {\n        const windowOptionsString: string[] = [];\n\n        for (const key in windowOptions) {\n            windowOptionsString.push(key + '=' + windowOptions[key].toString());\n        }\n\n        return windowOptionsString.join(',');\n    }\n\n    /**\n     * Creates the URL for the new window, including the\n     * config GET parameter\n     *\n     * @returns URL\n     * @internal\n     */\n    private createUrl(): string {\n        const storageKey = 'gl-window-config-' + getUniqueId();\n        const config = ResolvedLayoutConfig.minifyConfig(this._config);\n\n        try {\n            localStorage.setItem(storageKey, JSON.stringify(config));\n        } catch (e) {\n            throw new Error('Error while writing to localStorage ' + getErrorMessage(e));\n        }\n\n        const url = new URL(location.href);\n        url.searchParams.set('gl-window', storageKey);\n        return url.toString();\n    }\n\n    /**\n     * Move the newly created window roughly to\n     * where the component used to be.\n     * @internal\n     */\n    private positionWindow() {\n        if (this._popoutWindow === null) {\n            throw new Error('BrowserPopout.positionWindow: null popoutWindow');\n        } else {\n            this._popoutWindow.moveTo(this._initialWindowSize.left, this._initialWindowSize.top);\n            this._popoutWindow.focus();\n        }\n    }\n\n    /**\n     * Callback when the new window is opened and the GoldenLayout instance\n     * within it is initialised\n     * @internal\n     */\n    private onInitialised(): void {\n        this._isInitialised = true;\n        this.getGlInstance().on('popIn', () => this.popIn());\n        this.emit('initialised');\n    }\n\n    /**\n     * Invoked 50ms after the window unload event\n     * @internal\n     */\n    private _onClose() {\n        setTimeout(() => this.emit('closed'), 50);\n    }\n}\n", "import { ResolvedItemConfig } from '../config/resolved-config'\nimport { BrowserPopout } from '../controls/browser-popout'\nimport { AssertError, UnexpectedNullError } from '../errors/internal-error'\nimport { LayoutManager } from '../layout-manager'\nimport { EventEmitter } from '../utils/event-emitter'\nimport { AreaLinkedRect, ItemType, SizeUnitEnum } from '../utils/types'\nimport { getUniqueId, setElementDisplayVisibility } from '../utils/utils'\nimport { ComponentItem } from './component-item'\nimport { ComponentParentableItem } from './component-parentable-item'\nimport { Stack } from './stack'\n\n/**\n * This is the baseclass that all content items inherit from.\n * Most methods provide a subset of what the sub-classes do.\n *\n * It also provides a number of functions for tree traversal\n * @public\n */\n\nexport abstract class ContentItem extends EventEmitter {\n    /** @internal */\n    private _type: ItemType;\n    /** @internal */\n    private _id: string;\n    /** @internal */\n    private _popInParentIds: string[] = [];\n    /** @internal */\n    private _contentItems: ContentItem[];\n    /** @internal */\n    private _isClosable;\n    /** @internal */\n    private _pendingEventPropagations: Record<string, unknown>;\n    /** @internal */\n    private _throttledEvents: string[];\n    /** @internal */\n    private _isInitialised;\n\n    /** @internal */\n    size: number;\n    /** @internal */\n    sizeUnit: SizeUnitEnum;\n    /** @internal */\n    minSize: number | undefined;\n    /** @internal */\n    minSizeUnit: SizeUnitEnum;\n\n    isGround: boolean\n    isRow: boolean\n    isColumn: boolean\n    isStack: boolean\n    isComponent: boolean\n\n    get type(): ItemType { return this._type; }\n    get id(): string { return this._id; }\n    set id(value: string) { this._id = value; }\n    /** @internal */\n    get popInParentIds(): string[] { return this._popInParentIds; }\n    get parent(): ContentItem | null { return this._parent; }\n    get contentItems(): ContentItem[] { return this._contentItems; }\n    get isClosable(): boolean { return this._isClosable; }\n    get element(): HTMLElement { return this._element; }\n    get isInitialised(): boolean { return this._isInitialised; }\n\n    static isStack(item: ContentItem): item is Stack {\n        return item.isStack;\n    }\n\n    static isComponentItem(item: ContentItem): item is ComponentItem {\n        return item.isComponent;\n    }\n\n    static isComponentParentableItem(item: ContentItem): item is ComponentParentableItem {\n        return item.isStack || item.isGround;\n    }\n\n    /** @internal */\n    constructor(public readonly layoutManager: LayoutManager,\n        config: ResolvedItemConfig,\n        /** @internal */\n        private _parent: ContentItem | null,\n        /** @internal */\n        private readonly _element: HTMLElement\n    ) {\n        super();\n\n        this._type = config.type;\n        this._id = config.id;\n\n        this._isInitialised = false;\n        this.isGround = false;\n        this.isRow = false;\n        this.isColumn = false;\n        this.isStack = false;\n        this.isComponent = false;\n\n        this.size = config.size;\n        this.sizeUnit = config.sizeUnit;\n        this.minSize = config.minSize;\n        this.minSizeUnit = config.minSizeUnit;\n\n        this._isClosable = config.isClosable;\n\n        this._pendingEventPropagations = {};\n        this._throttledEvents = ['stateChanged'];\n\n        this._contentItems = this.createContentItems(config.content);\n    }\n\n    /**\n     * Updaters the size of the component and its children, called recursively\n     * @param force - In some cases the size is not updated if it has not changed. In this case, events\n     * (such as ComponentContainer.virtualRectingRequiredEvent) are not fired. Setting force to true, ensures the size is updated regardless, and\n     * the respective events are fired. This is sometimes necessary when a component's size has not changed but it has become visible, and the\n     * relevant events need to be fired.\n     * @internal\n     */\n    abstract updateSize(force: boolean): void;\n\n    /**\n     * Removes a child node (and its children) from the tree\n     * @param contentItem - The child item to remove\n     * @param keepChild - Whether to destroy the removed item\n     */\n    removeChild(contentItem: ContentItem, keepChild = false): void {\n        /*\n         * Get the position of the item that's to be removed within all content items this node contains\n         */\n        const index = this._contentItems.indexOf(contentItem);\n\n        /*\n         * Make sure the content item to be removed is actually a child of this item\n         */\n        if (index === -1) {\n            throw new Error('Can\\'t remove child item. Unknown content item');\n        }\n\n        /**\n\t\t * Call destroy on the content item.\n\t\t * All children are destroyed as well\n\t\t */\n        if (!keepChild) {\n\t\t\tthis._contentItems[index].destroy();\n        }\n\n        /**\n         * Remove the content item from this nodes array of children\n         */\n        this._contentItems.splice(index, 1);\n\n        /**\n         * If this node still contains other content items, adjust their size\n         */\n        if (this._contentItems.length > 0) {\n            this.updateSize(false);\n        } else {\n            /**\n             * If this was the last content item, remove this node as well\n             */\n            if (!this.isGround && this._isClosable === true) {\n                if (this._parent === null) {\n                    throw new UnexpectedNullError('CIUC00874');\n                } else {\n                    this._parent.removeChild(this);\n                }\n            }\n        }\n    }\n\n    /**\n     * Sets up the tree structure for the newly added child\n     * The responsibility for the actual DOM manipulations lies\n     * with the concrete item\n     *\n     * @param contentItem -\n     * @param index - If omitted item will be appended\n     * @param suspendResize - Used by descendent implementations\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    addChild(contentItem: ContentItem, index?: number | null, suspendResize?: boolean): number {\n        index ??= this._contentItems.length;\n\n        this._contentItems.splice(index, 0, contentItem);\n        contentItem.setParent(this);\n\n        if (this._isInitialised === true && contentItem._isInitialised === false) {\n            contentItem.init();\n        }\n\n        return index;\n    }\n\n    /**\n     * Replaces oldChild with newChild\n     * @param oldChild -\n     * @param newChild -\n     * @internal\n     */\n    replaceChild(oldChild: ContentItem, newChild: ContentItem, destroyOldChild = false): void {\n        // Do not try to replace ComponentItem - will not work\n        const index = this._contentItems.indexOf(oldChild);\n        const parentNode = oldChild._element.parentNode;\n\n        if (index === -1) {\n            throw new AssertError('CIRCI23232', 'Can\\'t replace child. oldChild is not child of this');\n        }\n\n        if (parentNode === null) {\n            throw new UnexpectedNullError('CIRCP23232');\n        } else {\n            parentNode.replaceChild(newChild._element, oldChild._element);\n\n            /*\n            * Optionally destroy the old content item\n            */\n            if (destroyOldChild === true) {\n                oldChild._parent = null;\n                oldChild.destroy(); // will now also destroy all children of oldChild\n            }\n\n            /*\n            * Wire the new contentItem into the tree\n            */\n            this._contentItems[index] = newChild;\n            newChild.setParent(this);\n            // newChild inherits the sizes from the old child:\n            newChild.size = oldChild.size;\n            newChild.sizeUnit = oldChild.sizeUnit;\n            newChild.minSize = oldChild.minSize;\n            newChild.minSizeUnit = oldChild.minSizeUnit;\n\n            //TODO This doesn't update the config... refactor to leave item nodes untouched after creation\n            if (newChild._parent === null) {\n                throw new UnexpectedNullError('CIRCNC45699');\n            } else {\n                if (newChild._parent._isInitialised === true && newChild._isInitialised === false) {\n                    newChild.init();\n                }\n\n                this.updateSize(false);\n            }\n        }\n    }\n\n    /**\n     * Convenience method.\n     * Shorthand for this.parent.removeChild( this )\n     */\n    remove(): void {\n        if (this._parent === null) {\n            throw new UnexpectedNullError('CIR11110');\n        } else {\n            this._parent.removeChild(this);\n        }\n    }\n\n    /**\n     * Removes the component from the layout and creates a new\n     * browser window with the component and its children inside\n     */\n    popout(): BrowserPopout {\n        const parentId = getUniqueId();\n        const browserPopout = this.layoutManager.createPopoutFromContentItem(this, undefined, parentId, undefined);\n        this.emitBaseBubblingEvent('stateChanged');\n        return browserPopout;\n    }\n\n    abstract toConfig(): ResolvedItemConfig;\n\n    /** @internal */\n    calculateConfigContent(): ResolvedItemConfig[] {\n        const contentItems = this._contentItems;\n        const count = contentItems.length;\n        const result = new Array<ResolvedItemConfig>(count);\n        for (let i = 0; i < count; i++) {\n            const item = contentItems[i];\n            result[i] = item.toConfig();\n        }\n        return result;\n    }\n\n    /** @internal */\n    highlightDropZone(x: number, y: number, area: AreaLinkedRect): void {\n        const dropTargetIndicator = this.layoutManager.dropTargetIndicator;\n        if (dropTargetIndicator === null) {\n            throw new UnexpectedNullError('ACIHDZ5593');\n        } else {\n            dropTargetIndicator.highlightArea(area, 1);\n        }\n    }\n\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onDrop(contentItem: ContentItem, area: ContentItem.Area): void {\n        this.addChild(contentItem);\n    }\n\n    /** @internal */\n    show(): void {\n        this.layoutManager.beginSizeInvalidation();\n        try {\n            // Not sure why showAllActiveContentItems() was called. GoldenLayout seems to work fine without it.  Left commented code\n            // in source in case a reason for it becomes apparent.\n            // this.layoutManager.showAllActiveContentItems();\n            setElementDisplayVisibility(this._element, true);\n            // this.layoutManager.updateSizeFromContainer();\n\n            for (let i = 0; i < this._contentItems.length; i++) {\n                this._contentItems[i].show();\n            }\n        } finally {\n            this.layoutManager.endSizeInvalidation();\n        }\n    }\n\n    /**\n     * Destroys this item ands its children\n     * @internal\n     */\n    destroy(): void {\n        for (let i = 0; i < this._contentItems.length; i++) {\n            this._contentItems[i].destroy();\n        }\n        this._contentItems = [];\n\n        this.emitBaseBubblingEvent('beforeItemDestroyed');\n        this._element.remove();\n        this.emitBaseBubblingEvent('itemDestroyed');\n    }\n\n    /**\n     * Returns the area the component currently occupies\n     * @internal\n     */\n    getElementArea(element?: HTMLElement): ContentItem.Area | null {\n        element = element ?? this._element;\n\n        const rect = element.getBoundingClientRect();\n        const top = rect.top + document.body.scrollTop;\n        const left = rect.left + document.body.scrollLeft;\n\n        const width = rect.width;\n        const height = rect.height;\n\n        return {\n            x1: left,\n            y1: top,\n            x2: left + width,\n            y2: top + height,\n            surface: width * height,\n            contentItem: this\n        };\n    }\n\n    /**\n     * The tree of content items is created in two steps: First all content items are instantiated,\n     * then init is called recursively from top to bottem. This is the basic init function,\n     * it can be used, extended or overwritten by the content items\n     *\n     * Its behaviour depends on the content item\n     * @internal\n     */\n    init(): void {\n        this._isInitialised = true;\n        this.emitBaseBubblingEvent('itemCreated');\n        this.emitUnknownBubblingEvent(this.type + 'Created');\n    }\n\n    /** @internal */\n    protected setParent(parent: ContentItem): void {\n        this._parent = parent;\n    }\n\n    /** @internal */\n    addPopInParentId(id: string): void {\n        if (!this.popInParentIds.includes(id)) {\n            this.popInParentIds.push(id);\n        }\n    }\n\n    /** @internal */\n    protected initContentItems(): void {\n        for (let i = 0; i < this._contentItems.length; i++) {\n            this._contentItems[i].init();\n        }\n    }\n\n    /** @internal */\n    protected hide(): void {\n        this.layoutManager.beginSizeInvalidation();\n        try {\n            setElementDisplayVisibility(this._element, false);\n            // this.layoutManager.updateSizeFromContainer();\n        } finally {\n            this.layoutManager.endSizeInvalidation();\n        }\n    }\n\n    /** @internal */\n    protected updateContentItemsSize(force: boolean): void {\n        for (let i = 0; i < this._contentItems.length; i++) {\n            this._contentItems[i].updateSize(force);\n        }\n    }\n\n    /**\n     * creates all content items for this node at initialisation time\n     * PLEASE NOTE, please see addChild for adding contentItems at runtime\n     * @internal\n     */\n    private createContentItems(content: readonly ResolvedItemConfig[]) {\n        const count = content.length;\n        const result = new Array<ContentItem>(count);\n        for (let i = 0; i < content.length; i++) {\n            result[i] = this.layoutManager.createContentItem(content[i], this);\n        }\n        return result;\n    }\n\n    /**\n     * Called for every event on the item tree. Decides whether the event is a bubbling\n     * event and propagates it to its parent\n     *\n     * @param name - The name of the event\n     * @param event -\n     * @internal\n     */\n    private propagateEvent(name: string, args: unknown[]) {\n        if (args.length === 1) {\n            const event = args[0];\n            if (event instanceof EventEmitter.BubblingEvent &&\n                event.isPropagationStopped === false &&\n                this._isInitialised === true) {\n\n                /**\n                 * In some cases (e.g. if an element is created from a DragSource) it\n                 * doesn't have a parent and is not a child of GroundItem. If that's the case\n                 * propagate the bubbling event from the top level of the substree directly\n                 * to the layoutManager\n                 */\n                if (this.isGround === false && this._parent) {\n                    this._parent.emitUnknown(name, event);\n                } else {\n                    this.scheduleEventPropagationToLayoutManager(name, event);\n                }\n            }\n        }\n    }\n\n    override tryBubbleEvent(name: string, args: unknown[]): void {\n        if (args.length === 1) {\n            const event = args[0];\n            if (event instanceof EventEmitter.BubblingEvent &&\n                event.isPropagationStopped === false &&\n                this._isInitialised === true\n            ) {\n                /**\n                 * In some cases (e.g. if an element is created from a DragSource) it\n                 * doesn't have a parent and is not a child of GroundItem. If that's the case\n                 * propagate the bubbling event from the top level of the substree directly\n                 * to the layoutManager\n                 */\n                if (this.isGround === false && this._parent) {\n                    this._parent.emitUnknown(name, event);\n                } else {\n                    this.scheduleEventPropagationToLayoutManager(name, event);\n                }\n            }\n        }\n    }\n\n    /**\n     * All raw events bubble up to the Ground element. Some events that\n     * are propagated to - and emitted by - the layoutManager however are\n     * only string-based, batched and sanitized to make them more usable\n     *\n     * @param name - The name of the event\n     * @internal\n     */\n    private scheduleEventPropagationToLayoutManager(name: string, event: EventEmitter.BubblingEvent) {\n        if (this._throttledEvents.indexOf(name) === -1) {\n            this.layoutManager.emitUnknown(name, event);\n        } else {\n            if (this._pendingEventPropagations[name] !== true) {\n                this._pendingEventPropagations[name] = true;\n                globalThis.requestAnimationFrame(() => this.propagateEventToLayoutManager(name, event));\n            }\n        }\n\n    }\n\n    /**\n     * Callback for events scheduled by _scheduleEventPropagationToLayoutManager\n     *\n     * @param name - The name of the event\n     * @internal\n     */\n    private propagateEventToLayoutManager(name: string, event: EventEmitter.BubblingEvent) {\n        this._pendingEventPropagations[name] = false;\n        this.layoutManager.emitUnknown(name, event);\n    }\n}\n\n/** @public */\nexport namespace ContentItem {\n    /** @internal */\n    export interface Area extends AreaLinkedRect {\n        surface: number;\n        contentItem: ContentItem;\n    }\n}\n\n/** @public @deprecated Use {@link (ContentItem:class)} */\nexport type AbstractContentItem = ContentItem;\n", "import { ResolvedComponentItemConfig, ResolvedHeaderedItemConfig } from '../config/resolved-config';\nimport { ComponentContainer } from '../container/component-container';\nimport { Tab } from '../controls/tab';\nimport { UnexpectedNullError } from '../errors/internal-error';\nimport { LayoutManager } from '../layout-manager';\nimport { DomConstants } from '../utils/dom-constants';\nimport { ItemType, JsonValue } from '../utils/types';\nimport { getElementWidthAndHeight, setElementHeight, setElementWidth } from '../utils/utils';\nimport { ComponentParentableItem } from './component-parentable-item';\nimport { ContentItem } from './content-item';\n\n/** @public */\nexport class ComponentItem extends ContentItem {\n    /** @internal */\n    private _reorderEnabled: boolean;\n    /** @internal */\n    private _headerConfig: ResolvedHeaderedItemConfig.Header | undefined;\n    /** @internal */\n    private _title: string;\n    /** @internal */\n    private readonly _initialWantMaximise: boolean;\n    /** @internal */\n    private _container: ComponentContainer;\n    /** @internal */\n    private _tab: Tab;\n    /** @internal */\n    private _focused = false;\n\n    /** @internal @deprecated use {@link (ComponentItem:class).componentType} */\n    get componentName(): JsonValue { return this._container.componentType; }\n    get componentType(): JsonValue { return this._container.componentType; }\n    get reorderEnabled(): boolean { return this._reorderEnabled; }\n    /** @internal */\n    get initialWantMaximise(): boolean { return this._initialWantMaximise; }\n    get component(): ComponentContainer.Component | undefined { return this._container.component; }\n    get container(): ComponentContainer { return this._container; }\n    get parentItem(): ComponentParentableItem { return this._parentItem; }\n\n    get headerConfig(): ResolvedHeaderedItemConfig.Header | undefined { return this._headerConfig; }\n    get title(): string { return this._title; }\n    get tab(): Tab { return this._tab; }\n    get focused(): boolean { return this._focused; }\n\n    /** @internal */\n    constructor(\n        layoutManager: LayoutManager,\n        config: ResolvedComponentItemConfig,\n        /** @internal */\n        private _parentItem: ComponentParentableItem\n    ) {\n        super(layoutManager, config, _parentItem, document.createElement('div'));\n\n        this.isComponent = true;\n\n        this._reorderEnabled = config.reorderEnabled;\n\n        this.applyUpdatableConfig(config);\n\n        this._initialWantMaximise = config.maximised;\n\n        const containerElement = document.createElement('div');\n        containerElement.classList.add(DomConstants.ClassName.Content);\n        this.element.appendChild(containerElement);\n        this._container = new ComponentContainer(config, this, layoutManager, containerElement,\n            (itemConfig) => this.handleUpdateItemConfigEvent(itemConfig),\n            () => this.show(),\n            () => this.hide(),\n            (suppressEvent) => this.focus(suppressEvent),\n            (suppressEvent) => this.blur(suppressEvent),\n        );\n    }\n\n    /** @internal */\n    override destroy(): void {\n        this._container.destroy()\n        super.destroy();\n    }\n\n    applyUpdatableConfig(config: ResolvedComponentItemConfig): void {\n        this.setTitle(config.title);\n        this._headerConfig = config.header;\n    }\n\n    toConfig(): ResolvedComponentItemConfig {\n        const stateRequestEvent = this._container.stateRequestEvent;\n        const state = stateRequestEvent === undefined ? this._container.state : stateRequestEvent();\n\n        const result: ResolvedComponentItemConfig = {\n            type: ItemType.component,\n            content: [],\n            size: this.size,\n            sizeUnit: this.sizeUnit,\n            minSize: this.minSize,\n            minSizeUnit: this.minSizeUnit,\n            id: this.id,\n            maximised: false,\n            isClosable: this.isClosable,\n            reorderEnabled: this._reorderEnabled,\n            title: this._title,\n            header: ResolvedHeaderedItemConfig.Header.createCopy(this._headerConfig),\n            componentType: ResolvedComponentItemConfig.copyComponentType(this.componentType),\n            componentState: state,\n        }\n\n        return result;\n    }\n\n    close(): void {\n        if (this.parent === null) {\n            throw new UnexpectedNullError('CIC68883');\n        } else {\n            this.parent.removeChild(this, false);\n        }\n    }\n\n    // Used by Drag Proxy\n    /** @internal */\n    enterDragMode(width: number, height: number): void {\n        setElementWidth(this.element, width);\n        setElementHeight(this.element, height);\n        this._container.enterDragMode(width, height);\n    }\n\n    /** @internal */\n    exitDragMode(): void {\n        this._container.exitDragMode();\n    }\n\n    /** @internal */\n    enterStackMaximised(): void {\n        this._container.enterStackMaximised();\n    }\n\n    /** @internal */\n    exitStackMaximised(): void {\n        this._container.exitStackMaximised();\n    }\n\n    // Used by Drag Proxy\n    /** @internal */\n    drag(): void {\n        this._container.drag();\n    }\n\n    /** @internal */\n    override updateSize(force: boolean): void {\n        this.updateNodeSize(force);\n    }\n\n    /** @internal */\n    override init(): void {\n        this.updateNodeSize(false);\n\n        super.init();\n        this._container.emit('open');\n        this.initContentItems();\n    }\n\n    /**\n     * Set this component's title\n     *\n     * @public\n     * @param title -\n     */\n\n    setTitle(title: string): void {\n        this._title = title;\n        this.emit('titleChanged', title);\n        this.emit('stateChanged');\n    }\n\n    setTab(tab: Tab): void {\n        this._tab = tab;\n        this.emit('tab', tab)\n        this._container.setTab(tab);\n    }\n\n    /** @internal */\n    override hide(): void {\n        super.hide();\n        this._container.setVisibility(false);\n    }\n\n    /** @internal */\n    override show(): void {\n        super.show();\n        this._container.setVisibility(true);\n    }\n\n    /**\n     * Focuses the item if it is not already focused\n     */\n    focus(suppressEvent = false): void {\n        this.parentItem.setActiveComponentItem(this, true, suppressEvent);\n    }\n\n    /** @internal */\n    setFocused(suppressEvent: boolean): void {\n        this._focused = true;\n        this.tab.setFocused();\n        if (!suppressEvent) {\n            this.emitBaseBubblingEvent('focus');\n        }\n    }\n\n    /**\n     * Blurs (defocuses) the item if it is focused\n     */\n    blur(suppressEvent = false): void {\n        if (this._focused) {\n            this.layoutManager.setFocusedComponentItem(undefined, suppressEvent);\n        }\n    }\n\n    /** @internal */\n    setBlurred(suppressEvent: boolean): void {\n        this._focused = false;\n        this.tab.setBlurred();\n        if (!suppressEvent) {\n            this.emitBaseBubblingEvent('blur');\n        }\n    }\n\n    /** @internal */\n    protected override setParent(parent: ContentItem): void {\n        this._parentItem = parent as ComponentParentableItem;\n        super.setParent(parent);\n    }\n\n    /** @internal */\n    private handleUpdateItemConfigEvent(itemConfig: ResolvedComponentItemConfig) {\n        this.applyUpdatableConfig(itemConfig);\n    }\n\n    /** @internal */\n    private updateNodeSize(force: boolean): void {\n        if (this.element.style.display !== 'none') {\n            // Do not update size of hidden components to prevent unwanted reflows\n\n            const { width, height } = getElementWidthAndHeight(this.element);\n            this._container.setSizeToNodeSize(width, height, force);\n        }\n    }\n}\n\n/** @public @deprecated use {@link (ComponentItem:class)} */\nexport type Component = ComponentItem;\n\n/** @public */\nexport namespace ComponentItem {\n    export type Component = ComponentContainer.Component;\n}\n", "import { ComponentItem } from './component-item';\nimport { ContentItem } from './content-item';\n\nexport abstract class ComponentParentableItem extends ContentItem {\n    /** @internal */\n    private _focused = false;\n\n    get focused(): boolean { return this._focused; }\n\n    /** @internal */\n    setFocusedValue(value: boolean): void {\n        this._focused = value;\n    }\n\n    abstract setActiveComponentItem(item: ComponentItem, focus: boolean, suppressFocusEvent: boolean): void;\n}\n", "import { DomConstants } from './dom-constants';\nimport { EventEmitter } from './event-emitter';\n\n/** @internal */\nexport class DragListener extends EventEmitter {\n    private _timeout: ReturnType<typeof setTimeout> | undefined;\n    private _allowableTargets: HTMLElement[];\n    private _oDocument: Document;\n    private _eBody: HTMLElement;\n    private _nDelay: number;\n    private _nDistance: number;\n    private _nX: number;\n    private _nY: number;\n    private _nOriginalX: number;\n    private _nOriginalY: number;\n    private _dragging: boolean;\n    private _pointerTracking = false;\n\n    private _pointerDownEventListener = (ev: PointerEvent) => this.onPointerDown(ev);\n    private _pointerMoveEventListener = (ev: PointerEvent) => this.onPointerMove(ev);\n    private _pointerUpEventListener = (ev: PointerEvent) => this.onPointerUp(ev);\n\n    constructor(private _eElement: HTMLElement, extraAllowableChildTargets: HTMLElement[]) {\n        super();\n\n        this._timeout = undefined;\n\n        this._allowableTargets = [_eElement, ...extraAllowableChildTargets];\n        this._oDocument = document;\n        this._eBody = document.body;\n\n        /**\n         * The delay after which to start the drag in milliseconds\n         * Do NOT make too short (previous value of 200 was not long enough for my touchpad)\n         * Should generally rely on the mouse move to start drag.  Not this delay.\n         */\n        this._nDelay = 1800;\n\n        /**\n         * The distance the mouse needs to be moved to qualify as a drag\n         * Previous comment: works better with delay only\n         * ???\n         * Probably somehow needs tuning for different devices\n         */\n        this._nDistance = 10;\n\n        this._nX = 0;\n        this._nY = 0;\n\n        this._nOriginalX = 0;\n        this._nOriginalY = 0;\n\n        this._dragging = false;\n\n        this._eElement.addEventListener('pointerdown', this._pointerDownEventListener, { passive: true });\n    }\n\n    destroy(): void {\n        this.checkRemovePointerTrackingEventListeners();\n\n        this._eElement.removeEventListener('pointerdown', this._pointerDownEventListener);\n    }\n\n    cancelDrag(): void {\n        this.processDragStop(undefined);\n    }\n\n    private onPointerDown(oEvent: PointerEvent) {\n        if (this._allowableTargets.includes(oEvent.target as HTMLElement) && oEvent.isPrimary) {\n            const coordinates = this.getPointerCoordinates(oEvent);\n            this.processPointerDown(coordinates);\n        }\n    }\n\n    private processPointerDown(coordinates: DragListener.PointerCoordinates) {\n        this._nOriginalX = coordinates.x;\n        this._nOriginalY = coordinates.y;\n\n        this._oDocument.addEventListener('pointermove', this._pointerMoveEventListener);\n        this._oDocument.addEventListener('pointerup', this._pointerUpEventListener, { passive: true });\n        this._pointerTracking = true;\n\n        this._timeout = setTimeout(\n            () => {\n                try {\n                    this.startDrag()\n                }\n                catch (err) {\n                    console.error(err);\n                    throw err;\n                }\n            }\n            , this._nDelay);\n    }\n\n    private onPointerMove(oEvent: PointerEvent) {\n        if (this._pointerTracking) {\n            this.processDragMove(oEvent);\n            oEvent.preventDefault();\n        }\n    }\n\n    private processDragMove(dragEvent: PointerEvent) {\n        this._nX = dragEvent.pageX - this._nOriginalX;\n        this._nY = dragEvent.pageY - this._nOriginalY;\n\n        if (this._dragging === false) {\n            if (\n                Math.abs(this._nX) > this._nDistance ||\n                Math.abs(this._nY) > this._nDistance\n            ) {\n                this.startDrag();\n            }\n        }\n\n        if (this._dragging) {\n            this.emit('drag', this._nX, this._nY, dragEvent);\n        }\n    }\n\n    private onPointerUp(oEvent: PointerEvent) {\n        this.processDragStop(oEvent);\n    }\n\n    private processDragStop(dragEvent?: PointerEvent) {\n        if (this._timeout !== undefined) {\n            clearTimeout(this._timeout);\n            this._timeout = undefined;\n        }\n\n        this.checkRemovePointerTrackingEventListeners();\n    \n        if (this._dragging === true) {\n            this._eBody.classList.remove(DomConstants.ClassName.Dragging);\n            this._eElement.classList.remove(DomConstants.ClassName.Dragging);\n            this._oDocument.querySelector('iframe')?.style.setProperty('pointer-events', '');\n            this._dragging = false;\n            this.emit('dragStop', dragEvent);\n        }\n    }\n\n    private checkRemovePointerTrackingEventListeners(): void {\n        if (this._pointerTracking) {\n            this._oDocument.removeEventListener('pointermove', this._pointerMoveEventListener);\n            this._oDocument.removeEventListener('pointerup', this._pointerUpEventListener);\n            this._pointerTracking = false;\n        }    \n    }\n\n    private startDrag() {\n        if (this._timeout !== undefined) {\n            clearTimeout(this._timeout);\n            this._timeout = undefined;\n        }\n        this._dragging = true;\n        this._eBody.classList.add(DomConstants.ClassName.Dragging);\n        this._eElement.classList.add(DomConstants.ClassName.Dragging);\n        this._oDocument.querySelector('iframe')?.style.setProperty('pointer-events', 'none');\n        this.emit('dragStart', this._nOriginalX, this._nOriginalY);\n    }\n\n    private getPointerCoordinates(event: PointerEvent) {\n        const result: DragListener.PointerCoordinates = {\n            x: event.pageX,\n            y: event.pageY\n        };\n        return result;\n    }\n\n}\n\n/** @internal */\nexport namespace DragListener {\n    export interface PointerCoordinates {\n        x: number,\n        y: number,\n    }\n}", "import { DomConstants } from '../utils/dom-constants';\nimport { DragListener } from '../utils/drag-listener';\nimport { EventEmitter } from '../utils/event-emitter';\nimport { numberToPixels } from '../utils/utils';\n\n/** @internal */\nexport class Splitter {\n    private _grabSize;\n    private _dragListener: DragListener;\n\n    private readonly _element: HTMLDivElement;\n\n    get element(): HTMLDivElement { return this._element; }\n\n    constructor(private _isVertical: boolean, private _size: number, grabSize: number) {\n        this._grabSize = grabSize < this._size ? this._size : grabSize;\n\n        this._element = document.createElement('div');\n        this._element.classList.add(DomConstants.ClassName.Splitter);\n        const dragHandleElement = document.createElement('div');\n        dragHandleElement.classList.add(DomConstants.ClassName.DragHandle);\n\n        const handleExcessSize = this._grabSize - this._size;\n        const handleExcessPos = handleExcessSize / 2;\n\n        if (this._isVertical) {\n            dragHandleElement.style.top = numberToPixels(-handleExcessPos);\n            dragHandleElement.style.height = numberToPixels(this._size + handleExcessSize);\n            this._element.classList.add(DomConstants.ClassName.Vertical);\n            this._element.style.height = numberToPixels(this._size);\n        } else {\n            dragHandleElement.style.left = numberToPixels(-handleExcessPos);\n            dragHandleElement.style.width = numberToPixels(this._size + handleExcessSize);\n            this._element.classList.add(DomConstants.ClassName.Horizontal);\n            this._element.style.width = numberToPixels(this._size);\n        }\n\n        this._element.appendChild(dragHandleElement);\n\n        this._dragListener = new DragListener(this._element, [dragHandleElement]);\n    }\n\n    destroy(): void {\n        this._element.remove();\n    }\n\n    on<K extends keyof EventEmitter.EventParamsMap>(eventName: K, callback: EventEmitter.Callback<K>): void {\n        this._dragListener.on<K>(eventName, callback);\n    }\n}\n", "import { ComponentItemConfig, ItemConfig, RowOrColumnItemConfig, StackItemConfig } from '../config/config'\nimport { ResolvedRowOrColumnItemConfig, ResolvedStackItemConfig } from '../config/resolved-config'\nimport { Splitter } from '../controls/splitter'\nimport { AssertError, UnexpectedNullError } from '../errors/internal-error'\nimport { LayoutManager } from '../layout-manager'\nimport { DomConstants } from '../utils/dom-constants'\nimport { ItemType, JsonValue, SizeUnitEnum, WidthOrHeightPropertyName } from '../utils/types'\nimport {\n    getElementHeight,\n    getElementWidth,\n    getElementWidthAndHeight,\n    numberToPixels,\n    pixelsToNumber,\n    setElementHeight,\n    setElementWidth\n} from \"../utils/utils\"\nimport { ComponentItem } from './component-item'\nimport { ContentItem } from './content-item'\n\n/** @public */\nexport class RowOrColumn extends ContentItem {\n    /** @internal */\n    private readonly _childElementContainer: HTMLElement;\n    /** @internal */\n    private readonly _configType: 'row' | 'column';\n    /** @internal */\n    private readonly _isColumn: boolean;\n    /** @internal */\n    private readonly _splitterSize: number;\n    /** @internal */\n    private readonly _splitterGrabSize: number;\n    /** @internal */\n    private readonly _dimension: WidthOrHeightPropertyName;\n    /** @internal */\n    private readonly _splitter: Splitter[] = [];\n    /** @internal */\n    private _splitterPosition: number | null;\n    /** @internal */\n    private _splitterMinPosition: number | null;\n    /** @internal */\n    private _splitterMaxPosition: number | null;\n\n    /** @internal */\n    constructor(isColumn: boolean, layoutManager: LayoutManager, config: ResolvedRowOrColumnItemConfig,\n        /** @internal */\n        private _rowOrColumnParent: ContentItem\n    ) {\n        super(layoutManager, config, _rowOrColumnParent, RowOrColumn.createElement(document, isColumn));\n\n        this.isRow = !isColumn;\n        this.isColumn = isColumn;\n\n        this._childElementContainer = this.element;\n        this._splitterSize = layoutManager.layoutConfig.dimensions.borderWidth;\n        this._splitterGrabSize = layoutManager.layoutConfig.dimensions.borderGrabWidth;\n        this._isColumn = isColumn;\n        this._dimension = isColumn ? 'height' : 'width';\n        this._splitterPosition = null;\n        this._splitterMinPosition = null;\n        this._splitterMaxPosition = null;\n\n        switch (config.type) {\n            case ItemType.row:\n            case ItemType.column:\n                this._configType = config.type;\n                break;\n            default:\n                throw new AssertError('ROCCCT00925');\n        }\n    }\n\n    newComponent(componentType: JsonValue, componentState?: JsonValue, title?: string, index?: number): ComponentItem {\n        const itemConfig: ComponentItemConfig = {\n            type: 'component',\n            componentType,\n            componentState,\n            title,\n        };\n        return this.newItem(itemConfig, index) as ComponentItem;\n    }\n\n    addComponent(componentType: JsonValue, componentState?: JsonValue, title?: string, index?: number): number {\n        const itemConfig: ComponentItemConfig = {\n            type: 'component',\n            componentType,\n            componentState,\n            title,\n        };\n        return this.addItem(itemConfig, index);\n    }\n\n    newItem(itemConfig: RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig,  index?: number): ContentItem {\n        index = this.addItem(itemConfig, index);\n        const createdItem = this.contentItems[index];\n\n        if (ContentItem.isStack(createdItem) && (ItemConfig.isComponent(itemConfig))) {\n            // createdItem is a Stack which was created to hold wanted component.  Return component\n            return createdItem.contentItems[0];\n        } else {\n            return createdItem;\n        }\n    }\n\n    addItem(itemConfig: RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig,\n        index?: number\n    ): number {\n        this.layoutManager.checkMinimiseMaximisedStack();\n        const resolvedItemConfig = ItemConfig.resolve(itemConfig, false);\n        const contentItem = this.layoutManager.createAndInitContentItem(resolvedItemConfig, this);\n        return this.addChild(contentItem, index, false);\n    }\n\n    /**\n     * Add a new contentItem to the Row or Column\n     *\n     * @param contentItem -\n     * @param index - The position of the new item within the Row or Column.\n     *                If no index is provided the item will be added to the end\n     * @param suspendResize - If true the items won't be resized. This will leave the item in\n     *                        an inconsistent state and is only intended to be used if multiple\n     *                        children need to be added in one go and resize is called afterwards\n     *\n     * @returns\n     */\n    override addChild(contentItem: ContentItem, index?: number, suspendResize?: boolean): number {\n\n        // contentItem = this.layoutManager._$normalizeContentItem(contentItem, this);\n\n        if (index === undefined) {\n            index = this.contentItems.length;\n        }\n\n        if (this.contentItems.length > 0) {\n            const splitterElement = this.createSplitter(Math.max(0, index - 1)).element;\n\n            if (index > 0) {\n                this.contentItems[index - 1].element.insertAdjacentElement('afterend', splitterElement);\n                splitterElement.insertAdjacentElement('afterend', contentItem.element);\n            } else {\n                this.contentItems[0].element.insertAdjacentElement('beforebegin', splitterElement);\n                splitterElement.insertAdjacentElement('beforebegin', contentItem.element);\n            }\n        } else {\n            this._childElementContainer.appendChild(contentItem.element);\n        }\n\n        super.addChild(contentItem, index);\n\n        const newItemSize = (1 / this.contentItems.length) * 100;\n\n        if (suspendResize === true) {\n            this.emitBaseBubblingEvent('stateChanged');\n            return index;\n        }\n\n        for (let i = 0; i < this.contentItems.length; i++) {\n            const indexedContentItem = this.contentItems[i];\n            if (indexedContentItem === contentItem) {\n                contentItem.size = newItemSize;\n            } else {\n                const itemSize = indexedContentItem.size *= (100 - newItemSize) / 100;\n                indexedContentItem.size = itemSize;\n            }\n        }\n\n        this.updateSize(false);\n        this.emitBaseBubblingEvent('stateChanged');\n\n        return index;\n    }\n\n    /**\n     * Removes a child of this element\n     *\n     * @param contentItem -\n     * @param keepChild - If true the child will be removed, but not destroyed\n     *\n     */\n    override removeChild(contentItem: ContentItem, keepChild: boolean): void {\n        const index = this.contentItems.indexOf(contentItem);\n        const splitterIndex = Math.max(index - 1, 0);\n\n        if (index === -1) {\n            throw new Error('Can\\'t remove child. ContentItem is not child of this Row or Column');\n        }\n\n        /**\n         * Remove the splitter before the item or after if the item happens\n         * to be the first in the row/column\n         */\n        if (this._splitter[splitterIndex]) {\n            this._splitter[splitterIndex].destroy();\n            this._splitter.splice(splitterIndex, 1);\n        }\n\n        super.removeChild(contentItem, keepChild);\n\n        if (this.contentItems.length === 1 && this.isClosable === true) {\n            const childItem = this.contentItems[0];\n            this.contentItems.length = 0;\n            this._rowOrColumnParent.replaceChild(this, childItem, true);\n        } else {\n            this.updateSize(false);\n            this.emitBaseBubblingEvent('stateChanged');\n        }\n    }\n\n    /**\n     * Replaces a child of this Row or Column with another contentItem\n     */\n    override replaceChild(oldChild: ContentItem, newChild: ContentItem): void {\n        const size = oldChild.size;\n        super.replaceChild(oldChild, newChild);\n        newChild.size = size;\n        this.updateSize(false);\n        this.emitBaseBubblingEvent('stateChanged');\n    }\n\n    /**\n     * Called whenever the dimensions of this item or one of its parents change\n     */\n    override updateSize(force: boolean): void {\n        this.layoutManager.beginVirtualSizedContainerAdding();\n        try {\n            this.updateNodeSize();\n            this.updateContentItemsSize(force);\n        } finally {\n            this.layoutManager.endVirtualSizedContainerAdding();\n        }\n    }\n\n    /**\n     * Invoked recursively by the layout manager. ContentItem.init appends\n     * the contentItem's DOM elements to the container, RowOrColumn init adds splitters\n     * in between them\n     * @internal\n     */\n    override init(): void {\n        if (this.isInitialised === true) return;\n\n        this.updateNodeSize();\n\n        for (let i = 0; i < this.contentItems.length; i++) {\n            this._childElementContainer.appendChild(this.contentItems[i].element);\n        }\n\n        super.init();\n\n        for (let i = 0; i < this.contentItems.length - 1; i++) {\n            this.contentItems[i].element.insertAdjacentElement('afterend', this.createSplitter(i).element);\n        }\n\n        this.initContentItems();\n    }\n\n    toConfig(): ResolvedRowOrColumnItemConfig {\n        const result: ResolvedRowOrColumnItemConfig = {\n            type: this.type as 'row' | 'column',\n            content: this.calculateConfigContent() as (ResolvedRowOrColumnItemConfig | ResolvedStackItemConfig)[],\n            size: this.size,\n            sizeUnit: this.sizeUnit,\n            minSize: this.minSize,\n            minSizeUnit: this.minSizeUnit,\n            id: this.id,\n            isClosable: this.isClosable,\n        }\n        return result;\n    }\n\n    /** @internal */\n    protected override setParent(parent: ContentItem): void {\n        this._rowOrColumnParent = parent;\n        super.setParent(parent);\n    }\n\n    /** @internal */\n    private updateNodeSize(): void {\n        if (this.contentItems.length > 0) {\n            this.calculateRelativeSizes();\n            this.setAbsoluteSizes();\n        }\n        this.emitBaseBubblingEvent('stateChanged');\n        this.emit('resize');\n    }\n\n    /**\n     * Turns the relative sizes calculated by calculateRelativeSizes into\n     * absolute pixel values and applies them to the children's DOM elements\n     *\n     * Assigns additional pixels to counteract Math.floor\n     * @internal\n     */\n    private setAbsoluteSizes() {\n        const absoluteSizes = this.calculateAbsoluteSizes();\n\n        for (let i = 0; i < this.contentItems.length; i++) {\n            if (absoluteSizes.additionalPixel - i > 0) {\n                absoluteSizes.itemSizes[i]++;\n            }\n\n            if (this._isColumn) {\n                setElementWidth(this.contentItems[i].element, absoluteSizes.crossAxisSize);\n                setElementHeight(this.contentItems[i].element, absoluteSizes.itemSizes[i]);\n            } else {\n                setElementWidth(this.contentItems[i].element, absoluteSizes.itemSizes[i]);\n                setElementHeight(this.contentItems[i].element, absoluteSizes.crossAxisSize);\n            }\n        }\n    }\n\n    /**\n     * Calculates the absolute sizes of all of the children of this Item.\n     * @returns Set with absolute sizes and additional pixels.\n     * @internal\n     */\n    private calculateAbsoluteSizes(): RowOrColumn.AbsoluteSizes {\n        const totalSplitterSize = (this.contentItems.length - 1) * this._splitterSize;\n        const { width: elementWidth, height: elementHeight } = getElementWidthAndHeight(this.element);\n\n        let totalSize: number;\n        let crossAxisSize: number;\n        if (this._isColumn) {\n            totalSize = elementHeight - totalSplitterSize;\n            crossAxisSize = elementWidth;\n        } else {\n            totalSize = elementWidth - totalSplitterSize;\n            crossAxisSize = elementHeight;\n        }\n\n        let totalAssigned = 0;\n        const itemSizes = [];\n\n        for (let i = 0; i < this.contentItems.length; i++) {\n            const contentItem = this.contentItems[i];\n            let itemSize: number;\n            if (contentItem.sizeUnit === SizeUnitEnum.Percent) {\n                itemSize = Math.floor(totalSize * (contentItem.size / 100));\n            } else {\n                throw new AssertError('ROCCAS6692');\n            }\n\n            totalAssigned += itemSize;\n            itemSizes.push(itemSize);\n        }\n\n        const additionalPixel = Math.floor(totalSize - totalAssigned);\n\n        return {\n            itemSizes,\n            additionalPixel,\n            totalSize,\n            crossAxisSize,\n        };\n    }\n\n    /**\n     * Calculates the relative sizes of all children of this Item. The logic\n     * is as follows:\n     *\n     * - Add up the total size of all items that have a configured size\n     *\n     * - If the total == 100 (check for floating point errors)\n     *        Excellent, job done\n     *\n     * - If the total is \\> 100,\n     *        set the size of items without set dimensions to 1/3 and add this to the total\n     *        set the size off all items so that the total is hundred relative to their original size\n     *\n     * - If the total is \\< 100\n     *        If there are items without set dimensions, distribute the remainder to 100 evenly between them\n     *        If there are no items without set dimensions, increase all items sizes relative to\n     *        their original size so that they add up to 100\n     *\n     * @internal\n     */\n    private calculateRelativeSizes() {\n\n        let total = 0;\n        const itemsWithFractionalSize: ContentItem[] = [];\n        let totalFractionalSize = 0;\n\n        for (let i = 0; i < this.contentItems.length; i++) {\n            const contentItem = this.contentItems[i];\n            const sizeUnit = contentItem.sizeUnit;\n            switch (sizeUnit) {\n                case SizeUnitEnum.Percent: {\n                    total += contentItem.size;\n                    break;\n                }\n                case SizeUnitEnum.Fractional: {\n                    itemsWithFractionalSize.push(contentItem);\n                    totalFractionalSize += contentItem.size;\n                    break;\n                }\n                default:\n                    throw new AssertError('ROCCRS49110', JSON.stringify(contentItem));\n            }\n        }\n\n        /**\n         * Everything adds up to hundred, all good :-)\n         */\n        if (Math.round(total) === 100) {\n            this.respectMinItemSize();\n            return;\n        } else {\n            /**\n             * Allocate the remaining size to the items with a fractional size\n             */\n            if (Math.round(total) < 100 && itemsWithFractionalSize.length > 0) {\n                const fractionalAllocatedSize = 100 - total;\n                for (let i = 0; i < itemsWithFractionalSize.length; i++) {\n                    const contentItem = itemsWithFractionalSize[i];\n                    contentItem.size = fractionalAllocatedSize * (contentItem.size / totalFractionalSize);\n                    contentItem.sizeUnit = SizeUnitEnum.Percent;\n                }\n                this.respectMinItemSize();\n                return;\n            } else {\n\n                /**\n                 * If the total is > 100, but there are also items with a fractional size, assign another 50%\n                 * to the fractional items\n                 *\n                 * This will be reset in the next step\n                 */\n                if (Math.round(total) > 100 && itemsWithFractionalSize.length > 0) {\n                    for (let i = 0; i < itemsWithFractionalSize.length; i++) {\n                        const contentItem = itemsWithFractionalSize[i];\n                        contentItem.size = 50 * (contentItem.size / totalFractionalSize);\n                        contentItem.sizeUnit = SizeUnitEnum.Percent;\n                    }\n                    total += 50;\n                }\n\n                /**\n                 * Set every items size relative to 100 relative to its size to total\n                 */\n                for (let i = 0; i < this.contentItems.length; i++) {\n                    const contentItem = this.contentItems[i];\n                    contentItem.size = (contentItem.size / total) * 100;\n                }\n\n                this.respectMinItemSize();\n            }\n        }\n    }\n\n    /**\n     * Adjusts the column widths to respect the dimensions minItemWidth if set.\n     * @internal\n     */\n    private respectMinItemSize() {\n        interface Entry {\n            size: number;\n        }\n\n        const minItemSize = this.calculateContentItemMinSize(this);\n\n        if (minItemSize <= 0 || this.contentItems.length <= 1) {\n            return;\n        } else {\n            let totalOverMin = 0;\n            let totalUnderMin = 0;\n            const entriesOverMin: Entry[] = [];\n            const allEntries: Entry[] = [];\n\n            const absoluteSizes = this.calculateAbsoluteSizes();\n\n            /**\n             * Figure out how much we are under the min item size total and how much room we have to use.\n             */\n            for (let i = 0; i < absoluteSizes.itemSizes.length; i++) {\n                const itemSize = absoluteSizes.itemSizes[i];\n\n                let entry: Entry;\n                if (itemSize < minItemSize) {\n                    totalUnderMin += minItemSize - itemSize;\n                    entry = {\n                        size: minItemSize\n                    };\n\n                } else {\n                    totalOverMin += itemSize - minItemSize;\n                    entry = {\n                        size: itemSize\n                    };\n                    entriesOverMin.push(entry);\n                }\n\n                allEntries.push(entry);\n            }\n\n            /**\n             * If there is nothing under min, or there is not enough over to make up the difference, do nothing.\n             */\n            if (totalUnderMin === 0 || totalUnderMin > totalOverMin) {\n                return;\n            } else {\n                /**\n                 * Evenly reduce all columns that are over the min item width to make up the difference.\n                 */\n                const reducePercent = totalUnderMin / totalOverMin;\n                let remainingSize = totalUnderMin;\n                for (let i = 0; i < entriesOverMin.length; i++) {\n                    const entry = entriesOverMin[i];\n                    const reducedSize = Math.round((entry.size - minItemSize) * reducePercent);\n                    remainingSize -= reducedSize;\n                    entry.size -= reducedSize;\n                }\n\n                /**\n                 * Take anything remaining from the last item.\n                 */\n                if (remainingSize !== 0) {\n                    allEntries[allEntries.length - 1].size -= remainingSize;\n                }\n\n                /**\n                 * Set every items size relative to 100 relative to its size to total\n                 */\n                for (let i = 0; i < this.contentItems.length; i++) {\n                    const contentItem = this.contentItems[i];\n                    contentItem.size = (allEntries[i].size / absoluteSizes.totalSize) * 100;\n                }\n            }\n        }\n    }\n\n    /**\n     * Instantiates a new Splitter, binds events to it and adds\n     * it to the array of splitters at the position specified as the index argument\n     *\n     * What it doesn't do though is append the splitter to the DOM\n     *\n     * @param index - The position of the splitter\n     *\n     * @returns\n     * @internal\n     */\n    private createSplitter(index: number): Splitter {\n        const splitter = new Splitter(this._isColumn, this._splitterSize, this._splitterGrabSize);\n        splitter.on('drag', (offsetX, offsetY) => this.onSplitterDrag(splitter, offsetX, offsetY));\n        splitter.on('dragStop', () => this.onSplitterDragStop(splitter));\n        splitter.on('dragStart', () => this.onSplitterDragStart(splitter));\n        this._splitter.splice(index, 0, splitter);\n        return splitter;\n    }\n\n    /**\n     * Locates the instance of Splitter in the array of\n     * registered splitters and returns a map containing the contentItem\n     * before and after the splitters, both of which are affected if the\n     * splitter is moved\n     *\n     * @returns A map of contentItems that the splitter affects\n     * @internal\n     */\n    private getSplitItems(splitter: Splitter) {\n        const index = this._splitter.indexOf(splitter);\n\n        return {\n            before: this.contentItems[index],\n            after: this.contentItems[index + 1]\n        };\n    }\n\n    private calculateContentItemMinSize(contentItem: ContentItem) {\n        const minSize = contentItem.minSize;\n        if (minSize !== undefined) {\n            if (contentItem.minSizeUnit === SizeUnitEnum.Pixel) {\n                return minSize;\n            } else {\n                throw new AssertError('ROCGMD98831', JSON.stringify(contentItem));\n            }\n        } else {\n            const dimensions = this.layoutManager.layoutConfig.dimensions;\n            return this._isColumn ? dimensions.defaultMinItemHeight : dimensions.defaultMinItemWidth;\n        }\n    }\n\n    /**\n     * Gets the minimum dimensions for the given item configuration array\n     * @internal\n     */\n    private calculateContentItemsTotalMinSize(contentItems: readonly ContentItem[]) {\n        let totalMinSize = 0;\n\n        for (const contentItem of contentItems) {\n            totalMinSize += this.calculateContentItemMinSize(contentItem);\n        }\n\n        return totalMinSize;\n    }\n\n    /**\n     * Invoked when a splitter's dragListener fires dragStart. Calculates the splitters\n     * movement area once (so that it doesn't need calculating on every mousemove event)\n     * @internal\n     */\n    private onSplitterDragStart(splitter: Splitter) {\n        const items = this.getSplitItems(splitter);\n\n        const beforeWidth = pixelsToNumber(items.before.element.style[this._dimension]);\n        const afterSize = pixelsToNumber(items.after.element.style[this._dimension]);\n        const beforeMinSize = this.calculateContentItemsTotalMinSize(items.before.contentItems);\n        const afterMinSize = this.calculateContentItemsTotalMinSize(items.after.contentItems);\n\n        this._splitterPosition = 0;\n        this._splitterMinPosition = -1 * (beforeWidth - beforeMinSize);\n        this._splitterMaxPosition = afterSize - afterMinSize;\n    }\n\n    /**\n     * Invoked when a splitter's DragListener fires drag. Updates the splitter's DOM position,\n     * but not the sizes of the elements the splitter controls in order to minimize resize events\n     *\n     * @param splitter -\n     * @param offsetX - Relative pixel values to the splitter's original position. Can be negative\n     * @param offsetY - Relative pixel values to the splitter's original position. Can be negative\n     * @internal\n     */\n    private onSplitterDrag(splitter: Splitter, offsetX: number, offsetY: number) {\n        let offset = this._isColumn ? offsetY : offsetX;\n\n        if (this._splitterMinPosition === null || this._splitterMaxPosition === null) {\n            throw new UnexpectedNullError('ROCOSD59226');\n        }\n        offset = Math.max(offset, this._splitterMinPosition);\n        offset = Math.min(offset, this._splitterMaxPosition);\n\n        this._splitterPosition = offset;\n        const offsetPixels = numberToPixels(offset);\n        if (this._isColumn) {\n            splitter.element.style.top = offsetPixels;\n        } else {\n            splitter.element.style.left = offsetPixels;\n        }\n    }\n\n    /**\n     * Invoked when a splitter's DragListener fires dragStop. Resets the splitters DOM position,\n     * and applies the new sizes to the elements before and after the splitter and their children\n     * on the next animation frame\n     * @internal\n     */\n    private onSplitterDragStop(splitter: Splitter) {\n        if (this._splitterPosition === null) {\n            throw new UnexpectedNullError('ROCOSDS66932');\n        } else {\n            const items = this.getSplitItems(splitter);\n            const sizeBefore = pixelsToNumber(items.before.element.style[this._dimension]);\n            const sizeAfter = pixelsToNumber(items.after.element.style[this._dimension]);\n            const splitterPositionInRange = (this._splitterPosition + sizeBefore) / (sizeBefore + sizeAfter);\n            const totalRelativeSize = items.before.size + items.after.size;\n\n            items.before.size = splitterPositionInRange * totalRelativeSize;\n            items.after.size = (1 - splitterPositionInRange) * totalRelativeSize;\n\n            splitter.element.style.top = numberToPixels(0);\n            splitter.element.style.left = numberToPixels(0);\n\n            globalThis.requestAnimationFrame(() => this.updateSize(false));\n        }\n    }\n}\n\n/** @public */\nexport namespace RowOrColumn {\n    /** @internal */\n    export interface AbsoluteSizes {\n        itemSizes: number[],\n        additionalPixel: number,\n        totalSize: number,\n        crossAxisSize: number\n    }\n\n    /** @internal */\n    export function getElementDimensionSize(element: HTMLElement, dimension: WidthOrHeightPropertyName): number {\n        if (dimension === 'width') {\n            return getElementWidth(element);\n        } else {\n            return getElementHeight(element);\n        }\n    }\n\n    /** @internal */\n    export function setElementDimensionSize(element: HTMLElement, dimension: WidthOrHeightPropertyName, value: number): void {\n        if (dimension === 'width') {\n            return setElementWidth(element, value);\n        } else {\n            return setElementHeight(element, value);\n        }\n    }\n\n    /** @internal */\n    export function createElement(document: Document, isColumn: boolean): HTMLDivElement {\n        const element = document.createElement('div');\n        element.classList.add(DomConstants.ClassName.Item);\n        if (isColumn) {\n            element.classList.add(DomConstants.ClassName.Column);\n        } else {\n            element.classList.add(DomConstants.ClassName.Row);\n        }\n        return element;\n    }\n}\n", "import { ComponentItemConfig, ItemConfig, RowOrColumnItemConfig, StackItemConfig } from '../config/config';\nimport { ResolvedComponentItemConfig, ResolvedGroundItemConfig, ResolvedHeaderedItemConfig, ResolvedItemConfig, ResolvedRootItemConfig, ResolvedStackItemConfig } from '../config/resolved-config';\nimport { AssertError, UnexpectedNullError } from '../errors/internal-error';\nimport { LayoutManager } from '../layout-manager';\nimport { DomConstants } from '../utils/dom-constants';\nimport { AreaLinkedRect, ItemType, SizeUnitEnum } from '../utils/types';\nimport { getElementWidthAndHeight, setElementHeight, setElementWidth } from '../utils/utils';\nimport { ComponentItem } from './component-item';\nimport { ComponentParentableItem } from './component-parentable-item';\nimport { ContentItem } from './content-item';\nimport { RowOrColumn } from './row-or-column';\n\n/**\n * GroundItem is the ContentItem whose one child is the root ContentItem (Root is planted in Ground).\n * (Previously it was called root however this was incorrect as its child is the root item)\n * There is only one instance of GroundItem and it is automatically created by the Layout Manager\n * @internal\n */\nexport class GroundItem extends ComponentParentableItem {\n    private readonly _childElementContainer: HTMLElement;\n    private readonly _containerElement: HTMLElement;\n\n    constructor(layoutManager: LayoutManager, rootItemConfig: ResolvedRootItemConfig | undefined, containerElement: HTMLElement) {\n\n        super(layoutManager, ResolvedGroundItemConfig.create(rootItemConfig), null, GroundItem.createElement(document));\n\n        this.isGround = true;\n        this._childElementContainer = this.element;\n        this._containerElement = containerElement;\n\n        // insert before any pre-existing content elements\n        let before = null;\n        while (true) {\n            const prev: ChildNode | null =\n                before ? before.previousSibling : this._containerElement.lastChild;\n            if (prev instanceof Element\n                && prev.classList.contains(DomConstants.ClassName.Content)) {\n                before = prev;\n            } else {\n                break;\n            }\n        }\n        this._containerElement.insertBefore(this.element, before);\n    }\n\n    override init(): void {\n        if (this.isInitialised === true) return;\n\n        this.updateNodeSize();\n\n        for (let i = 0; i < this.contentItems.length; i++) {\n            this._childElementContainer.appendChild(this.contentItems[i].element);\n        }\n\n        super.init();\n\n        this.initContentItems();\n    }\n\n    /**\n     * Loads a new Layout\n     * Internal only.  To load a new layout with API, use {@link (LayoutManager:class).loadLayout}\n     */\n    loadRoot(rootItemConfig: ResolvedRootItemConfig | undefined): void {\n        // Remove existing root if it exists\n        this.clearRoot();\n\n        if (rootItemConfig !== undefined) {\n            const rootContentItem = this.layoutManager.createAndInitContentItem(rootItemConfig, this);\n            this.addChild(rootContentItem, 0);\n        }\n    }\n\n    clearRoot(): void {\n        // Remove existing root if it exists\n        const contentItems = this.contentItems;\n        switch (contentItems.length) {\n            case 0: {\n                return;\n            }\n            case 1: {\n                const existingRootContentItem = contentItems[0];\n                existingRootContentItem.remove();\n                return;\n            }\n            default: {\n                throw new AssertError('GILR07721');\n            }\n        }\n    }\n\n    /**\n     * Adds a ContentItem child to root ContentItem.\n     * Internal only.  To load a add with API, use {@link (LayoutManager:class).addItem}\n     * @returns -1 if added as root otherwise index in root ContentItem's content\n     */\n    addItem(itemConfig: RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig,\n        index?: number\n    ): number {\n        this.layoutManager.checkMinimiseMaximisedStack();\n\n        const resolvedItemConfig = ItemConfig.resolve(itemConfig, false);\n        let parent: ContentItem;\n        if (this.contentItems.length > 0) {\n            parent = this.contentItems[0];\n        } else {\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            parent = this;\n        }\n        if (parent.isComponent) {\n            throw new Error('Cannot add item as child to ComponentItem');\n        } else {\n            const contentItem = this.layoutManager.createAndInitContentItem(resolvedItemConfig, parent);\n            index = parent.addChild(contentItem, index);\n            return (parent === this) ? -1 : index;\n        }\n    }\n\n    loadComponentAsRoot(itemConfig: ComponentItemConfig): void {\n        // Remove existing root if it exists\n        this.clearRoot();\n\n        const resolvedItemConfig = ItemConfig.resolve(itemConfig, false) as ResolvedComponentItemConfig;\n\n        if (resolvedItemConfig.maximised) {\n            throw new Error('Root Component cannot be maximised');\n        } else {\n            const rootContentItem = new ComponentItem(this.layoutManager, resolvedItemConfig, this);\n            rootContentItem.init();\n            this.addChild(rootContentItem, 0);\n        }\n    }\n\n    /**\n     * Adds a Root ContentItem.\n     * Internal only.  To replace Root ContentItem with API, use {@link (LayoutManager:class).loadLayout}\n     */\n    override addChild(contentItem: ContentItem, index?: number): number {\n        if (this.contentItems.length > 0) {\n            throw new Error('Ground node can only have a single child');\n        } else {\n            // contentItem = this.layoutManager._$normalizeContentItem(contentItem, this);\n            this._childElementContainer.appendChild(contentItem.element);\n            index = super.addChild(contentItem, index);\n\n            this.updateSize(false);\n            this.emitBaseBubblingEvent('stateChanged');\n\n            return index;\n        }\n    }\n\n    /** @internal */\n    override calculateConfigContent(): ResolvedRootItemConfig[] {\n        const contentItems = this.contentItems;\n        const count = contentItems.length;\n        const result = new Array<ResolvedRootItemConfig>(count);\n        for (let i = 0; i < count; i++) {\n            const item = contentItems[i];\n            const itemConfig = item.toConfig();\n            if (ResolvedRootItemConfig.isRootItemConfig(itemConfig)) {\n                result[i] = itemConfig;\n            } else {\n                throw new AssertError('RCCC66832');\n            }\n        }\n        return result;\n    }\n\n    /** @internal */\n    setSize(width: number, height: number): void {\n        if (width === undefined || height === undefined) {\n            this.updateSize(false); // For backwards compatibility with v1.x API\n        } else {\n            setElementWidth(this.element, width);\n            setElementHeight(this.element, height);\n\n            // GroundItem can be empty\n            if (this.contentItems.length > 0) {\n                setElementWidth(this.contentItems[0].element, width);\n                setElementHeight(this.contentItems[0].element, height);\n            }\n\n            this.updateContentItemsSize(false);\n        }\n    }\n\n    /**\n     * Adds a Root ContentItem.\n     * Internal only.  To replace Root ContentItem with API, use {@link (LayoutManager:class).updateRootSize}\n     */\n    override updateSize(force: boolean): void {\n        this.layoutManager.beginVirtualSizedContainerAdding();\n        try {\n            this.updateNodeSize();\n            this.updateContentItemsSize(force);\n        } finally {\n            this.layoutManager.endVirtualSizedContainerAdding();\n        }\n    }\n\n    createSideAreas(): GroundItem.Area[] {\n        const areaSize = 50;\n\n        const oppositeSides = GroundItem.Area.oppositeSides;\n        const result = new Array<GroundItem.Area>(Object.keys(oppositeSides).length);\n        let idx = 0;\n\n        for (const key in oppositeSides) {\n            const side = key as keyof GroundItem.Area.Sides;\n            const area = this.getElementArea() as GroundItem.Area;\n            if (area === null) {\n                throw new UnexpectedNullError('RCSA77553');\n            } else {\n                area.side = side;\n                if (oppositeSides[side][1] === '2' )\n                    area[side] = area[oppositeSides[side]] - areaSize;\n                else\n                    area[side] = area[oppositeSides[side]] + areaSize;\n                area.surface = (area.x2 - area.x1) * (area.y2 - area.y1);\n                result[idx++] = area;\n            }\n        }\n\n        return result;\n    }\n\n    override highlightDropZone(x: number, y: number, area: AreaLinkedRect): void {\n        this.layoutManager.tabDropPlaceholder.remove();\n        super.highlightDropZone(x, y, area);\n    }\n\n    override onDrop(contentItem: ContentItem, area: GroundItem.Area): void {\n\n        if (contentItem.isComponent) {\n            const itemConfig = ResolvedStackItemConfig.createDefault();\n            // since ResolvedItemConfig.contentItems not set up, we need to add header from Component\n            const component = contentItem as ComponentItem;\n            itemConfig.header = ResolvedHeaderedItemConfig.Header.createCopy(component.headerConfig);\n            const stack = this.layoutManager.createAndInitContentItem(itemConfig, this);\n            stack.addChild(contentItem);\n            contentItem = stack;\n        }\n\n        if (this.contentItems.length === 0) {\n            this.addChild(contentItem);\n        } else {\n            /*\n             * If the contentItem that's being dropped is not dropped on a Stack (cases which just passed above and\n             * which would wrap the contentItem in a Stack) we need to check whether contentItem is a RowOrColumn.\n             * If it is, we need to re-wrap it in a Stack like it was when it was dragged by its Tab (it was dragged!).\n             */\n            if(contentItem.type === ItemType.row || contentItem.type === ItemType.column){\n                const itemConfig = ResolvedStackItemConfig.createDefault();\n                const stack = this.layoutManager.createContentItem(itemConfig, this);\n                stack.addChild(contentItem)\n                contentItem = stack\n            }\n\n            const type = area.side[0] == 'x' ? ItemType.row : ItemType.column;\n            const insertBefore = area.side[1] == '2';\n            const column = this.contentItems[0];\n            if (!(column instanceof RowOrColumn) || column.type !== type) {\n                const itemConfig = ResolvedItemConfig.createDefault(type);\n                const rowOrColumn = this.layoutManager.createContentItem(itemConfig, this);\n                this.replaceChild(column, rowOrColumn);\n                rowOrColumn.addChild(contentItem, insertBefore ? 0 : undefined, true);\n                rowOrColumn.addChild(column, insertBefore ? undefined : 0, true);\n                column.size = 50;\n                contentItem.size = 50;\n                contentItem.sizeUnit = SizeUnitEnum.Percent;\n                rowOrColumn.updateSize(false);\n            } else {\n                const sibling = column.contentItems[insertBefore ? 0 : column.contentItems.length - 1]\n                column.addChild(contentItem, insertBefore ? 0 : undefined, true);\n                sibling.size *= 0.5;\n                contentItem.size = sibling.size;\n                contentItem.sizeUnit = SizeUnitEnum.Percent;\n                column.updateSize(false);\n            }\n        }\n    }\n\n    // No ContentItem can dock with groundItem.  However Stack can have a GroundItem parent and Stack requires that\n    // its parent implement dock() function.  Accordingly this function is implemented but throws an exception as it should\n    // never be called\n    dock(): void {\n        throw new AssertError('GID87731');\n    }\n\n    // No ContentItem can dock with groundItem.  However Stack can have a GroundItem parent and Stack requires that\n    // its parent implement validateDocking() function.  Accordingly this function is implemented but throws an exception as it should\n    // never be called\n    validateDocking(): void {\n        throw new AssertError('GIVD87732');\n    }\n\n    getAllContentItems(): ContentItem[] {\n        const result: ContentItem[] = [this];\n        this.deepGetAllContentItems(this.contentItems, result);\n        return result;\n    }\n\n    getConfigMaximisedItems(): ContentItem[] {\n        const result: ContentItem[] = [];\n        this.deepFilterContentItems(this.contentItems, result, (item) => {\n            if (ContentItem.isStack(item) && item.initialWantMaximise) {\n                return true;\n            } else {\n                if (ContentItem.isComponentItem(item) && item.initialWantMaximise) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        });\n\n        return result;\n    }\n\n    getItemsByPopInParentId(popInParentId: string): ContentItem[] {\n        const result: ContentItem[] = [];\n        this.deepFilterContentItems(this.contentItems, result, (item) => item.popInParentIds.includes(popInParentId));\n        return result;\n    }\n\n    toConfig(): ResolvedItemConfig {\n        throw new Error('Cannot generate GroundItem config');\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setActiveComponentItem(item: ComponentItem, focus: boolean, suppressFocusEvent: boolean): void {\n        // only applicable if ComponentItem is root and then it always has focus\n    }\n\n    private updateNodeSize(): void {\n        const { width, height } = getElementWidthAndHeight(this._containerElement);\n\n        setElementWidth(this.element, width);\n        setElementHeight(this.element, height);\n\n        /*\n         * GroundItem can be empty\n         */\n        if (this.contentItems.length > 0) {\n            setElementWidth(this.contentItems[0].element, width);\n            setElementHeight(this.contentItems[0].element, height);\n        }\n    }\n\n    private deepGetAllContentItems(content: readonly ContentItem[], result: ContentItem[]): void {\n        for (let i = 0; i < content.length; i++) {\n            const contentItem = content[i];\n            result.push(contentItem);\n            this.deepGetAllContentItems(contentItem.contentItems, result);\n        }\n    }\n\n    private deepFilterContentItems(content: readonly ContentItem[], result: ContentItem[],\n        checkAcceptFtn: ((this: void, item: ContentItem) => boolean)\n    ): void {\n        for (let i = 0; i < content.length; i++) {\n            const contentItem = content[i];\n            if (checkAcceptFtn(contentItem)) {\n                result.push(contentItem);\n            }\n            this.deepFilterContentItems(contentItem.contentItems, result, checkAcceptFtn);\n        }\n    }\n\n}\n\n/** @internal */\nexport namespace GroundItem {\n    export interface Area extends ContentItem.Area {\n        side: keyof typeof Area.Side;\n    }\n\n    export namespace Area {\n        export const enum Side {\n            y2,\n            x2,\n            y1,\n            x1,\n        }\n\n        export type Sides = { [side in keyof typeof Side]: keyof typeof Side; }\n\n        export const oppositeSides: Sides = {\n            y2: 'y1',\n            x2: 'x1',\n            y1: 'y2',\n            x1: 'x2',\n        };\n    }\n\n    export function createElement(document: Document): HTMLDivElement {\n        const element = document.createElement('div');\n        element.classList.add(DomConstants.ClassName.GoldenLayout);\n        element.classList.add(DomConstants.ClassName.Item);\n        element.classList.add(DomConstants.ClassName.Root);\n        return element;\n    }\n}\n", "import { Header } from './header';\n\n/** @internal */\nexport class HeaderButton {\n    private _element: HTMLElement;\n    private _clickEventListener = (ev: MouseEvent) => this.onClick(ev);\n    private _touchStartEventListener = (ev: TouchEvent) => this.onTouchStart(ev);\n\n    get element(): HTMLElement { return this._element; }\n\n    constructor(private _header: Header, label: string, cssClass: string, private _pushEvent: HeaderButton.PushEvent) {\n        this._element = document.createElement('div');\n        this._element.classList.add(cssClass);\n        this._element.title = label;\n        this._header.on('destroy', () => this.destroy());\n        this._element.addEventListener('click', this._clickEventListener, { passive: true });\n        this._element.addEventListener('touchstart', this._touchStartEventListener, { passive: true });\n        this._header.controlsContainerElement.appendChild(this._element);\n    }\n\n    destroy(): void {\n        this._element.removeEventListener('click', this._clickEventListener);\n        this._element.removeEventListener('touchstart', this._touchStartEventListener);\n        this._element.parentNode?.removeChild(this._element);\n    }\n\n    private onClick(ev: MouseEvent) {\n        this._pushEvent(ev);\n    }\n\n    private onTouchStart(ev: TouchEvent) {\n        this._pushEvent(ev);\n    }\n}\n\n/** @internal */\nexport namespace HeaderButton {\n    export type PushEvent = (this: void, ev: Event) => void;\n}\n", "import { UnexpectedUndefinedError } from '../errors/internal-error';\nimport { ComponentItem } from '../items/component-item';\nimport { LayoutManager } from '../layout-manager';\nimport { DomConstants } from '../utils/dom-constants';\nimport { DragListener } from '../utils/drag-listener';\n\n/**\n * Represents an individual tab within a Stack's header\n * @public\n */\nexport class Tab {\n    /** @internal */\n    private readonly _element: HTMLDivElement;\n    /** @internal */\n    private readonly _titleElement: HTMLSpanElement;\n    /** @internal */\n    private readonly _closeElement: HTMLDivElement | undefined;\n\n    /** @internal */\n    private _dragListener: DragListener | undefined;\n    /** @internal */\n    private _isActive = false;\n\n    /** @internal */\n    private readonly _tabClickListener = (ev: MouseEvent) => this.onTabClickDown(ev);\n    /** @internal */\n    private readonly _tabTouchStartListener = (ev: TouchEvent) => this.onTabTouchStart(ev);\n    /** @internal */\n    private readonly _closeClickListener = () => this.onCloseClick();\n    /** @internal */\n    private readonly _closeTouchStartListener = () => this.onCloseTouchStart();\n    // /** @internal */\n    // private readonly _closeMouseDownListener = () => this.onCloseMousedown();\n    /** @internal */\n    private readonly _dragStartListener = (x: number, y: number) => this.onDragStart(x, y);\n    /** @internal */\n    private readonly _contentItemDestroyListener = () => this.onContentItemDestroy();\n    /** @internal */\n    private readonly _tabTitleChangedListener = (title: string) => this.setTitle(title)\n\n    get isActive(): boolean { return this._isActive; }\n    // get header(): Header { return this._header; }\n    get componentItem(): ComponentItem { return this._componentItem; }\n    /** @deprecated use {@link (Tab:class).componentItem} */\n    get contentItem(): ComponentItem { return this._componentItem; }\n    get element(): HTMLElement { return this._element; }\n    get titleElement(): HTMLElement { return this._titleElement; }\n    get closeElement(): HTMLElement | undefined { return this._closeElement; }\n    get reorderEnabled(): boolean { return this._dragListener !== undefined; }\n    set reorderEnabled(value: boolean) {\n        if (value !== this.reorderEnabled) {\n            if (value) {\n                this.enableReorder();\n            } else {\n                this.disableReorder();\n            }\n        }\n    }\n\n    /** @internal */\n    constructor(\n        /** @internal */\n        private readonly _layoutManager: LayoutManager,\n        /** @internal */\n        private _componentItem: ComponentItem,\n        /** @internal */\n        private _closeEvent: Tab.CloseEvent | undefined,\n        /** @internal */\n        private _focusEvent: Tab.FocusEvent | undefined,\n        /** @internal */\n        private _dragStartEvent: Tab.DragStartEvent | undefined\n    ) {\n        this._element = document.createElement('div');\n        this._element.classList.add(DomConstants.ClassName.Tab);\n        this._titleElement = document.createElement('span'); \n        this._titleElement.classList.add(DomConstants.ClassName.Title);\n        this._closeElement = document.createElement('div'); \n        this._closeElement.classList.add(DomConstants.ClassName.CloseTab);\n        this._element.appendChild(this._titleElement);\n        this._element.appendChild(this._closeElement);\n\n        if (_componentItem.isClosable) {\n            this._closeElement.style.display = '';\n        } else {\n            this._closeElement.style.display = 'none';\n        }\n\n        this.setTitle(_componentItem.title);\n        this._componentItem.on('titleChanged', this._tabTitleChangedListener);\n\n        const reorderEnabled = _componentItem.reorderEnabled ?? this._layoutManager.layoutConfig.settings.reorderEnabled;\n\n        if (reorderEnabled) {\n            this.enableReorder();\n        }\n\n        this._element.addEventListener('click', this._tabClickListener, { passive: true });\n        this._element.addEventListener('touchstart', this._tabTouchStartListener, { passive: true });\n\n        if (this._componentItem.isClosable) {\n            this._closeElement.addEventListener('click', this._closeClickListener, { passive: true });\n            this._closeElement.addEventListener('touchstart', this._closeTouchStartListener, { passive: true });\n            // this._closeElement.addEventListener('mousedown', this._closeMouseDownListener, { passive: true });\n        } else {\n            this._closeElement.remove();\n            this._closeElement = undefined;\n        }\n\n        this._componentItem.setTab(this);\n        this._layoutManager.emit('tabCreated', this);\n    }\n\n    /**\n     * Sets the tab's title to the provided string and sets\n     * its title attribute to a pure text representation (without\n     * html tags) of the same string.\n     */\n    setTitle(title: string): void {\n        this._titleElement.innerText = title;\n        this._element.title = title;\n    }\n\n    /**\n     * Sets this tab's active state. To programmatically\n     * switch tabs, use Stack.setActiveComponentItem( item ) instead.\n     */\n    setActive(isActive: boolean): void {\n        if (isActive === this._isActive) {\n            return;\n        }\n        this._isActive = isActive;\n\n        if (isActive) {\n            this._element.classList.add(DomConstants.ClassName.Active);\n        } else {\n            this._element.classList.remove(DomConstants.ClassName.Active);\n        }\n    }\n\n    /**\n     * Destroys the tab\n     * @internal\n     */\n    destroy(): void {\n        this._closeEvent = undefined;\n        this._focusEvent = undefined;\n        this._dragStartEvent = undefined;\n        this._element.removeEventListener('click', this._tabClickListener);\n        this._element.removeEventListener('touchstart', this._tabTouchStartListener);\n        this._closeElement?.removeEventListener('click', this._closeClickListener);\n        this._closeElement?.removeEventListener('touchstart', this._closeTouchStartListener);\n        // this._closeElement?.removeEventListener('mousedown', this._closeMouseDownListener);\n        this._componentItem.off('titleChanged', this._tabTitleChangedListener);\n        if (this.reorderEnabled) {\n            this.disableReorder();\n        }\n        this._element.remove();\n    }\n\n    /** @internal */\n    setBlurred(): void {\n        this._element.classList.remove(DomConstants.ClassName.Focused);\n        this._titleElement.classList.remove(DomConstants.ClassName.Focused);\n    }\n\n    /** @internal */\n    setFocused(): void {\n        this._element.classList.add(DomConstants.ClassName.Focused);\n        this._titleElement.classList.add(DomConstants.ClassName.Focused);\n    }\n\n    /**\n     * Callback for the DragListener\n     * @param x - The tabs absolute x position\n     * @param y - The tabs absolute y position\n     * @internal\n     */\n    private onDragStart(x: number, y: number): void {\n        if (this._dragListener === undefined) {\n            throw new UnexpectedUndefinedError('TODSDLU10093');\n        } else {\n            if (this._dragStartEvent === undefined) {\n                throw new UnexpectedUndefinedError('TODS23309');\n            } else {\n                this._dragStartEvent(x, y, this._dragListener, this.componentItem);\n            }\n        }\n\n    }\n\n    /** @internal */\n    private onContentItemDestroy() {\n        if (this._dragListener !== undefined) {\n            this._dragListener.destroy();\n            this._dragListener = undefined;\n        }\n    }\n\n    /**\n     * Callback when the tab is clicked\n     * @internal\n     */\n    private onTabClickDown(event: MouseEvent) {\n        const target = event.target;\n        if (target === this._element || target === this._titleElement) {\n            // left mouse button\n            if (event.button === 0) {\n                // event.stopPropagation();\n                this.notifyFocus();\n\n                // middle mouse button\n            } else if (event.button === 1 && this._componentItem.isClosable) {\n                // event.stopPropagation();\n                this.notifyClose();\n            }\n        }\n    }\n\n    /** @internal */\n    private onTabTouchStart(event: TouchEvent) {\n        if (event.target === this._element) {\n            this.notifyFocus();\n        }\n    }\n\n    /**\n     * Callback when the tab's close button is clicked\n     * @internal\n     */\n    private onCloseClick() {\n        this.notifyClose();\n    }\n\n    /** @internal */\n    private onCloseTouchStart() {\n        this.notifyClose();\n    }\n\n    /**\n     * Callback to capture tab close button mousedown\n     * to prevent tab from activating.\n     * @internal\n     */\n    // private onCloseMousedown(): void {\n    //     // event.stopPropagation();\n    // }\n\n    /** @internal */\n    private notifyClose() {\n        if (this._closeEvent === undefined) {\n            throw new UnexpectedUndefinedError('TNC15007');\n        } else {\n            this._closeEvent(this._componentItem);\n        }\n    }\n\n    /** @internal */\n    private notifyFocus() {\n        if (this._focusEvent === undefined) {\n            throw new UnexpectedUndefinedError('TNA15007');\n        } else {\n            this._focusEvent(this._componentItem);\n        }\n    }\n\n    /** @internal */\n    private enableReorder() {\n        this._dragListener = new DragListener(this._element, [this._titleElement]);\n        this._dragListener.on('dragStart', this._dragStartListener);\n        this._componentItem.on('destroy', this._contentItemDestroyListener);\n    }\n\n    /** @internal */\n    private disableReorder() {\n        if (this._dragListener === undefined) {\n            throw new UnexpectedUndefinedError('TDR87745');\n        } else {\n            this._componentItem.off('destroy', this._contentItemDestroyListener);\n            this._dragListener.off('dragStart', this._dragStartListener);\n            this._dragListener = undefined;\n        }\n    }\n}\n\n/** @public */\nexport namespace Tab {\n    /** @internal */\n    export type CloseEvent = (componentItem: ComponentItem) => void;\n    /** @internal */\n    export type FocusEvent = (componentItem: ComponentItem) => void;\n    /** @internal */\n    export type DragStartEvent = (x: number, y: number, dragListener: DragListener, componentItem: ComponentItem) => void;\n}\n", "import { AssertError } from '../errors/internal-error';\nimport { ComponentItem } from '../items/component-item';\nimport { LayoutManager } from '../layout-manager';\nimport { DomConstants } from '../utils/dom-constants';\nimport { DragListener } from '../utils/drag-listener';\nimport { numberToPixels, pixelsToNumber } from '../utils/utils';\nimport { Tab } from './tab';\n\n/** @internal */\nexport class TabsContainer {\n    // There is one tab per ComponentItem in stack.  However they may not be ordered the same\n    private readonly _tabs: Tab[] = [];\n\n    private readonly _dropdownElement: HTMLElement;\n    private readonly _element: HTMLElement;\n    private _lastVisibleTabIndex = -1;\n    private _dropdownActive = false;\n\n    get tabs(): Tab[] { return this._tabs; }\n    get tabCount(): number { return this._tabs.length; }\n    get lastVisibleTabIndex(): number { return this._lastVisibleTabIndex; }\n\n    get element(): HTMLElement { return this._element; }\n    get dropdownElement(): HTMLElement { return this._dropdownElement; }\n    get dropdownActive(): boolean { return this._dropdownActive; }\n\n    constructor(private _layoutManager: LayoutManager,\n        private _componentRemoveEvent: TabsContainer.ComponentItemRemoveEvent,\n        private _componentFocusEvent: TabsContainer.ComponentItemFocusEvent,\n        private _componentDragStartEvent: TabsContainer.ComponentItemDragStartEvent,\n        private _dropdownActiveChangedEvent: TabsContainer.DropdownActiveChangedEvent,\n    ) {\n        this._element = document.createElement('section');\n        this._element.classList.add(DomConstants.ClassName.Tabs);\n\n        this._dropdownElement = document.createElement('section');\n        this._dropdownElement.classList.add(DomConstants.ClassName.TabDropdownList);\n        this._dropdownElement.style.display = 'none';\n    }\n\n    destroy(): void {\n        for (let i = 0; i < this._tabs.length; i++) {\n            this._tabs[i].destroy();\n        }\n    }\n\n    /**\n     * Creates a new tab and associates it with a contentItem\n     * @param index - The position of the tab\n     */\n    createTab(componentItem: ComponentItem, index: number): void {\n        //If there's already a tab relating to the\n        //content item, don't do anything\n        for (let i = 0; i < this._tabs.length; i++) {\n            if (this._tabs[i].componentItem === componentItem) {\n                return;\n            }\n        }\n\n        const tab = new Tab(this._layoutManager,\n            componentItem,\n            (item) => this.handleTabCloseEvent(item),\n            (item) => this.handleTabFocusEvent(item),\n            (x, y, dragListener, item) => this.handleTabDragStartEvent(x, y, dragListener, item));\n\n        if (index === undefined) {\n            index = this._tabs.length;\n        }\n\n        this._tabs.splice(index, 0, tab);\n\n        if (index < this._element.childNodes.length) {\n            this._element.insertBefore(tab.element, this._element.childNodes[index]);\n        } else {\n            this._element.appendChild(tab.element);\n        }\n    }\n\n    removeTab(componentItem: ComponentItem): void {\n        // componentItem cannot be ActiveComponentItem\n        for (let i = 0; i < this._tabs.length; i++) {\n            if (this._tabs[i].componentItem === componentItem) {\n                const tab = this._tabs[i];\n                tab.destroy();\n                this._tabs.splice(i, 1);\n                return;\n            }\n        }\n\n        throw new Error('contentItem is not controlled by this header');\n    }\n\n    processActiveComponentChanged(newActiveComponentItem: ComponentItem): void {\n        let activeIndex = -1;\n        for (let i = 0; i < this._tabs.length; i++) {\n            const isActive = this._tabs[i].componentItem === newActiveComponentItem;\n            this._tabs[i].setActive(isActive);\n            if (isActive) {\n                activeIndex = i;\n            }\n        }\n\n        if (activeIndex < 0) {\n            throw new AssertError('HSACI56632');\n        } else {\n            if (this._layoutManager.layoutConfig.settings.reorderOnTabMenuClick) {\n                /**\n                 * If the tab selected was in the dropdown, move everything down one to make way for this one to be the first.\n                 * This will make sure the most used tabs stay visible.\n                 */\n                if (this._lastVisibleTabIndex !== -1 && activeIndex > this._lastVisibleTabIndex) {\n                    const activeTab = this._tabs[activeIndex];\n                    for (let j = activeIndex; j > 0; j--) {\n                        this._tabs[j] = this._tabs[j - 1];\n                    }\n                    this._tabs[0] = activeTab;\n\n                    // updateTabSizes will always be called after this and it will reposition tab elements\n                }\n            }\n        }\n    }\n\n    /**\n     * Pushes the tabs to the tab dropdown if the available space is not sufficient\n     */\n    updateTabSizes(availableWidth: number, activeComponentItem: ComponentItem | undefined): void {\n        let dropDownActive = false;\n        const success = this.tryUpdateTabSizes(dropDownActive, availableWidth, activeComponentItem);\n        if (!success) {\n            dropDownActive = true;\n            // this will always succeed\n            this.tryUpdateTabSizes(dropDownActive, availableWidth, activeComponentItem)\n        }\n\n        if (dropDownActive !== this._dropdownActive) {\n            this._dropdownActive = dropDownActive;\n            this._dropdownActiveChangedEvent();\n        }\n    }\n\n    tryUpdateTabSizes(dropdownActive: boolean, availableWidth: number, activeComponentItem: ComponentItem | undefined): boolean {\n        if (this._tabs.length > 0) {\n            if (activeComponentItem === undefined) {\n                throw new Error('non-empty tabs must have active component item');\n            }\n\n            let cumulativeTabWidth = 0;\n            let tabOverlapAllowanceExceeded = false;\n            const tabOverlapAllowance = this._layoutManager.layoutConfig.settings.tabOverlapAllowance;\n            const activeIndex = this._tabs.indexOf(activeComponentItem.tab);\n            const activeTab = this._tabs[activeIndex];\n            this._lastVisibleTabIndex = -1;\n\n            for (let i = 0; i < this._tabs.length; i++) {\n                const tabElement = this._tabs[i].element;\n\n                //Put the tab in the tabContainer so its true width can be checked\n                if (tabElement.parentElement !== this._element) {\n                    this._element.appendChild(tabElement);\n                }\n                const tabMarginRightPixels = getComputedStyle(activeTab.element).marginRight;\n                const tabMarginRight = pixelsToNumber(tabMarginRightPixels);\n                const tabWidth = tabElement.offsetWidth + tabMarginRight;\n\n                cumulativeTabWidth += tabWidth;\n\n                //Include the active tab's width if it isn't already\n                //This is to ensure there is room to show the active tab\n                let visibleTabWidth = 0;\n                if (activeIndex <= i) {\n                    visibleTabWidth = cumulativeTabWidth;\n                } else {\n                    const activeTabMarginRightPixels = getComputedStyle(activeTab.element).marginRight;\n                    const activeTabMarginRight = pixelsToNumber(activeTabMarginRightPixels);\n                    visibleTabWidth = cumulativeTabWidth + activeTab.element.offsetWidth + activeTabMarginRight;\n                }\n\n                // If the tabs won't fit, check the overlap allowance.\n                if (visibleTabWidth > availableWidth) {\n\n                    //Once allowance is exceeded, all remaining tabs go to menu.\n                    if (!tabOverlapAllowanceExceeded) {\n\n                        //No overlap for first tab or active tab\n                        //Overlap spreads among non-active, non-first tabs\n                        let overlap: number;\n                        if (activeIndex > 0 && activeIndex <= i) {\n                            overlap = (visibleTabWidth - availableWidth) / (i - 1);\n                        } else {\n                            overlap = (visibleTabWidth - availableWidth) / i;\n                        }\n\n                        //Check overlap against allowance.\n                        if (overlap < tabOverlapAllowance) {\n                            for (let j = 0; j <= i; j++) {\n                                const marginLeft = (j !== activeIndex && j !== 0) ? '-' + numberToPixels(overlap) : '';\n                                this._tabs[j].element.style.zIndex = numberToPixels(i - j);\n                                this._tabs[j].element.style.marginLeft = marginLeft;\n                            }\n                            this._lastVisibleTabIndex = i;\n                            if (tabElement.parentElement !== this._element) {\n                                this._element.appendChild(tabElement);\n                            }\n                        } else {\n                            tabOverlapAllowanceExceeded = true;\n                        }\n\n                    } else if (i === activeIndex) {\n                        //Active tab should show even if allowance exceeded. (We left room.)\n                        tabElement.style.zIndex = 'auto';\n                        tabElement.style.marginLeft = '';\n                        if (tabElement.parentElement !== this._element) {\n                            this._element.appendChild(tabElement);\n                        }\n                    }\n\n                    if (tabOverlapAllowanceExceeded && i !== activeIndex) {\n                        if (dropdownActive) {\n                            //Tab menu already shown, so we just add to it.\n                            tabElement.style.zIndex = 'auto';\n                            tabElement.style.marginLeft = '';\n\n                            if (tabElement.parentElement !== this._dropdownElement) {\n                                this._dropdownElement.appendChild(tabElement);\n                            }\n                        } else {\n                            //We now know the tab menu must be shown, so we have to recalculate everything.\n                            return false;\n                        }\n                    }\n\n                } else {\n                    this._lastVisibleTabIndex = i;\n                    tabElement.style.zIndex = 'auto';\n                    tabElement.style.marginLeft = '';\n                    if (tabElement.parentElement !== this._element) {\n                        this._element.appendChild(tabElement);\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Shows drop down for additional tabs when there are too many to display.\n     */\n    showAdditionalTabsDropdown(): void {\n        this._dropdownElement.style.display = '';\n    }\n\n    /**\n     * Hides drop down for additional tabs when there are too many to display.\n     */\n    hideAdditionalTabsDropdown(): void {\n        this._dropdownElement.style.display = 'none';\n    }\n\n    private handleTabCloseEvent(componentItem: ComponentItem) {\n        this._componentRemoveEvent(componentItem);\n    }\n\n    private handleTabFocusEvent(componentItem: ComponentItem) {\n        this._componentFocusEvent(componentItem);\n    }\n\n    private handleTabDragStartEvent(x: number, y: number, dragListener: DragListener, componentItem: ComponentItem) {\n        this._componentDragStartEvent(x, y, dragListener, componentItem);\n    }\n\n}\n\n/** @internal */\nexport namespace TabsContainer {\n    export type ComponentItemRemoveEvent = (this: void, componentItem: ComponentItem) => void;\n    export type ComponentItemFocusEvent = (this: void, componentItem: ComponentItem) => void;\n    export type ComponentItemDragStartEvent = (this: void, x: number, y: number, dragListener: DragListener, componentItem: ComponentItem) => void;\n    export type DropdownActiveChangedEvent = (this: void) => void;\n}\n", "import { UnexpectedUndefinedError } from '../errors/internal-error';\nimport { ComponentItem } from '../items/component-item';\nimport { Stack } from '../items/stack';\nimport { LayoutManager } from '../layout-manager';\nimport { DomConstants } from '../utils/dom-constants';\nimport { DragListener } from '../utils/drag-listener';\nimport { EventEmitter } from '../utils/event-emitter';\nimport { Side } from '../utils/types';\nimport { numberToPixels, setElementDisplayVisibility } from '../utils/utils';\nimport { HeaderButton } from './header-button';\nimport { Tab } from './tab';\nimport { TabsContainer } from './tabs-container';\n\n/**\n * This class represents a header above a Stack ContentItem.\n * @public\n */\nexport class Header extends EventEmitter {\n    /** @internal */\n    private readonly _tabsContainer: TabsContainer;\n    /** @internal */\n    private readonly _element: HTMLElement;\n    /** @internal */\n    private readonly _controlsContainerElement: HTMLElement;\n\n    /** @internal */\n    private readonly _show: boolean;\n    /** @internal */\n    private readonly _popoutEnabled: boolean;\n    /** @internal */\n    private readonly _popoutLabel: string;\n    /** @internal */\n    private readonly _maximiseEnabled: boolean;\n    /** @internal */\n    private readonly _maximiseLabel: string;\n    /** @internal */\n    private readonly _minimiseEnabled: boolean;\n    /** @internal */\n    private readonly _minimiseLabel: string;\n    /** @internal */\n    private readonly _closeEnabled: boolean;\n    /** @internal */\n    private readonly _closeLabel: string;\n    /** @internal */\n    private readonly _tabDropdownEnabled: boolean;\n    /** @internal */\n    private readonly _tabDropdownLabel: string;\n\n    /** @internal */\n    private readonly _tabControlOffset: number;\n\n    /** @internal */\n    private readonly _clickListener = (ev: MouseEvent) => this.onClick(ev);\n    /** @internal */\n    private readonly _touchStartListener = (ev: TouchEvent) => this.onTouchStart(ev);\n    /** @internal */\n    private readonly _documentMouseUpListener: (this: void) => void;\n\n    /** @internal */\n    private _rowColumnClosable = true;\n    /** @internal */\n    private _canRemoveComponent: boolean;\n    /** @internal */\n    private _side: Side;\n    /** @internal */\n    private _leftRightSided: boolean;\n    /** @internal */\n    private readonly _closeButton: HeaderButton | null = null;\n    /** @internal */\n    private readonly _popoutButton: HeaderButton | null = null;\n    /** @internal */\n    private readonly _tabDropdownButton: HeaderButton;\n    /** @internal */\n    private readonly _maximiseButton: HeaderButton | undefined;\n    // /** @internal */\n    // private _activeComponentItem: ComponentItem | null = null; // only used to identify active tab\n\n    get show(): boolean { return this._show; }\n    get side(): Side { return this._side; }\n    get leftRightSided(): boolean { return this._leftRightSided; }\n\n    get layoutManager(): LayoutManager { return this._layoutManager; }\n    get parent(): Stack { return this._parent; }\n    get tabs(): Tab[] { return this._tabsContainer.tabs; }\n    get lastVisibleTabIndex(): number { return this._tabsContainer.lastVisibleTabIndex; }\n\n    get element(): HTMLElement { return this._element; }\n    get tabsContainerElement(): HTMLElement { return this._tabsContainer.element; }\n    get controlsContainerElement(): HTMLElement { return this._controlsContainerElement; }\n\n    /** @internal */\n    constructor(\n        /** @internal */\n        private _layoutManager: LayoutManager,\n        /** @internal */\n        private _parent: Stack,\n        settings: Header.Settings,\n        /** @internal */\n        private readonly _configClosable: boolean,\n        /** @internal */\n        private _getActiveComponentItemEvent: Header.GetActiveComponentItemEvent,\n        closeEvent: Header.CloseEvent,\n        /** @internal */\n        private _popoutEvent: Header.PopoutEvent | undefined,\n        /** @internal */\n        private _maximiseToggleEvent: Header.MaximiseToggleEvent | undefined,\n        /** @internal */\n        private _clickEvent: Header.ClickEvent | undefined,\n        /** @internal */\n        private _touchStartEvent: Header.TouchStartEvent | undefined,\n        /** @internal */\n        private _componentRemoveEvent: Header.ComponentRemoveEvent | undefined,\n        /** @internal */\n        private _componentFocusEvent: Header.ComponentFocusEvent | undefined,\n        /** @internal */\n        private _componentDragStartEvent: Header.ComponentDragStartEvent | undefined,\n    ) {\n        super();\n\n        this._tabsContainer = new TabsContainer(this._layoutManager,\n            (item) => this.handleTabInitiatedComponentRemoveEvent(item),\n            (item) => this.handleTabInitiatedComponentFocusEvent(item),\n            (x, y, dragListener, item) => this.handleTabInitiatedDragStartEvent(x, y, dragListener, item),\n            () => this.processTabDropdownActiveChanged(),\n        );\n\n        this._show = settings.show;\n        this._popoutEnabled = settings.popoutEnabled;\n        this._popoutLabel = settings.popoutLabel;\n        this._maximiseEnabled = settings.maximiseEnabled;\n        this._maximiseLabel = settings.maximiseLabel;\n        this._minimiseEnabled = settings.minimiseEnabled;\n        this._minimiseLabel = settings.minimiseLabel;\n        this._closeEnabled = settings.closeEnabled;\n        this._closeLabel = settings.closeLabel;\n        this._tabDropdownEnabled = settings.tabDropdownEnabled;\n        this._tabDropdownLabel = settings.tabDropdownLabel;\n        this.setSide(settings.side);\n\n        this._canRemoveComponent = this._configClosable;\n\n        this._element = document.createElement('section');\n        this._element.classList.add(DomConstants.ClassName.Header);\n        this._controlsContainerElement = document.createElement('section');\n        this._controlsContainerElement.classList.add(DomConstants.ClassName.Controls);\n        this._element.appendChild(this._tabsContainer.element);\n        this._element.appendChild(this._controlsContainerElement);\n        this._element.appendChild(this._tabsContainer.dropdownElement);\n\n        this._element.addEventListener('click', this._clickListener, { passive: true });\n        this._element.addEventListener('touchstart', this._touchStartListener, { passive: true });\n\n        this._documentMouseUpListener = () => this._tabsContainer.hideAdditionalTabsDropdown()\n        globalThis.document.addEventListener('mouseup', this._documentMouseUpListener, { passive: true });\n\n        this._tabControlOffset = this._layoutManager.layoutConfig.settings.tabControlOffset;\n\n        if (this._tabDropdownEnabled) {\n            this._tabDropdownButton = new HeaderButton(this, this._tabDropdownLabel, DomConstants.ClassName.TabDropdown,\n                () => this._tabsContainer.showAdditionalTabsDropdown()\n            );\n        }\n\n        if (this._popoutEnabled) {\n            this._popoutButton = new HeaderButton(this, this._popoutLabel, DomConstants.ClassName.Popout, () => this.handleButtonPopoutEvent());\n        }\n\n        /**\n         * Maximise control - set the component to the full size of the layout\n         */\n        if (this._maximiseEnabled) {\n            this._maximiseButton = new HeaderButton(this, this._maximiseLabel, DomConstants.ClassName.Maximise,\n                (ev) => this.handleButtonMaximiseToggleEvent(ev)\n            );\n        }\n\n        /**\n         * Close button\n         */\n        if (this._configClosable) {\n            this._closeButton = new HeaderButton(this, this._closeLabel, DomConstants.ClassName.Close, () => closeEvent());\n        }\n\n        this.processTabDropdownActiveChanged();\n    }\n\n    /**\n     * Destroys the entire header\n     * @internal\n     */\n    destroy(): void {\n        this.emit('destroy');\n\n        this._popoutEvent = undefined;\n        this._maximiseToggleEvent = undefined;\n        this._clickEvent = undefined;\n        this._touchStartEvent = undefined;\n        this._componentRemoveEvent = undefined;\n        this._componentFocusEvent = undefined;\n        this._componentDragStartEvent = undefined;\n\n        this._tabsContainer.destroy();\n\n        globalThis.document.removeEventListener('mouseup', this._documentMouseUpListener);\n        this._element.remove();\n    }\n\n    /**\n     * Creates a new tab and associates it with a contentItem\n     * @param index - The position of the tab\n     * @internal\n     */\n    createTab(componentItem: ComponentItem, index: number): void {\n        this._tabsContainer.createTab(componentItem, index);\n    }\n\n    /**\n     * Finds a tab based on the contentItem its associated with and removes it.\n     * Cannot remove tab if it has the active ComponentItem\n     * @internal\n     */\n    removeTab(componentItem: ComponentItem): void {\n        this._tabsContainer.removeTab(componentItem);\n    }\n\n    /** @internal */\n    processActiveComponentChanged(newActiveComponentItem: ComponentItem): void {\n        this._tabsContainer.processActiveComponentChanged(newActiveComponentItem);\n        this.updateTabSizes();\n    }\n\n    /** @internal */\n    setSide(value: Side): void {\n        this._side = value;\n        this._leftRightSided = [Side.right, Side.left].includes(this._side);\n    }\n\n    /**\n     * Programmatically set closability.\n     * @param value - Whether to enable/disable closability.\n     * @returns Whether the action was successful\n     * @internal\n     */\n    setRowColumnClosable(value: boolean): void {\n        this._rowColumnClosable = value;\n        this.updateClosability();\n    }\n\n    /**\n     * Updates the header's closability. If a stack/header is able\n     * to close, but has a non closable component added to it, the stack is no\n     * longer closable until all components are closable.\n     * @internal\n     */\n    updateClosability(): void {\n        let isClosable: boolean;\n        if (!this._configClosable) {\n            isClosable = false;\n        } else {\n            if (!this._rowColumnClosable) {\n                isClosable = false;\n            } else {\n                isClosable = true;\n                const len = this.tabs.length;\n                for (let i = 0; i < len; i++) {\n                    const tab = this._tabsContainer.tabs[i];\n                    const item = tab.componentItem;\n                    if (!item.isClosable) {\n                        isClosable = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (this._closeButton !== null) {\n            setElementDisplayVisibility(this._closeButton.element, isClosable);\n        }\n        if (this._popoutButton !== null) {\n            setElementDisplayVisibility(this._popoutButton.element, isClosable);\n        }\n\n        this._canRemoveComponent = isClosable || this._tabsContainer.tabCount > 1;\n    }\n\n    /** @internal */\n    applyFocusedValue(value: boolean): void {\n        if (value) {\n            this._element.classList.add(DomConstants.ClassName.Focused);\n        } else {\n            this._element.classList.remove(DomConstants.ClassName.Focused);\n        }\n    }\n\n    /** @internal */\n    processMaximised(): void {\n        if (this._maximiseButton === undefined) {\n            throw new UnexpectedUndefinedError('HPMAX16997');\n        } else {\n            this._maximiseButton.element.setAttribute('title', this._minimiseLabel);\n        }\n    }\n\n    /** @internal */\n    processMinimised(): void {\n        if (this._maximiseButton === undefined) {\n            throw new UnexpectedUndefinedError('HPMIN16997');\n        } else {\n            this._maximiseButton.element.setAttribute('title', this._maximiseLabel);\n        }\n    }\n\n    /**\n     * Pushes the tabs to the tab dropdown if the available space is not sufficient\n     * @internal\n     */\n    updateTabSizes(): void {\n        if (this._tabsContainer.tabCount > 0) {\n            const headerHeight = this._show ? this._layoutManager.layoutConfig.dimensions.headerHeight : 0;\n\n            if (this._leftRightSided) {\n                this._element.style.height = '';\n                this._element.style.width = numberToPixels(headerHeight);\n            } else {\n                this._element.style.width = '';\n                this._element.style.height = numberToPixels(headerHeight);\n            }\n            let availableWidth: number;\n            if (this._leftRightSided) {\n                availableWidth = this._element.offsetHeight - this._controlsContainerElement.offsetHeight - this._tabControlOffset;\n            } else {\n                availableWidth = this._element.offsetWidth - this._controlsContainerElement.offsetWidth - this._tabControlOffset;\n            }\n\n            this._tabsContainer.updateTabSizes(availableWidth, this._getActiveComponentItemEvent());\n        }\n    }\n\n    /** @internal */\n    private handleTabInitiatedComponentRemoveEvent(componentItem: ComponentItem) {\n        if (this._canRemoveComponent) {\n            if (this._componentRemoveEvent === undefined) {\n                throw new UnexpectedUndefinedError('HHTCE22294');\n            } else {\n                this._componentRemoveEvent(componentItem);\n            }\n        }\n    }\n\n    /** @internal */\n    private handleTabInitiatedComponentFocusEvent(componentItem: ComponentItem) {\n        if (this._componentFocusEvent === undefined) {\n            throw new UnexpectedUndefinedError('HHTAE22294');\n        } else {\n            this._componentFocusEvent(componentItem);\n        }\n    }\n\n    /** @internal */\n    private handleTabInitiatedDragStartEvent(x: number, y: number, dragListener: DragListener, componentItem: ComponentItem) {\n        if (!this._canRemoveComponent) {\n            dragListener.cancelDrag();\n        } else {\n            if (this._componentDragStartEvent === undefined) {\n                throw new UnexpectedUndefinedError('HHTDSE22294');\n            } else {\n                this._componentDragStartEvent(x, y, dragListener, componentItem);\n            }\n        }\n    }\n\n    /** @internal */\n    private processTabDropdownActiveChanged() {\n        if (this._tabDropdownButton !== undefined) {\n            setElementDisplayVisibility(this._tabDropdownButton.element, this._tabsContainer.dropdownActive);\n        }\n    }\n\n    /** @internal */\n    private handleButtonPopoutEvent() {\n        if (this._layoutManager.layoutConfig.settings.popoutWholeStack) {\n            if (this._popoutEvent === undefined) {\n                throw new UnexpectedUndefinedError('HHBPOE17834');\n            } else {\n                this._popoutEvent();\n            }\n        } else {\n            const activeComponentItem = this._getActiveComponentItemEvent();\n            if (activeComponentItem) {\n                activeComponentItem.popout();\n            }\n            // else: if the stack is empty there won't be an active item (and nothing to popout)\n        }\n    }\n\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    private handleButtonMaximiseToggleEvent(ev: Event) {\n        if (this._maximiseToggleEvent === undefined) {\n            throw new UnexpectedUndefinedError('HHBMTE16834');\n        } else {\n            this._maximiseToggleEvent();\n        }\n    }\n\n    /**\n     * Invoked when the header's background is clicked (not it's tabs or controls)\n     * @internal\n     */\n    private onClick(event: MouseEvent) {\n        if (event.target === this._element) {\n            this.notifyClick(event);\n        }\n    }\n\n    /**\n     * Invoked when the header's background is touched (not it's tabs or controls)\n     * @internal\n     */\n    private onTouchStart(event: TouchEvent) {\n        if (event.target === this._element) {\n            this.notifyTouchStart(event);\n        }\n    }\n\n    /** @internal */\n    private notifyClick(ev: MouseEvent) {\n        if (this._clickEvent === undefined) {\n            throw new UnexpectedUndefinedError('HNHC46834');\n        } else {\n            this._clickEvent(ev);\n        }\n    }\n\n    /** @internal */\n    private notifyTouchStart(ev: TouchEvent) {\n        if (this._touchStartEvent === undefined) {\n            throw new UnexpectedUndefinedError('HNHTS46834');\n        } else {\n            this._touchStartEvent(ev);\n        }\n    }\n}\n\n/** @public */\nexport namespace Header {\n    /** @internal */\n    export type GetActiveComponentItemEvent = (this: void) => ComponentItem | undefined;\n    /** @internal */\n    export type CloseEvent = (this: void) => void;\n    /** @internal */\n    export type PopoutEvent = (this: void) => void;\n    /** @internal */\n    export type MaximiseToggleEvent = (this: void) => void;\n    /** @internal */\n    export type ClickEvent = (this: void, ev: MouseEvent) => void;\n    /** @internal */\n    export type TouchStartEvent = (this: void, ev: TouchEvent) => void;\n    /** @internal */\n    export type ComponentRemoveEvent = (this: void, componentItem: ComponentItem) => void;\n    /** @internal */\n    export type ComponentFocusEvent = (this: void, componentItem: ComponentItem) => void;\n    /** @internal */\n    export type ComponentDragStartEvent = (this: void, x: number, y: number, dragListener: DragListener, componentItem: ComponentItem) => void;\n    /** @internal */\n    export type StateChangedEvent = (this: void) => void;\n\n    /** @internal */\n    export interface Settings {\n        show: boolean;\n        side: Side;\n        popoutEnabled: boolean;\n        popoutLabel: string;\n        maximiseEnabled: boolean;\n        maximiseLabel: string;\n        minimiseEnabled: boolean;\n        minimiseLabel: string;\n        closeEnabled: boolean;\n        closeLabel: string;\n        tabDropdownEnabled: boolean;\n        tabDropdownLabel: string;\n    }\n}\n", "import { ComponentItemConfig, ItemConfig } from '../config/config';\nimport { ResolvedComponentItemConfig, ResolvedHeaderedItemConfig, ResolvedItemConfig, ResolvedStackItemConfig } from '../config/resolved-config';\nimport { Header } from '../controls/header';\nimport { AssertError, UnexpectedNullError, UnexpectedUndefinedError } from '../errors/internal-error';\nimport { LayoutManager } from '../layout-manager';\nimport { DomConstants } from '../utils/dom-constants';\nimport { DragListener } from '../utils/drag-listener';\nimport { EventEmitter } from '../utils/event-emitter';\nimport { AreaLinkedRect, ItemType, JsonValue, Side, SizeUnitEnum, WidthAndHeight, WidthOrHeightPropertyName } from '../utils/types';\nimport {\n    getElementWidthAndHeight,\n    numberToPixels,\n    setElementDisplayVisibility\n} from '../utils/utils';\nimport { ComponentItem } from './component-item';\nimport { ComponentParentableItem } from './component-parentable-item';\nimport { ContentItem } from './content-item';\n\n/** @public */\nexport class Stack extends ComponentParentableItem {\n    /** @internal */\n    private readonly _headerConfig: ResolvedHeaderedItemConfig.Header | undefined;\n    /** @internal */\n    private readonly _header: Header;\n    /** @internal */\n    private readonly _childElementContainer: HTMLElement;\n    /** @internal */\n    private readonly _maximisedEnabled: boolean;\n    /** @internal */\n    private _activeComponentItem: ComponentItem | undefined;\n    /** @internal */\n    private _dropSegment: Stack.Segment;\n    /** @internal */\n    private _dropIndex: number;\n    /** @internal */\n    private _contentAreaDimensions: Stack.ContentAreaDimensions;\n    /** @internal */\n    private _headerSideChanged = false;\n    /** @internal */\n    private readonly _initialWantMaximise: boolean;\n    /** @internal */\n    private _initialActiveItemIndex: number;\n\n    /** @internal */\n    private _resizeListener = () => this.handleResize();\n    /** @internal */\n    private _maximisedListener = () => this.handleMaximised();\n    /** @internal */\n    private _minimisedListener = () => this.handleMinimised();\n\n    get childElementContainer(): HTMLElement { return this._childElementContainer; }\n    get header(): Header { return this._header; }\n    get headerShow(): boolean { return this._header.show; }\n    get headerSide(): Side { return this._header.side; }\n    get headerLeftRightSided(): boolean { return this._header.leftRightSided; }\n    /** @internal */\n    get contentAreaDimensions(): Stack.ContentAreaDimensions | undefined { return this._contentAreaDimensions; }\n    /** @internal */\n    get initialWantMaximise(): boolean { return this._initialWantMaximise; }\n    get isMaximised(): boolean { return this === this.layoutManager.maximisedStack; }\n    get stackParent(): ContentItem {\n        if (!this.parent) {\n            throw new Error('Stack should always have a parent');\n        }\n        return this.parent;\n    }\n\n    /** @internal */\n    constructor(layoutManager: LayoutManager, config: ResolvedStackItemConfig, parent: ContentItem) {\n        super(layoutManager, config, parent, Stack.createElement(document));\n\n        this._headerConfig = config.header;\n        const layoutHeaderConfig = layoutManager.layoutConfig.header;\n        const configContent = config.content;\n        // If stack has only one component, then we can also check this for header settings\n        let componentHeaderConfig: ResolvedHeaderedItemConfig.Header | undefined;\n        if (configContent.length !== 1) {\n            componentHeaderConfig = undefined;\n        } else {\n            const firstChildItemConfig = configContent[0];\n            componentHeaderConfig = (firstChildItemConfig as ResolvedHeaderedItemConfig).header; // will be undefined if not component (and wont be stack)\n        }\n\n        this._initialWantMaximise = config.maximised;\n        this._initialActiveItemIndex = config.activeItemIndex ?? 0; // make sure defined\n\n        // check for defined value for each item in order of Stack (this Item), Component (first child), Manager.\n        const show = this._headerConfig?.show ?? componentHeaderConfig?.show ?? layoutHeaderConfig.show;\n        const popout = this._headerConfig?.popout ?? componentHeaderConfig?.popout ?? layoutHeaderConfig.popout;\n        const maximise = this._headerConfig?.maximise ?? componentHeaderConfig?.maximise ?? layoutHeaderConfig.maximise;\n        const close = this._headerConfig?.close ?? componentHeaderConfig?.close ?? layoutHeaderConfig.close;\n        const minimise = this._headerConfig?.minimise ?? componentHeaderConfig?.minimise ?? layoutHeaderConfig.minimise;\n        const tabDropdown = this._headerConfig?.tabDropdown ?? componentHeaderConfig?.tabDropdown ?? layoutHeaderConfig.tabDropdown;\n        this._maximisedEnabled = maximise !== false;\n        const headerSettings: Header.Settings = {\n            show: show !== false,\n            side: show === false ? Side.top : show,\n            popoutEnabled: popout !== false,\n            popoutLabel: popout === false ? '' : popout,\n            maximiseEnabled: this._maximisedEnabled,\n            maximiseLabel: maximise === false ? '' : maximise,\n            closeEnabled: close !== false,\n            closeLabel: close === false ? '' : close,\n            minimiseEnabled: true,\n            minimiseLabel: minimise,\n            tabDropdownEnabled: tabDropdown !== false,\n            tabDropdownLabel: tabDropdown === false ? '' : tabDropdown,\n        };\n\n        this._header = new Header(layoutManager,\n            this, headerSettings,\n            config.isClosable && close !== false,\n            () => this.getActiveComponentItem(),\n            () => this.remove(),\n            () => this.handlePopoutEvent(),\n            () => this.toggleMaximise(),\n            (ev) => this.handleHeaderClickEvent(ev),\n            (ev) => this.handleHeaderTouchStartEvent(ev),\n            (item) => this.handleHeaderComponentRemoveEvent(item),\n            (item) => this.handleHeaderComponentFocusEvent(item),\n            (x, y, dragListener, item) => this.handleHeaderComponentStartDragEvent(x, y, dragListener, item),\n        );\n\n        // this._dropZones = {};\n\n        this.isStack = true;\n\n        this._childElementContainer = document.createElement('section');\n        this._childElementContainer.classList.add(DomConstants.ClassName.Items);\n\n        this.on('resize', this._resizeListener);\n        if (this._maximisedEnabled) {\n            this.on('maximised', this._maximisedListener);\n            this.on('minimised', this._minimisedListener);\n        }\n\n        this.element.appendChild(this._header.element);\n        this.element.appendChild(this._childElementContainer);\n\n        this.setupHeaderPosition();\n        this._header.updateClosability();\n    }\n\n    /** @internal */\n    override updateSize(force: boolean): void {\n        this.layoutManager.beginVirtualSizedContainerAdding();\n        try {\n            this.updateNodeSize();\n            this.updateContentItemsSize(force);\n        } finally {\n            this.layoutManager.endVirtualSizedContainerAdding();\n        }\n    }\n\n    /** @internal */\n    override init(): void {\n        if (this.isInitialised === true) return;\n\n        this.updateNodeSize();\n\n        for (let i = 0; i < this.contentItems.length; i++) {\n            this._childElementContainer.appendChild(this.contentItems[i].element);\n        }\n\n        super.init();\n\n        const contentItems = this.contentItems;\n        const contentItemCount = contentItems.length;\n        if (contentItemCount > 0) { // contentItemCount will be 0 on drag drop\n            if (this._initialActiveItemIndex < 0 || this._initialActiveItemIndex >= contentItemCount) {\n                throw new Error(`ActiveItemIndex out of range: ${this._initialActiveItemIndex} id: ${this.id}`);\n            } else {\n                for (let i = 0; i < contentItemCount; i++) {\n                    const contentItem = contentItems[i];\n                    if (!(contentItem instanceof ComponentItem)) {\n                        throw new Error(`Stack Content Item is not of type ComponentItem: ${i} id: ${this.id}`);\n                    } else {\n                        this._header.createTab(contentItem, i);\n                        contentItem.hide();\n                        contentItem.container.setBaseLogicalZIndex();\n                    }\n                }\n\n                this.setActiveComponentItem(contentItems[this._initialActiveItemIndex] as ComponentItem, false);\n\n                this._header.updateTabSizes();\n            }\n        }\n\n        this._header.updateClosability();\n        this.initContentItems();\n    }\n\n    /** @deprecated Use {@link (Stack:class).setActiveComponentItem} */\n    setActiveContentItem(item: ContentItem): void {\n        if (!ContentItem.isComponentItem(item)) {\n            throw new Error('Stack.setActiveContentItem: item is not a ComponentItem');\n        } else {\n            this.setActiveComponentItem(item, false);\n        }\n    }\n\n    setActiveComponentItem(componentItem: ComponentItem, focus: boolean, suppressFocusEvent = false): void {\n        if (this._activeComponentItem !== componentItem) {\n            if (this.contentItems.indexOf(componentItem) === -1) {\n                throw new Error('componentItem is not a child of this stack');\n            } else {\n                this.layoutManager.beginSizeInvalidation();\n                try {\n                    if (this._activeComponentItem !== undefined) {\n                        this._activeComponentItem.hide();\n                    }\n                    this._activeComponentItem = componentItem;\n                    this._header.processActiveComponentChanged(componentItem);\n                    componentItem.show();\n                } finally {\n                    this.layoutManager.endSizeInvalidation();\n                }\n\n                this.emit('activeContentItemChanged', componentItem);\n                this.layoutManager.emit('activeContentItemChanged', componentItem);\n                this.emitStateChangedEvent();\n            }\n        }\n\n        if (this.focused || focus) {\n            this.layoutManager.setFocusedComponentItem(componentItem, suppressFocusEvent);\n        }\n    }\n\n    /** @deprecated Use {@link (Stack:class).getActiveComponentItem} */\n    getActiveContentItem(): ContentItem | null {\n        return this.getActiveComponentItem() ?? null;\n    }\n\n    getActiveComponentItem(): ComponentItem | undefined {\n        return this._activeComponentItem;\n    }\n\n    /** @internal */\n    focusActiveContentItem(): void {\n        this._activeComponentItem?.focus();\n    }\n\n    /** @internal */\n    override setFocusedValue(value: boolean): void {\n        this._header.applyFocusedValue(value);\n        super.setFocusedValue(value);\n    }\n\n    /** @internal */\n    setRowColumnClosable(value: boolean): void {\n        this._header.setRowColumnClosable(value);\n    }\n\n    newComponent(componentType: JsonValue, componentState?: JsonValue, title?: string, index?: number): ComponentItem {\n        const itemConfig: ComponentItemConfig = {\n            type: 'component',\n            componentType,\n            componentState,\n            title,\n        };\n        return this.newItem(itemConfig, index) as ComponentItem;\n    }\n\n    addComponent(componentType: JsonValue, componentState?: JsonValue, title?: string, index?: number): number {\n        const itemConfig: ComponentItemConfig = {\n            type: 'component',\n            componentType,\n            componentState,\n            title,\n        };\n        return this.addItem(itemConfig, index);\n    }\n\n    newItem(itemConfig: ComponentItemConfig,  index?: number): ContentItem {\n        index = this.addItem(itemConfig, index);\n        return this.contentItems[index];\n    }\n\n    addItem(itemConfig: ComponentItemConfig, index?: number): number {\n        this.layoutManager.checkMinimiseMaximisedStack();\n\n        const resolvedItemConfig = ItemConfig.resolve(itemConfig, false);\n        const contentItem = this.layoutManager.createAndInitContentItem(resolvedItemConfig, this);\n        return this.addChild(contentItem, index);\n    }\n\n    override addChild(contentItem: ContentItem, index?: number, focus = false): number {\n        if(index !== undefined && index > this.contentItems.length){\n            index -= 1;\n            throw new AssertError('SAC99728'); // undisplayChild() removed so this condition should no longer occur\n        }\n\n        if (!(contentItem instanceof ComponentItem)) {\n            throw new AssertError('SACC88532'); // Stacks can only have Component children\n        } else {\n            index = super.addChild(contentItem, index);\n            this._childElementContainer.appendChild(contentItem.element);\n            this._header.createTab(contentItem, index);\n            this.setActiveComponentItem(contentItem, focus);\n            this._header.updateTabSizes();\n            this.updateSize(false);\n            contentItem.container.setBaseLogicalZIndex();\n            this._header.updateClosability();\n            this.emitStateChangedEvent();\n            return index;\n        }\n    }\n\n    override removeChild(contentItem: ContentItem, keepChild: boolean): void {\n        const componentItem = contentItem as ComponentItem;\n        const index = this.contentItems.indexOf(componentItem);\n        const stackWillBeDeleted = this.contentItems.length === 1;\n\n        if (this._activeComponentItem === componentItem) {\n            if (componentItem.focused) {\n                componentItem.blur();\n            }\n            if (!stackWillBeDeleted) {\n                // At this point we're already sure we have at least one content item left *after*\n                // removing contentItem, so we can safely assume index 1 is a valid one if\n                // the index of contentItem is 0, otherwise we just use the previous content item.\n                const newActiveComponentIdx = index === 0 ? 1 : index - 1;\n                this.setActiveComponentItem(this.contentItems[newActiveComponentIdx] as ComponentItem, false);\n            }\n        }\n\n        this._header.removeTab(componentItem);\n\n        super.removeChild(componentItem, keepChild);\n\n        if (!stackWillBeDeleted) {\n            this._header.updateClosability();\n        }\n\n        this.emitStateChangedEvent();\n    }\n\n    /**\n     * Maximises the Item or minimises it if it is already maximised\n     */\n    toggleMaximise(): void {\n        if (this.isMaximised) {\n            this.minimise();\n        } else {\n            this.maximise();\n        }\n    }\n\n    maximise(): void {\n        if (!this.isMaximised) {\n            this.layoutManager.setMaximisedStack(this);\n            const contentItems = this.contentItems;\n            const contentItemCount = contentItems.length;\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                if (contentItem instanceof ComponentItem) {\n                    contentItem.enterStackMaximised();\n                } else {\n                    throw new AssertError('SMAXI87773');\n                }\n            }\n            this.emitStateChangedEvent();\n        }\n    }\n\n    minimise(): void {\n        if (this.isMaximised) {\n            this.layoutManager.setMaximisedStack(undefined);\n            const contentItems = this.contentItems;\n            const contentItemCount = contentItems.length;\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                if (contentItem instanceof ComponentItem) {\n                    contentItem.exitStackMaximised();\n                } else {\n                    throw new AssertError('SMINI87773');\n                }\n            }\n            this.emitStateChangedEvent();\n        }\n    }\n\n    /** @internal */\n    override destroy(): void {\n        if (this._activeComponentItem?.focused) {\n            this._activeComponentItem.blur();\n        }\n        super.destroy();\n        this.off('resize', this._resizeListener);\n        if (this._maximisedEnabled) {\n            this.off('maximised', this._maximisedListener);\n            this.off('minimised', this._minimisedListener);\n        }\n        this._header.destroy();\n    }\n\n    toConfig(): ResolvedStackItemConfig {\n        let activeItemIndex: number | undefined;\n        if (this._activeComponentItem) {\n            activeItemIndex = this.contentItems.indexOf(this._activeComponentItem);\n            if (activeItemIndex < 0) {\n                throw new Error('active component item not found in stack');\n            }\n        }\n        if (this.contentItems.length > 0 && activeItemIndex === undefined) {\n            throw new Error('expected non-empty stack to have an active component item');\n        } else {\n            const result: ResolvedStackItemConfig = {\n                type: 'stack',\n                content: this.calculateConfigContent() as ResolvedComponentItemConfig[],\n                size: this.size,\n                sizeUnit: this.sizeUnit,\n                minSize: this.minSize,\n                minSizeUnit: this.minSizeUnit,\n                id: this.id,\n                isClosable: this.isClosable,\n                maximised: this.isMaximised,\n                header: this.createHeaderConfig(),\n                activeItemIndex,\n            }\n            return result;\n        }\n    }\n\n    /**\n     * Ok, this one is going to be the tricky one: The user has dropped a {@link (ContentItem:class)} onto this stack.\n     *\n     * It was dropped on either the stacks header or the top, right, bottom or left bit of the content area\n     * (which one of those is stored in this._dropSegment). Now, if the user has dropped on the header the case\n     * is relatively clear: We add the item to the existing stack... job done (might be good to have\n     * tab reordering at some point, but lets not sweat it right now)\n     *\n     * If the item was dropped on the content part things are a bit more complicated. If it was dropped on either the\n     * top or bottom region we need to create a new column and place the items accordingly.\n     * Unless, of course if the stack is already within a column... in which case we want\n     * to add the newly created item to the existing column...\n     * either prepend or append it, depending on wether its top or bottom.\n     *\n     * Same thing for rows and left / right drop segments... so in total there are 9 things that can potentially happen\n     * (left, top, right, bottom) * is child of the right parent (row, column) + header drop\n     *\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    override onDrop(contentItem: ContentItem, area: ContentItem.Area): void {\n        /*\n         * The item was dropped on the header area. Just add it as a child of this stack and\n         * get the hell out of this logic\n         */\n        if (this._dropSegment === Stack.Segment.Header) {\n            this.resetHeaderDropZone();\n            if (this._dropIndex === undefined) {\n                throw new UnexpectedUndefinedError('SODDI68990');\n            } else {\n                this.addChild(contentItem, this._dropIndex);\n                return;\n            }\n        }\n\n        /*\n         * The stack is empty. Let's just add the element.\n         */\n        if (this._dropSegment === Stack.Segment.Body) {\n            this.addChild(contentItem, 0, true);\n            return;\n        }\n\n        /*\n         * The item was dropped on the top-, left-, bottom- or right- part of the content. Let's\n         * aggregate some conditions to make the if statements later on more readable\n         */\n        const isVertical = this._dropSegment === Stack.Segment.Top || this._dropSegment === Stack.Segment.Bottom;\n        const isHorizontal = this._dropSegment === Stack.Segment.Left || this._dropSegment === Stack.Segment.Right;\n        const insertBefore = this._dropSegment === Stack.Segment.Top || this._dropSegment === Stack.Segment.Left;\n        const hasCorrectParent = (isVertical && this.stackParent.isColumn) || (isHorizontal && this.stackParent.isRow);\n\n        /*\n         * The content item can be either a component or a stack. If it is a component, wrap it into a stack\n         */\n        if (contentItem.isComponent) {\n            const itemConfig = ResolvedStackItemConfig.createDefault();\n            itemConfig.header = this.createHeaderConfig();\n            const stack = this.layoutManager.createAndInitContentItem(itemConfig, this);\n            stack.addChild(contentItem);\n            contentItem = stack;\n        }\n\n\n        /*\n         * If the contentItem that's being dropped is not dropped on a Stack (cases which just passed above and\n         * which would wrap the contentItem in a Stack) we need to check whether contentItem is a RowOrColumn.\n         * If it is, we need to re-wrap it in a Stack like it was when it was dragged by its Tab (it was dragged!).\n         */\n        if(contentItem.type === ItemType.row || contentItem.type === ItemType.column){\n            const itemConfig = ResolvedStackItemConfig.createDefault();\n            itemConfig.header = this.createHeaderConfig();\n            const stack = this.layoutManager.createContentItem(itemConfig, this);\n            stack.addChild(contentItem)\n            contentItem = stack\n        }\n\n        /*\n         * If the item is dropped on top or bottom of a column or left and right of a row, it's already\n         * layd out in the correct way. Just add it as a child\n         */\n        if (hasCorrectParent) {\n            const index = this.stackParent.contentItems.indexOf(this);\n            this.stackParent.addChild(contentItem, insertBefore ? index : index + 1, true);\n            this.size *= 0.5;\n            contentItem.size = this.size;\n            contentItem.sizeUnit = this.sizeUnit;\n            this.stackParent.updateSize(false);\n            /*\n             * This handles items that are dropped on top or bottom of a row or left / right of a column. We need\n             * to create the appropriate contentItem for them to live in\n             */\n        } else {\n            const type = isVertical ? ItemType.column : ItemType.row;\n            const itemConfig = ResolvedItemConfig.createDefault(type) as ResolvedItemConfig;\n            const rowOrColumn = this.layoutManager.createContentItem(itemConfig, this);\n            this.stackParent.replaceChild(this, rowOrColumn);\n\n            rowOrColumn.addChild(contentItem, insertBefore ? 0 : undefined, true);\n            rowOrColumn.addChild(this, insertBefore ? undefined : 0, true);\n\n            this.size = 50;\n            contentItem.size = 50;\n            contentItem.sizeUnit = SizeUnitEnum.Percent;\n            rowOrColumn.updateSize(false);\n        }\n    }\n\n    /**\n     * If the user hovers above the header part of the stack, indicate drop positions for tabs.\n     * otherwise indicate which segment of the body the dragged item would be dropped on\n     *\n     * @param x - Absolute Screen X\n     * @param y - Absolute Screen Y\n     * @internal\n     */\n    override highlightDropZone(x: number, y: number): void {\n        for (const key in this._contentAreaDimensions) {\n            const segment = key as Stack.Segment;\n            const area = this._contentAreaDimensions[segment].hoverArea;\n\n            if (area.x1 < x && area.x2 > x && area.y1 < y && area.y2 > y) {\n\n                if (segment === Stack.Segment.Header) {\n                    this._dropSegment = Stack.Segment.Header;\n                    this.highlightHeaderDropZone(this._header.leftRightSided ? y : x);\n                } else {\n                    this.resetHeaderDropZone();\n                    this.highlightBodyDropZone(segment);\n                }\n\n                return;\n            }\n        }\n    }\n\n    /** @internal */\n    getArea(): ContentItem.Area | null {\n        if (this.element.style.display === 'none') {\n            return null;\n        }\n\n        const headerArea = super.getElementArea(this._header.element);\n        const contentArea = super.getElementArea(this._childElementContainer);\n        if (headerArea === null || contentArea === null) {\n            throw new UnexpectedNullError('SGAHC13086');\n        }\n        const contentWidth = contentArea.x2 - contentArea.x1;\n        const contentHeight = contentArea.y2 - contentArea.y1;\n\n        this._contentAreaDimensions = {\n            header: {\n                hoverArea: {\n                    x1: headerArea.x1,\n                    y1: headerArea.y1,\n                    x2: headerArea.x2,\n                    y2: headerArea.y2\n                },\n                highlightArea: {\n                    x1: headerArea.x1,\n                    y1: headerArea.y1,\n                    x2: headerArea.x2,\n                    y2: headerArea.y2\n                }\n            }\n        };\n\n        /**\n         * Highlight the entire body if the stack is empty\n         */\n        if (this.contentItems.length === 0) {\n\n            this._contentAreaDimensions.body = {\n                hoverArea: {\n                    x1: contentArea.x1,\n                    y1: contentArea.y1,\n                    x2: contentArea.x2,\n                    y2: contentArea.y2\n                },\n                highlightArea: {\n                    x1: contentArea.x1,\n                    y1: contentArea.y1,\n                    x2: contentArea.x2,\n                    y2: contentArea.y2\n                }\n            };\n\n            return super.getElementArea(this.element);\n        } else {\n            this._contentAreaDimensions.left = {\n                hoverArea: {\n                    x1: contentArea.x1,\n                    y1: contentArea.y1,\n                    x2: contentArea.x1 + contentWidth * 0.25,\n                    y2: contentArea.y2\n                },\n                highlightArea: {\n                    x1: contentArea.x1,\n                    y1: contentArea.y1,\n                    x2: contentArea.x1 + contentWidth * 0.5,\n                    y2: contentArea.y2\n                }\n            };\n\n            this._contentAreaDimensions.top = {\n                hoverArea: {\n                    x1: contentArea.x1 + contentWidth * 0.25,\n                    y1: contentArea.y1,\n                    x2: contentArea.x1 + contentWidth * 0.75,\n                    y2: contentArea.y1 + contentHeight * 0.5\n                },\n                highlightArea: {\n                    x1: contentArea.x1,\n                    y1: contentArea.y1,\n                    x2: contentArea.x2,\n                    y2: contentArea.y1 + contentHeight * 0.5\n                }\n            };\n\n            this._contentAreaDimensions.right = {\n                hoverArea: {\n                    x1: contentArea.x1 + contentWidth * 0.75,\n                    y1: contentArea.y1,\n                    x2: contentArea.x2,\n                    y2: contentArea.y2\n                },\n                highlightArea: {\n                    x1: contentArea.x1 + contentWidth * 0.5,\n                    y1: contentArea.y1,\n                    x2: contentArea.x2,\n                    y2: contentArea.y2\n                }\n            };\n\n            this._contentAreaDimensions.bottom = {\n                hoverArea: {\n                    x1: contentArea.x1 + contentWidth * 0.25,\n                    y1: contentArea.y1 + contentHeight * 0.5,\n                    x2: contentArea.x1 + contentWidth * 0.75,\n                    y2: contentArea.y2\n                },\n                highlightArea: {\n                    x1: contentArea.x1,\n                    y1: contentArea.y1 + contentHeight * 0.5,\n                    x2: contentArea.x2,\n                    y2: contentArea.y2\n                }\n            };\n\n            return super.getElementArea(this.element);\n        }\n    }\n\n    /**\n     * Programmatically operate with header position.\n     *\n     * @param position -\n     *\n     * @returns previous header position\n     * @internal\n     */\n    positionHeader(position: Side): void {\n        if (this._header.side !== position) {\n            this._header.setSide(position);\n            this._headerSideChanged = true;\n            this.setupHeaderPosition();\n        }\n    }\n\n    /** @internal */\n    private updateNodeSize(): void {\n        if (this.element.style.display !== 'none') {\n            const content: WidthAndHeight = getElementWidthAndHeight(this.element);\n\n            if (this._header.show) {\n                const dimension = this._header.leftRightSided ? WidthOrHeightPropertyName.width : WidthOrHeightPropertyName.height;\n                content[dimension] -= this.layoutManager.layoutConfig.dimensions.headerHeight;\n            }\n            this._childElementContainer.style.width = numberToPixels(content.width);\n            this._childElementContainer.style.height = numberToPixels(content.height);\n            for (let i = 0; i < this.contentItems.length; i++) {\n                this.contentItems[i].element.style.width = numberToPixels(content.width);\n                this.contentItems[i].element.style.height = numberToPixels(content.height);\n            }\n            this.emit('resize');\n            this.emitStateChangedEvent();\n        }\n    }\n\n    /** @internal */\n    private highlightHeaderDropZone(x: number): void {\n        const visibleTabsLength = this._header.lastVisibleTabIndex + 1;\n        const tabsContainerElement = this._header.tabsContainerElement;\n        const tabsContainerElementChildNodes = tabsContainerElement.childNodes;\n\n        // Create shallow copy of childNodes list, excluding DropPlaceHolder, as we will be modifying the childNodes list\n        const visibleTabElements = new Array<HTMLElement>(visibleTabsLength);\n        let tabIndex = 0;\n        let tabCount = 0;\n        while (tabCount < visibleTabsLength) {\n            const visibleTabElement = tabsContainerElementChildNodes[tabIndex++] as HTMLElement;\n            if (visibleTabElement !== this.layoutManager.tabDropPlaceholder) {\n                visibleTabElements[tabCount++] = visibleTabElement;\n            }\n        }\n\n        const dropTargetIndicator = this.layoutManager.dropTargetIndicator;\n        if (dropTargetIndicator === null) {\n            throw new UnexpectedNullError('SHHDZDTI97110');\n        }\n\n        let area: AreaLinkedRect;\n\n        // Empty stack\n        if (visibleTabsLength === 0) {\n            const headerRect = this._header.element.getBoundingClientRect();\n            const headerTop = headerRect.top + document.body.scrollTop;\n            const headerLeft = headerRect.left + document.body.scrollLeft;\n\n            area = {\n                x1: headerLeft,\n                x2: headerLeft + 100,\n                y1: headerTop + headerRect.height - 20,\n                y2: headerTop + headerRect.height,\n            };\n\n            this._dropIndex = 0;\n        } else {\n            let tabIndex = 0;\n            // This indicates whether our cursor is exactly over a tab\n            let isAboveTab = false;\n            let tabTop: number;\n            let tabLeft: number;\n            let tabWidth: number;\n            let tabElement: HTMLElement;\n            do {\n                tabElement = visibleTabElements[tabIndex] as HTMLElement;\n                const tabRect = tabElement.getBoundingClientRect();\n                const tabRectTop = tabRect.top + document.body.scrollTop;\n                const tabRectLeft = tabRect.left + document.body.scrollLeft;\n\n                if (this._header.leftRightSided) {\n                    tabLeft = tabRectTop;\n                    tabTop = tabRectLeft;\n                    tabWidth = tabRect.height;\n                } else {\n                    tabLeft = tabRectLeft;\n                    tabTop = tabRectTop;\n                    tabWidth = tabRect.width;\n                }\n\n                if (x >= tabLeft && x < tabLeft + tabWidth) {\n                    isAboveTab = true;\n                } else {\n                    tabIndex++;\n                }\n            } while (tabIndex < visibleTabsLength && !isAboveTab);\n\n            // If we're not above any tabs, or to the right of any tab, we are out of the area, so give up\n            if (isAboveTab === false && x < tabLeft) {\n                return;\n            }\n\n            const halfX = tabLeft + tabWidth / 2;\n\n            if (x < halfX) {\n                this._dropIndex = tabIndex;\n                tabElement.insertAdjacentElement('beforebegin', this.layoutManager.tabDropPlaceholder);\n            } else {\n                this._dropIndex = Math.min(tabIndex + 1, visibleTabsLength);\n                tabElement.insertAdjacentElement('afterend', this.layoutManager.tabDropPlaceholder);\n            }\n\n            const tabDropPlaceholderRect = this.layoutManager.tabDropPlaceholder.getBoundingClientRect();\n            const tabDropPlaceholderRectTop = tabDropPlaceholderRect.top + document.body.scrollTop;\n            const tabDropPlaceholderRectLeft = tabDropPlaceholderRect.left + document.body.scrollLeft;\n            const tabDropPlaceholderRectWidth = tabDropPlaceholderRect.width;\n\n            if (this._header.leftRightSided) {\n                const placeHolderTop = tabDropPlaceholderRectTop;\n                area = {\n                    x1: tabTop,\n                    x2: tabTop + tabElement.clientHeight,\n                    y1: placeHolderTop,\n                    y2: placeHolderTop + tabDropPlaceholderRectWidth,\n                };\n            } else {\n                const placeHolderLeft = tabDropPlaceholderRectLeft;\n\n                area = {\n                    x1: placeHolderLeft,\n                    x2: placeHolderLeft + tabDropPlaceholderRectWidth,\n                    y1: tabTop,\n                    y2: tabTop + tabElement.clientHeight,\n                };\n            }\n        }\n\n        dropTargetIndicator.highlightArea(area, 0);\n        return;\n    }\n\n    /** @internal */\n    private resetHeaderDropZone() {\n        this.layoutManager.tabDropPlaceholder.remove();\n    }\n\n    /** @internal */\n    private setupHeaderPosition() {\n        setElementDisplayVisibility(this._header.element, this._header.show);\n        this.element.classList.remove(DomConstants.ClassName.Left, DomConstants.ClassName.Right, DomConstants.ClassName.Bottom);\n        if (this._header.leftRightSided) {\n            this.element.classList.add('lm_' + this._header.side);\n        }\n\n        //if ([Side.right, Side.bottom].includes(this._header.side)) {\n        //    // move the header behind the content.\n        //    this.element.appendChild(this._header.element);\n        //}\n        this.updateSize(false);\n    }\n\n    /** @internal */\n    private highlightBodyDropZone(segment: Stack.Segment): void {\n        if (this._contentAreaDimensions === undefined) {\n            throw new UnexpectedUndefinedError('SHBDZC82265');\n        } else {\n            const highlightArea = this._contentAreaDimensions[segment].highlightArea;\n            const dropTargetIndicator = this.layoutManager.dropTargetIndicator;\n            if (dropTargetIndicator === null) {\n                throw new UnexpectedNullError('SHBDZD96110');\n            } else {\n                dropTargetIndicator.highlightArea(highlightArea, 1);\n                this._dropSegment = segment;\n            }\n        }\n    }\n\n    /** @internal */\n    private handleResize() {\n        this._header.updateTabSizes()\n    }\n\n    /** @internal */\n    private handleMaximised() {\n        this._header.processMaximised();\n    }\n\n    /** @internal */\n    private handleMinimised() {\n        this._header.processMinimised();\n    }\n\n    /** @internal */\n    private handlePopoutEvent() {\n        this.popout();\n    }\n\n    /** @internal */\n    private handleHeaderClickEvent(ev: MouseEvent) {\n        const eventName = EventEmitter.headerClickEventName;\n        const bubblingEvent = new EventEmitter.ClickBubblingEvent(eventName, this, ev);\n        this.emit(eventName, bubblingEvent);\n    }\n\n    /** @internal */\n    private handleHeaderTouchStartEvent(ev: TouchEvent) {\n        const eventName = EventEmitter.headerTouchStartEventName;\n        const bubblingEvent = new EventEmitter.TouchStartBubblingEvent(eventName, this, ev);\n        this.emit(eventName, bubblingEvent);\n    }\n\n    /** @internal */\n    private handleHeaderComponentRemoveEvent(item: ComponentItem) {\n        this.removeChild(item, false);\n    }\n\n    /** @internal */\n    private handleHeaderComponentFocusEvent(item: ComponentItem) {\n        this.setActiveComponentItem(item, true);\n    }\n\n    /** @internal */\n    private handleHeaderComponentStartDragEvent(x: number, y: number, dragListener: DragListener, componentItem: ComponentItem) {\n        if (this.isMaximised === true) {\n            this.toggleMaximise();\n        }\n        this.layoutManager.startComponentDrag(x, y, dragListener, componentItem, this);\n    }\n\n    /** @internal */\n    private createHeaderConfig() {\n        if (!this._headerSideChanged) {\n            return ResolvedHeaderedItemConfig.Header.createCopy(this._headerConfig);\n        } else {\n            const show = this._header.show ? this._header.side : false;\n\n            let result = ResolvedHeaderedItemConfig.Header.createCopy(this._headerConfig, show);\n            if (result === undefined) {\n                result = {\n                    show,\n                    popout: undefined,\n                    maximise: undefined,\n                    close: undefined,\n                    minimise: undefined,\n                    tabDropdown: undefined,\n                };\n            }\n            return result;\n        }\n    }\n\n    /** @internal */\n    private emitStateChangedEvent() {\n        this.emitBaseBubblingEvent('stateChanged');\n    }\n}\n\n/** @public */\nexport namespace Stack {\n    /** @internal */\n    export const enum Segment {\n        Header = 'header',\n        Body = 'body',\n        Left = 'left',\n        Right = 'right',\n        Top = 'top',\n        Bottom = 'bottom',\n    }\n\n    /** @internal */\n    export interface ContentAreaDimension {\n        hoverArea: AreaLinkedRect;\n        highlightArea: AreaLinkedRect;\n    }\n\n    /** @internal */\n    export type ContentAreaDimensions = {\n        [segment: string]: ContentAreaDimension;\n    };\n\n    /** @internal */\n    export function createElement(document: Document): HTMLDivElement {\n        const element = document.createElement('div');\n        element.classList.add(DomConstants.ClassName.Item);\n        element.classList.add(DomConstants.ClassName.Stack);\n        return element;\n    }\n}\n", "import { UnexpectedNullError, UnexpectedUndefinedError } from '../errors/internal-error';\nimport { ComponentItem } from '../items/component-item';\nimport { ContentItem } from '../items/content-item';\nimport { Stack } from '../items/stack';\nimport { LayoutManager } from '../layout-manager';\nimport { DomConstants } from '../utils/dom-constants';\nimport { DragListener } from '../utils/drag-listener';\nimport { EventEmitter } from '../utils/event-emitter';\nimport { Side } from '../utils/types';\nimport {\n    numberToPixels\n} from '../utils/utils';\n\n/**\n * This class creates a temporary container\n * for the component whilst it is being dragged\n * and handles drag events\n * @internal\n */\nexport class DragProxy extends EventEmitter {\n    private _area: ContentItem.Area | null = null;\n    private _lastValidArea: ContentItem.Area | null = null;\n    private _minX: number;\n    private _minY: number;\n    private _maxX: number;\n    private _maxY: number;\n    private _sided: boolean;\n    private _element: HTMLElement;\n    private _proxyContainerElement: HTMLElement;\n    private _componentItemFocused: boolean;\n\n    get element(): HTMLElement { return this._element; }\n\n    /**\n     * @param x - The initial x position\n     * @param y - The initial y position\n     * @internal\n     */\n    constructor(x: number, y: number,\n        private readonly _dragListener: DragListener,\n        private readonly _layoutManager: LayoutManager,\n        private readonly _componentItem: ComponentItem,\n        private readonly _originalParent: ContentItem) {\n\n        super();\n\n        this._dragListener.on('drag', (offsetX, offsetY, event) => this.onDrag(offsetX, offsetY, event));\n        this._dragListener.on('dragStop', () => this.onDrop());\n\n        this.createDragProxyElements(x, y);\n\n        if (this._componentItem.parent === null) {\n            // Note that _contentItem will have dummy GroundItem as parent if initiated by a external drag source\n            throw new UnexpectedNullError('DPC10097');\n        }\n\n        this._componentItemFocused = this._componentItem.focused;\n        if (this._componentItemFocused) {\n            this._componentItem.blur();\n        }\n        this._componentItem.parent.removeChild(this._componentItem, true);\n\n        this.setDimensions();\n\n        document.body.appendChild(this._element);\n\n        this.determineMinMaxXY();\n        this._layoutManager.calculateItemAreas();\n        this.setDropPosition(x, y);\n    }\n\n    /** Create Stack-like structure to contain the dragged component */\n    private createDragProxyElements(initialX: number, initialY: number): void {\n        this._element = document.createElement('div');\n        this._element.classList.add(DomConstants.ClassName.DragProxy);\n        const headerElement = document.createElement('div');\n        headerElement.classList.add(DomConstants.ClassName.Header);\n        const tabsElement = document.createElement('div');\n        tabsElement.classList.add(DomConstants.ClassName.Tabs);\n        const tabElement = document.createElement('div');\n        tabElement.classList.add(DomConstants.ClassName.Tab);\n        const titleElement = document.createElement('span');\n        titleElement.classList.add(DomConstants.ClassName.Title);\n        tabElement.appendChild(titleElement);\n        tabsElement.appendChild(tabElement);\n        headerElement.appendChild(tabsElement);\n\n        this._proxyContainerElement = document.createElement('div');\n        this._proxyContainerElement.classList.add(DomConstants.ClassName.Content);\n\n        this._element.appendChild(headerElement);\n        this._element.appendChild(this._proxyContainerElement);\n\n        if (this._originalParent instanceof Stack && this._originalParent.headerShow) {\n            this._sided = this._originalParent.headerLeftRightSided;\n            this._element.classList.add('lm_' + this._originalParent.headerSide);\n            if ([Side.right, Side.bottom].indexOf(this._originalParent.headerSide) >= 0) {\n                this._proxyContainerElement.insertAdjacentElement('afterend', headerElement);\n            }\n        }\n        this._element.style.left = numberToPixels(initialX);\n        this._element.style.top = numberToPixels(initialY);\n        tabElement.setAttribute('title', this._componentItem.title);\n        titleElement.insertAdjacentText('afterbegin', this._componentItem.title);\n        this._proxyContainerElement.appendChild(this._componentItem.element);\n    }\n\n    private determineMinMaxXY(): void {\n        const groundItem = this._layoutManager.groundItem;\n        if (groundItem === undefined) {\n            throw new UnexpectedUndefinedError('DPDMMXY73109');\n        } else {\n            const groundElement = groundItem.element;\n            const rect = groundElement.getBoundingClientRect();\n            this._minX = rect.left + document.body.scrollLeft;\n            this._minY = rect.top + document.body.scrollTop;\n            this._maxX = this._minX + rect.width;\n            this._maxY = this._minY + rect.height;\n        }\n    }\n\n    /**\n     * Callback on every mouseMove event during a drag. Determines if the drag is\n     * still within the valid drag area and calls the layoutManager to highlight the\n     * current drop area\n     *\n     * @param offsetX - The difference from the original x position in px\n     * @param offsetY - The difference from the original y position in px\n     * @param event -\n     * @internal\n     */\n    private onDrag(offsetX: number, offsetY: number, event: PointerEvent) {\n\n        const x = event.pageX;\n        const y = event.pageY;\n\n        this.setDropPosition(x, y);\n        this._componentItem.drag();\n    }\n\n    /**\n     * Sets the target position, highlighting the appropriate area\n     *\n     * @param x - The x position in px\n     * @param y - The y position in px\n     *\n     * @internal\n     */\n    private setDropPosition(x: number, y: number): void {\n        if (this._layoutManager.layoutConfig.settings.constrainDragToContainer) {\n            if (x <= this._minX) {\n                x = Math.ceil(this._minX);\n            } else if (x >= this._maxX) {\n                x = Math.floor(this._maxX);\n            }\n\n            if (y <= this._minY) {\n                y = Math.ceil(this._minY);\n            } else if (y >= this._maxY) {\n                y = Math.floor(this._maxY);\n            }\n        }\n\n        this._element.style.left = numberToPixels(x);\n        this._element.style.top = numberToPixels(y);\n        this._area = this._layoutManager.getArea(x, y);\n\n        if (this._area !== null) {\n            this._lastValidArea = this._area;\n            this._area.contentItem.highlightDropZone(x, y, this._area);\n        }\n    }\n\n    /**\n     * Callback when the drag has finished. Determines the drop area\n     * and adds the child to it\n     * @internal\n     */\n    private onDrop(): void {\n        const dropTargetIndicator = this._layoutManager.dropTargetIndicator;\n        if (dropTargetIndicator === null) {\n            throw new UnexpectedNullError('DPOD30011');\n        } else {\n            dropTargetIndicator.hide();\n        }\n\n        this._componentItem.exitDragMode();\n\n        /*\n         * Valid drop area found\n         */\n        let droppedComponentItem: ComponentItem | undefined;\n        if (this._area !== null) {\n            droppedComponentItem = this._componentItem;\n            this._area.contentItem.onDrop(droppedComponentItem, this._area);\n\n            /**\n             * No valid drop area available at present, but one has been found before.\n             * Use it\n             */\n        } else if (this._lastValidArea !== null) {\n            droppedComponentItem = this._componentItem;\n            const newParentContentItem = this._lastValidArea.contentItem;\n            newParentContentItem.onDrop(droppedComponentItem, this._lastValidArea);\n\n            /**\n             * No valid drop area found during the duration of the drag. Return\n             * content item to its original position if a original parent is provided.\n             * (Which is not the case if the drag had been initiated by createDragSource)\n             */\n        } else if (this._originalParent) {\n            droppedComponentItem = this._componentItem;\n            this._originalParent.addChild(droppedComponentItem);\n\n            /**\n             * The drag didn't ultimately end up with adding the content item to\n             * any container. In order to ensure clean up happens, destroy the\n             * content item.\n             */\n        } else {\n            this._componentItem.destroy(); // contentItem children are now destroyed as well\n        }\n\n        this._element.remove();\n\n        this._layoutManager.emit('itemDropped', this._componentItem);\n\n        if (this._componentItemFocused && droppedComponentItem !== undefined) {\n            droppedComponentItem.focus();\n        }\n    }\n\n    /**\n     * Updates the Drag Proxy's dimensions\n     * @internal\n     */\n    private setDimensions() {\n        const dimensions = this._layoutManager.layoutConfig.dimensions;\n        if (dimensions === undefined) {\n            throw new Error('DragProxy.setDimensions: dimensions undefined');\n        }\n\n        let width = dimensions.dragProxyWidth;\n        let height = dimensions.dragProxyHeight;\n        if (width === undefined || height === undefined) {\n            throw new Error('DragProxy.setDimensions: width and/or height undefined');\n        }\n\n        const headerHeight = this._layoutManager.layoutConfig.header.show === false ? 0 : dimensions.headerHeight;\n        this._element.style.width = numberToPixels(width);\n        this._element.style.height = numberToPixels(height)\n        width -= (this._sided ? headerHeight : 0);\n        height -= (!this._sided ? headerHeight : 0);\n        this._proxyContainerElement.style.width = numberToPixels(width);\n        this._proxyContainerElement.style.height = numberToPixels(height);\n        this._componentItem.enterDragMode(width, height);\n        this._componentItem.show();\n    }\n}\n", "import { ComponentItemConfig as ConfigComponentItemConfig } from '../config/config'; // remove alias in version 3\nimport { ResolvedRowOrColumnItemConfig } from \"../config/resolved-config\";\nimport { UnexpectedNullError } from '../errors/internal-error';\nimport { ComponentItem } from '../items/component-item';\nimport { GroundItem } from '../items/ground-item';\nimport { LayoutManager } from '../layout-manager';\nimport { DragListener } from '../utils/drag-listener';\nimport { JsonValue } from '../utils/types';\nimport { DragProxy } from './drag-proxy';\n\n/**\n * Allows for any DOM item to create a component on drag\n * start to be dragged into the Layout\n * @public\n */\nexport class DragSource {\n    /** @internal */\n    private _dragListener: DragListener | null;\n    /** @internal */\n    private _dummyGroundContainer: HTMLElement;\n    /** @internal */\n    private _dummyGroundContentItem: GroundItem;\n\n    /** @internal */\n    constructor(\n        /** @internal */\n        private _layoutManager: LayoutManager,\n        /** @internal */\n        private readonly _element: HTMLElement,\n        /** @internal */\n        private readonly _extraAllowableChildTargets: HTMLElement[],\n        /** @internal @deprecated replace with componentItemConfigOrFtn in version 3 */\n        private _componentTypeOrFtn: JsonValue | (() => (DragSource.ComponentItemConfig | ConfigComponentItemConfig)),\n        /** @internal @deprecated remove in version 3 */\n        private _componentState: JsonValue | undefined,\n        /** @internal @deprecated remove in version 3 */\n        private _title: string | undefined,\n        /** @internal @deprecated remove in version 3 */\n        private _id: string | undefined\n    ) {\n        this._dragListener = null;\n\n        this._dummyGroundContainer = document.createElement('div');\n\n        const dummyRootItemConfig = ResolvedRowOrColumnItemConfig.createDefault('row');\n        this._dummyGroundContentItem = new GroundItem(this._layoutManager, dummyRootItemConfig, this._dummyGroundContainer);\n\n        this.createDragListener();\n    }\n\n\t/**\n\t * Disposes of the drag listeners so the drag source is not usable any more.\n     * @internal\n\t */\n\tdestroy(): void {\n\t\tthis.removeDragListener();\n    }\n\n    /**\n     * Called initially and after every drag\n     * @internal\n     */\n    private createDragListener() {\n        this.removeDragListener();\n\n        this._dragListener = new DragListener(this._element, this._extraAllowableChildTargets);\n        this._dragListener.on('dragStart', (x, y) => this.onDragStart(x, y));\n        this._dragListener.on('dragStop', () => this.onDragStop());\n    }\n\n    /**\n     * Callback for the DragListener's dragStart event\n     *\n     * @param x - The x position of the mouse on dragStart\n     * @param y - The x position of the mouse on dragStart\n     * @internal\n     */\n    private onDragStart(x: number, y: number) {\n        const type = 'component';\n        let dragSourceItemConfig: ConfigComponentItemConfig;\n\n        if (typeof this._componentTypeOrFtn === \"function\") {\n            const ftnDragSourceItemConfig = this._componentTypeOrFtn() as (DragSource.ComponentItemConfig | ConfigComponentItemConfig);\n            // If the componentType property exists, then it is already a ComponentItemConfig so nothing to do\n            if (DragSource.isDragSourceComponentItemConfig(ftnDragSourceItemConfig)) {\n                dragSourceItemConfig = {\n                    type,\n                    componentState: ftnDragSourceItemConfig.state,\n                    componentType: ftnDragSourceItemConfig.type,\n                    title: ftnDragSourceItemConfig.title ?? this._title,\n                };\n            } else {\n                dragSourceItemConfig = ftnDragSourceItemConfig;\n            }\n        } else {\n            dragSourceItemConfig = {\n                type,\n                componentState: this._componentState,\n                componentType: this._componentTypeOrFtn,\n                title: this._title,\n                id: this._id,\n            };\n        }\n\n        // Create a dummy ContentItem only for drag purposes\n        // All ContentItems (except for GroundItem) need a parent.  When dragging, the parent is not used.\n        // Instead of allowing null parents (as Javascript version did), use a temporary dummy GroundItem parent and add ContentItem to that\n        // If this does not work, need to create alternative GroundItem class\n\n        const resolvedItemConfig = ConfigComponentItemConfig.resolve(dragSourceItemConfig, false);\n\n        const componentItem = new ComponentItem(this._layoutManager, resolvedItemConfig, this._dummyGroundContentItem)\n        this._dummyGroundContentItem.contentItems.push(componentItem);\n\n        if (this._dragListener === null) {\n            throw new UnexpectedNullError('DSODSD66746');\n        } else {\n            const dragProxy = new DragProxy(x, y, this._dragListener, this._layoutManager, componentItem , this._dummyGroundContentItem);\n\n            const transitionIndicator = this._layoutManager.transitionIndicator;\n            if (transitionIndicator === null) {\n                throw new UnexpectedNullError('DSODST66746');\n            } else {\n                transitionIndicator.transitionElements(this._element, dragProxy.element);\n            }\n        }\n    }\n\n    /** @internal */\n    private onDragStop() {\n        // if (this._dummyGroundContentItem === undefined) {\n        //     throw new UnexpectedUndefinedError('DSODSDRU08116');\n        // } else {\n        //     this._dummyGroundContentItem._$destroy\n        //     this._dummyGroundContentItem = undefined;\n        // }\n        this.createDragListener();\n    }\n\n    /**\n\t * Called after every drag and when the drag source is being disposed of.\n     * @internal\n\t */\n\tprivate removeDragListener() {\n\t\tif (this._dragListener !== null ) {\n            this._dragListener.destroy();\n            this._dragListener = null;\n\t\t}\n\t}\n}\n\n/** @public */\nexport namespace DragSource {\n    /** @deprecated  use Config {@link (ComponentItemConfig:interface)} */\n    export interface ComponentItemConfig {\n        type: JsonValue,\n        state?: JsonValue,\n        title?: string,\n    }\n\n    /** @deprecated remove in version 3 */\n    export function isDragSourceComponentItemConfig(\n        config: DragSource.ComponentItemConfig | ConfigComponentItemConfig\n    ): config is DragSource.ComponentItemConfig {\n        return !(\"componentType\" in config);\n    }\n}\n", "import { DomConstants } from '../utils/dom-constants';\nimport { AreaLinkedRect } from '../utils/types';\nimport { numberToPixels, setElementDisplayVisibility } from '../utils/utils';\n\n/** @internal */\nexport class DropTargetIndicator {\n    private _element: HTMLElement;\n\n    constructor() {\n        // Maybe use container instead of Document Body?\n        this._element = document.createElement('div');\n        this._element.classList.add(DomConstants.ClassName.DropTargetIndicator);\n        const innerElement = document.createElement('div');\n        innerElement.classList.add(DomConstants.ClassName.Inner);\n        this._element.appendChild(innerElement);\n\n        document.body.appendChild(this._element);\n    }\n\n    destroy(): void {\n        this._element.remove();\n    }\n\n    highlightArea(area: AreaLinkedRect, margin: number): void {\n        this._element.style.left = numberToPixels(area.x1 + margin);\n        this._element.style.top = numberToPixels(area.y1 + margin);\n        this._element.style.width = numberToPixels(area.x2 - area.x1 - margin);\n        this._element.style.height = numberToPixels(area.y2 - area.y1 - margin);\n        this._element.style.display = 'block';\n    }\n\n    hide(): void {\n        setElementDisplayVisibility(this._element, false);\n    }\n}\n", "import { DomConstants } from '../utils/dom-constants';\nimport { Rect } from '../utils/types';\n\n/** @internal @deprecated To be removed */\nexport class TransitionIndicator {\n    private _element: HTMLElement;\n    private _toElement: HTMLElement | null;\n    private _fromDimensions: null;\n    private _totalAnimationDuration: number;\n    private _animationStartTime: number | null;\n\n    constructor() {\n        this._element = document.createElement('div');\n        this._element.classList.add(DomConstants.ClassName.TransitionIndicator);\n        document.body.appendChild(this._element);\n\n        this._toElement = null;\n        this._fromDimensions = null;\n        this._totalAnimationDuration = 200;\n        this._animationStartTime = null;\n    }\n\n    destroy(): void {\n        this._element.remove();\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    transitionElements(fromElement: HTMLElement, toElement: HTMLElement): void {\n        /**\n         * TODO - This is not quite as cool as expected. Review.\n         */\n        return;\n        // this._toElement = toElement;\n        // this._animationStartTime = now();\n        // this._fromDimensions = this._measure(fromElement);\n        // this._fromDimensions.opacity = 0.8;\n        // this._element.show().css(this._fromDimensions);\n        // animFrame(fnBind(this._nextAnimationFrame, this));\n    }\n\n    private nextAnimationFrame(): void {\n        // if (this._toElement === null || this._fromDimensions === null || this._animationStartTime === null) {\n        //     throw new UnexpectedNullError('TINAFTD97115');\n        // } else {\n        //     const toDimensions = this.measure(this._toElement);\n        //     const animationProgress = (now() - this._animationStartTime) / this._totalAnimationDuration;\n        //     const currentFrameStyles = {};\n        //     const cssProperty;\n\n        //     if (animationProgress >= 1) {\n        //         this._element.style.display = 'none';\n        //         return;\n        //     }\n\n        //     toDimensions.opacity = 0;\n\n        //     for (const cssProperty in this._fromDimensions) {\n        //         currentFrameStyles[cssProperty] = this._fromDimensions[cssProperty] +\n        //             (toDimensions[cssProperty] - this._fromDimensions[cssProperty]) *\n        //             animationProgress;\n        //     }\n\n        //     this._element.css(currentFrameStyles);\n        //     animFrame(fnBind(this._nextAnimationFrame, this));\n        // }\n    }\n\n    private measure(element: HTMLElement): Rect {\n        const rect = element.getBoundingClientRect();\n\n        return {\n            left: rect.left,\n            top: rect.top,\n            width: element.offsetWidth,\n            height: element.offsetHeight,\n        };\n    }\n}\n", "import { UnexpectedNullError } from '../errors/internal-error';\nimport { LayoutManager } from '../layout-manager';\nimport { EventEmitter } from './event-emitter';\n\n// Add our ChildEvent to WindowEventMap for type safety\n/** @public */\ndeclare global {\n    interface WindowEventMap {\n        [EventHub.ChildEventName]: CustomEvent<EventHub.ChildEventDetail>;\n    }\n}\n\n/**\n * An EventEmitter singleton that propagates events\n * across multiple windows. This is a little bit trickier since\n * windows are allowed to open childWindows in their own right.\n *\n * This means that we deal with a tree of windows. Therefore, we do the event propagation in two phases:\n *\n * - Propagate events from this layout to the parent layout\n *   - Repeat until the event arrived at the root layout\n * - Propagate events to this layout and to all children\n *   - Repeat until all layouts got the event\n *\n * **WARNING**: Only userBroadcast events are propagated between windows.\n * This means the you have to take care of propagating state changes between windows yourself.\n *\n * @public\n */\nexport class EventHub extends EventEmitter {\n\n    /** @internal */\n    private _childEventListener = (childEvent: CustomEvent<EventHub.ChildEventDetail>) => this.onEventFromChild(childEvent);\n\n    /**\n     * Creates a new EventHub instance\n     * @param _layoutManager - the layout manager to synchronize between the windows\n     * @internal\n     */\n    constructor(\n        /** @internal */\n        private _layoutManager: LayoutManager\n    ) {\n        super();\n        globalThis.addEventListener(EventHub.ChildEventName, this._childEventListener, { passive: true });\n    }\n\n    /**\n     * Emit an event and notify listeners\n     *\n     * @param eventName - The name of the event\n     * @param args - Additional arguments that will be passed to the listener\n     * @public\n     */\n    override emit<K extends keyof EventEmitter.EventParamsMap>(eventName: K, ...args: EventEmitter.EventParamsMap[K]): void {\n        if (eventName === 'userBroadcast') {\n            // Explicitly redirect the user broadcast to our overridden method.\n            this.emitUserBroadcast(...args);\n        } else {\n            super.emit(eventName, ...args);\n        }\n    }\n\n    /**\n     * Broadcasts a message to all other currently opened windows.\n     * @public\n     */\n    emitUserBroadcast(...args: EventEmitter.UnknownParams): void {\n        // Step 1: Bubble up the event\n        this.handleUserBroadcastEvent('userBroadcast', args);\n    }\n\n    /**\n     * Destroys the EventHub\n     * @internal\n     */\n    destroy(): void {\n        globalThis.removeEventListener(EventHub.ChildEventName, this._childEventListener);\n    }\n\n    /**\n     * Internal processor to process local events.\n     * @internal\n     */\n    private handleUserBroadcastEvent(eventName: string, args: unknown[]) {\n        if (this._layoutManager.isSubWindow) {\n            // We are a sub window and received an event from one of our children.\n            // So propagate it to the Root.\n            this.propagateToParent(eventName, args);\n        } else {\n            // We are the root window, propagate it to the subtree below us.\n            this.propagateToThisAndSubtree(eventName, args);\n        }\n    }\n\n    /**\n     * Callback for child events raised on the window\n     * @internal\n     */\n    private onEventFromChild(event: CustomEvent<EventHub.ChildEventDetail>) {\n        const detail = event.detail;\n        this.handleUserBroadcastEvent(detail.eventName, detail.args);\n    }\n\n    /**\n     * Propagates the event to the parent by emitting\n     * it on the parent's DOM window\n     * @internal\n     */\n    private propagateToParent(eventName: string, args: unknown[]) {\n        const detail: EventHub.ChildEventDetail = {\n            layoutManager: this._layoutManager,\n            eventName,\n            args: args,\n        }\n\n        const eventInit: EventHub.ChildEventInit = {\n            bubbles: true,\n            cancelable: true,\n            detail,\n        };\n\n        const event = new CustomEvent<EventHub.ChildEventDetail>(EventHub.ChildEventName, eventInit);\n        const opener = globalThis.opener;\n        if (opener === null) {\n            throw new UnexpectedNullError('EHPTP15778')\n        }\n\n        opener.dispatchEvent(event);\n    }\n\n    /**\n     * Propagate events to the whole subtree under this event hub.\n     * @internal\n     */\n    private propagateToThisAndSubtree(eventName: string, args: unknown[]) {\n        this.emitUnknown(eventName, ...args);\n        for (let i = 0; i < this._layoutManager.openPopouts.length; i++) {\n            const childGl = this._layoutManager.openPopouts[i].getGlInstance();\n\n            if (childGl) {\n                childGl.eventHub.propagateToThisAndSubtree(eventName, args);\n            }\n        }\n    }\n}\n\n/** @public */\nexport namespace EventHub {\n\n    /** @internal */\n    export const ChildEventName = 'gl_child_event';\n\n    /** @internal */\n    export type ChildEventDetail = {\n        layoutManager: LayoutManager;\n        eventName: string;\n        args: unknown[];\n    };\n\n    /** @internal */\n    export type ChildEventInit = CustomEventInit<ChildEventDetail>;\n}\n", "import { ComponentItemConfig, ItemConfig, LayoutConfig, RowOrColumnItemConfig, StackItemConfig } from './config/config';\nimport {\n    ResolvedComponentItemConfig,\n    ResolvedItemConfig,\n    ResolvedLayoutConfig,\n    ResolvedPopoutLayoutConfig,\n    ResolvedRootItemConfig,\n    ResolvedRowOrColumnItemConfig,\n    ResolvedStackItemConfig\n} from \"./config/resolved-config\";\nimport { ComponentContainer } from './container/component-container';\nimport { BrowserPopout } from './controls/browser-popout';\nimport { DragProxy } from './controls/drag-proxy';\nimport { DragSource } from './controls/drag-source';\nimport { DropTargetIndicator } from './controls/drop-target-indicator';\nimport { TransitionIndicator } from './controls/transition-indicator';\nimport { ConfigurationError } from './errors/external-error';\nimport { AssertError, UnexpectedNullError, UnexpectedUndefinedError, UnreachableCaseError } from './errors/internal-error';\nimport { ComponentItem } from './items/component-item';\nimport { ComponentParentableItem } from './items/component-parentable-item';\nimport { ContentItem } from './items/content-item';\nimport { GroundItem } from './items/ground-item';\nimport { RowOrColumn } from './items/row-or-column';\nimport { Stack } from './items/stack';\nimport { ConfigMinifier } from './utils/config-minifier';\nimport { DomConstants } from './utils/dom-constants';\nimport { DragListener } from './utils/drag-listener';\nimport { EventEmitter } from './utils/event-emitter';\nimport { EventHub } from './utils/event-hub';\nimport { I18nStringId, I18nStrings, i18nStrings } from './utils/i18n-strings';\nimport { ItemType, JsonValue, Rect, ResponsiveMode } from './utils/types';\nimport {\n    getElementWidthAndHeight,\n    removeFromArray,\n    setElementHeight,\n    setElementWidth\n} from './utils/utils';\n\n/** @internal */\ndeclare global {\n    interface Window {\n        __glInstance: LayoutManager;\n    }\n}\n\n/**\n * The main class that will be exposed as GoldenLayout.\n */\n\n/** @public */\nexport abstract class LayoutManager extends EventEmitter {\n    /** Whether the layout will be automatically be resized to container whenever the container's size is changed\n     * Default is true if <body> is the container otherwise false\n     * Default will be changed to true for any container in the future\n     */\n    resizeWithContainerAutomatically = false;\n    /** The debounce interval (in milliseconds) used whenever a layout is automatically resized.  0 means next tick */\n    resizeDebounceInterval = 100;\n    /** Extend the current debounce delay time period if it is triggered during the delay.\n     * If this is true, the layout will only resize when its container has stopped being resized.\n     * If it is false, the layout will resize at intervals while its container is being resized.\n     */\n    resizeDebounceExtendedWhenPossible = true;\n\n    /** @internal */\n    private _containerElement: HTMLElement;\n    /** @internal */\n    private _isInitialised = false;\n    /** @internal */\n    private _groundItem: GroundItem | undefined = undefined;\n    /** @internal */\n    private _openPopouts: BrowserPopout[] = [];\n    /** @internal */\n    private _dropTargetIndicator: DropTargetIndicator | null = null;\n    /** @internal */\n    private _transitionIndicator: TransitionIndicator | null = null;\n    /** @internal */\n    private _resizeTimeoutId: ReturnType<typeof setTimeout> | undefined;\n    /** @internal */\n    private _itemAreas: ContentItem.Area[] = [];\n    /** @internal */\n    private _maximisedStack: Stack | undefined;\n    /** @internal */\n    private _maximisePlaceholder = LayoutManager.createMaximisePlaceElement(document);\n    /** @internal */\n    private _tabDropPlaceholder = LayoutManager.createTabDropPlaceholderElement(document);\n    /** @internal */\n    private _dragSources: DragSource[] = [];\n    /** @internal */\n    private _updatingColumnsResponsive = false;\n    /** @internal */\n    private _firstLoad = true;\n    /** @internal */\n    private _eventHub = new EventHub(this);\n    /** @internal */\n    private _width: number | null = null;\n    /** @internal */\n    private _height: number | null = null;\n    /** @internal */\n    private _focusedComponentItem: ComponentItem | undefined;\n    /** @internal */\n    private _virtualSizedContainers: ComponentContainer[] = [];\n    /** @internal */\n    private _virtualSizedContainerAddingBeginCount = 0;\n    /** @internal */\n    private _sizeInvalidationBeginCount = 0;\n    /** @internal */\n    protected _constructorOrSubWindowLayoutConfig: LayoutConfig | undefined; // protected for backwards compatibility\n\n    /** @internal */\n    private _resizeObserver = new ResizeObserver(() => this.handleContainerResize());\n    /** @internal @deprecated to be removed in version 3 */\n    private _windowBeforeUnloadListener = () => this.onBeforeUnload();\n    /** @internal @deprecated to be removed in version 3 */\n    private _windowBeforeUnloadListening = false;\n    /** @internal */\n    private _maximisedStackBeforeDestroyedListener = (ev: EventEmitter.BubblingEvent) => this.cleanupBeforeMaximisedStackDestroyed(ev);\n\n    readonly isSubWindow: boolean;\n    layoutConfig: ResolvedLayoutConfig;\n\n    beforeVirtualRectingEvent: LayoutManager.BeforeVirtualRectingEvent | undefined;\n    afterVirtualRectingEvent: LayoutManager.AfterVirtualRectingEvent | undefined;\n\n    get container(): HTMLElement { return this._containerElement; }\n    get isInitialised(): boolean { return this._isInitialised; }\n    /** @internal */\n    get groundItem(): GroundItem | undefined { return this._groundItem; }\n    /** @internal @deprecated use {@link (LayoutManager:class).groundItem} instead */\n    get root(): GroundItem | undefined { return this._groundItem; }\n    get openPopouts(): BrowserPopout[] { return this._openPopouts; }\n    /** @internal */\n    get dropTargetIndicator(): DropTargetIndicator | null { return this._dropTargetIndicator; }\n    /** @internal @deprecated To be removed */\n    get transitionIndicator(): TransitionIndicator | null { return this._transitionIndicator; }\n    get width(): number | null { return this._width; }\n    get height(): number | null { return this._height; }\n    /**\n     * Retrieves the {@link (EventHub:class)} instance associated with this layout manager.\n     * This can be used to propagate events between the windows\n     * @public\n     */\n    get eventHub(): EventHub { return this._eventHub; }\n    get rootItem(): ContentItem | undefined {\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot access rootItem before init');\n        } else {\n            const groundContentItems = this._groundItem.contentItems;\n            if (groundContentItems.length === 0) {\n                return undefined;\n            } else {\n                return this._groundItem.contentItems[0];\n            }\n        }\n    }\n    get focusedComponentItem(): ComponentItem | undefined { return this._focusedComponentItem; }\n    /** @internal */\n    get tabDropPlaceholder(): HTMLElement { return this._tabDropPlaceholder; }\n    get maximisedStack(): Stack | undefined { return this._maximisedStack; }\n\n    /** @deprecated indicates deprecated constructor use */\n    get deprecatedConstructor(): boolean { return !this.isSubWindow && this._constructorOrSubWindowLayoutConfig !== undefined; }\n\n\n    /**\n    * @param container - A Dom HTML element. Defaults to body\n    * @internal\n    */\n    constructor(parameters: LayoutManager.ConstructorParameters) {\n        super();\n\n        this.isSubWindow = parameters.isSubWindow;\n\n        this._constructorOrSubWindowLayoutConfig = parameters.constructorOrSubWindowLayoutConfig;\n\n        I18nStrings.checkInitialise();\n        ConfigMinifier.checkInitialise();\n\n        if (parameters.containerElement !== undefined) {\n            this._containerElement = parameters.containerElement;\n        }\n    }\n\n    /**\n     * Destroys the LayoutManager instance itself as well as every ContentItem\n     * within it. After this is called nothing should be left of the LayoutManager.\n     *\n     * This function only needs to be called if an application wishes to destroy the Golden Layout object while\n     * a page remains loaded. When a page is unloaded, all resources claimed by Golden Layout will automatically\n     * be released.\n     */\n    destroy(): void {\n        if (this._isInitialised) {\n            if (this._windowBeforeUnloadListening) {\n                globalThis.removeEventListener('beforeunload', this._windowBeforeUnloadListener);\n                this._windowBeforeUnloadListening = false;\n            }\n\n            if (this.layoutConfig.settings.closePopoutsOnUnload === true) {\n                this.closeAllOpenPopouts();\n            }\n\n            this._resizeObserver.disconnect();\n            this.checkClearResizeTimeout();\n\n            if (this._groundItem !== undefined) {\n                this._groundItem.destroy();\n            }\n            this._tabDropPlaceholder.remove();\n            if (this._dropTargetIndicator !== null) {\n                this._dropTargetIndicator.destroy();\n            }\n            if (this._transitionIndicator !== null) {\n                this._transitionIndicator.destroy();\n            }\n            this._eventHub.destroy();\n\n            for (const dragSource of this._dragSources) {\n                dragSource.destroy();\n            }\n            this._dragSources = [];\n\n            this._isInitialised = false;\n        }\n    }\n\n    /**\n     * Takes a GoldenLayout configuration object and\n     * replaces its keys and values recursively with\n     * one letter codes\n     * @deprecated use {@link (ResolvedLayoutConfig:namespace).minifyConfig} instead\n     */\n    minifyConfig(config: ResolvedLayoutConfig): ResolvedLayoutConfig {\n        return ResolvedLayoutConfig.minifyConfig(config);\n    }\n\n    /**\n     * Takes a configuration Object that was previously minified\n     * using minifyConfig and returns its original version\n     * @deprecated use {@link (ResolvedLayoutConfig:namespace).unminifyConfig} instead\n     */\n    unminifyConfig(config: ResolvedLayoutConfig): ResolvedLayoutConfig {\n        return ResolvedLayoutConfig.unminifyConfig(config);\n    }\n\n    /** @internal */\n    abstract bindComponent(container: ComponentContainer, itemConfig: ResolvedComponentItemConfig): ComponentContainer.BindableComponent;\n    /** @internal */\n    abstract unbindComponent(container: ComponentContainer, virtual: boolean, component: ComponentContainer.Component | undefined): void;\n\n    /**\n     * Called from GoldenLayout class. Finishes of init\n     * @internal\n     */\n    init(): void {\n        this.setContainer();\n        this._dropTargetIndicator = new DropTargetIndicator(/*this.container*/);\n        this._transitionIndicator = new TransitionIndicator();\n        this.updateSizeFromContainer();\n\n        let subWindowRootConfig: ComponentItemConfig | undefined;\n        if (this.isSubWindow) {\n            if (this._constructorOrSubWindowLayoutConfig === undefined) {\n                // SubWindow LayoutConfig should have been generated by constructor\n                throw new UnexpectedUndefinedError('LMIU07155');\n            } else {\n                const root = this._constructorOrSubWindowLayoutConfig.root;\n                if (root === undefined) {\n                    // SubWindow LayoutConfig must not be empty\n                    throw new AssertError('LMIC07156');\n                } else {\n                    if (ItemConfig.isComponent(root)) {\n                        subWindowRootConfig = root;\n                    } else {\n                        // SubWindow LayoutConfig must have Component as Root\n                        throw new AssertError('LMIC07157');\n                    }\n                }\n                const resolvedLayoutConfig = LayoutConfig.resolve(this._constructorOrSubWindowLayoutConfig);\n                // remove root from layoutConfig\n                this.layoutConfig = {\n                    ...resolvedLayoutConfig,\n                    root: undefined,\n                }\n            }\n        } else {\n            if (this._constructorOrSubWindowLayoutConfig === undefined) {\n                this.layoutConfig = ResolvedLayoutConfig.createDefault(); // will overwritten be loaded via loadLayout\n            } else {\n                // backwards compatibility\n                this.layoutConfig = LayoutConfig.resolve(this._constructorOrSubWindowLayoutConfig);\n            }\n        }\n        const layoutConfig = this.layoutConfig;\n        this._groundItem = new GroundItem(this, layoutConfig.root, this._containerElement);\n        this._groundItem.init();\n\n        this.checkLoadedLayoutMaximiseItem();\n\n        this._resizeObserver.observe(this._containerElement);\n        this._isInitialised = true;\n        this.adjustColumnsResponsive();\n        this.emit('initialised');\n\n        if (subWindowRootConfig !== undefined) {\n            // must be SubWindow\n            this.loadComponentAsRoot(subWindowRootConfig);\n        }\n    }\n\n    /**\n     * Loads a new layout\n     * @param layoutConfig - New layout to be loaded\n     */\n    loadLayout(layoutConfig: LayoutConfig): void {\n        if (!this.isInitialised) {\n            // In case application not correctly using legacy constructor\n            throw new Error('GoldenLayout: Need to call init() if LayoutConfig with defined root passed to constructor')\n        } else {\n            if (this._groundItem === undefined) {\n                throw new UnexpectedUndefinedError('LMLL11119');\n            } else {\n                this.createSubWindows(); // still needs to be tested\n\n                this.layoutConfig = LayoutConfig.resolve(layoutConfig);\n                this._groundItem.loadRoot(this.layoutConfig.root);\n                this.checkLoadedLayoutMaximiseItem();\n                this.adjustColumnsResponsive();\n            }\n        }\n    }\n\n    /**\n     * Creates a layout configuration object based on the the current state\n     *\n     * @public\n     * @returns GoldenLayout configuration\n     */\n    saveLayout(): ResolvedLayoutConfig {\n        if (this._isInitialised === false) {\n            throw new Error('Can\\'t create config, layout not yet initialised');\n        } else {\n\n            // if (root !== undefined && !(root instanceof ContentItem)) {\n            //     throw new Error('Root must be a ContentItem');\n            // }\n\n            /*\n            * Content\n            */\n            if (this._groundItem === undefined) {\n                throw new UnexpectedUndefinedError('LMTC18244');\n            } else {\n                const groundContent = this._groundItem.calculateConfigContent();\n\n                let rootItemConfig: ResolvedRootItemConfig | undefined;\n                if (groundContent.length !== 1) {\n                    rootItemConfig = undefined;\n                } else {\n                    rootItemConfig = groundContent[0];\n                }\n\n                /*\n                * Retrieve config for subwindows\n                */\n                this.reconcilePopoutWindows();\n                const openPopouts: ResolvedPopoutLayoutConfig[] = [];\n                for (let i = 0; i < this._openPopouts.length; i++) {\n                    openPopouts.push(this._openPopouts[i].toConfig());\n                }\n\n                const config: ResolvedLayoutConfig = {\n                    root: rootItemConfig,\n                    openPopouts,\n                    settings:  ResolvedLayoutConfig.Settings.createCopy(this.layoutConfig.settings),\n                    dimensions: ResolvedLayoutConfig.Dimensions.createCopy(this.layoutConfig.dimensions),\n                    header: ResolvedLayoutConfig.Header.createCopy(this.layoutConfig.header),\n                    resolved: true,\n                }\n\n                return config;\n            }\n        }\n    }\n\n    /**\n     * Removes any existing layout. Effectively, an empty layout will be loaded.\n     */\n\n    clear(): void {\n        if (this._groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMCL11129');\n        } else {\n            this._groundItem.clearRoot();\n        }\n    }\n\n    /**\n     * @deprecated Use {@link (LayoutManager:class).saveLayout}\n     */\n    toConfig(): ResolvedLayoutConfig {\n        return this.saveLayout();\n    }\n\n    /**\n     * Adds a new ComponentItem.  Will use default location selectors to ensure a location is found and\n     * component is successfully added\n     * @param componentTypeName - Name of component type to be created.\n     * @param state - Optional initial state to be assigned to component\n     * @returns New ComponentItem created.\n     */\n    newComponent(componentType: JsonValue, componentState?: JsonValue, title?: string): ComponentItem {\n        const componentItem = this.newComponentAtLocation(componentType, componentState, title);\n        if (componentItem === undefined) {\n            throw new AssertError('LMNC65588');\n        } else {\n            return componentItem;\n        }\n    }\n\n    /**\n     * Adds a ComponentItem at the first valid selector location.\n     * @param componentTypeName - Name of component type to be created.\n     * @param state - Optional initial state to be assigned to component\n     * @param locationSelectors - Array of location selectors used to find location in layout where component\n     * will be added. First location in array which is valid will be used. If locationSelectors is undefined,\n     * {@link (LayoutManager:namespace).defaultLocationSelectors} will be used\n     * @returns New ComponentItem created or undefined if no valid location selector was in array.\n     */\n    newComponentAtLocation(componentType: JsonValue, componentState?: JsonValue, title?: string,\n        locationSelectors?: LayoutManager.LocationSelector[]\n    ): ComponentItem | undefined{\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot add component before init');\n        } else {\n            const location = this.addComponentAtLocation(componentType, componentState, title, locationSelectors);\n            if (location === undefined) {\n                return undefined;\n            } else {\n                const createdItem = location.parentItem.contentItems[location.index];\n                if (!ContentItem.isComponentItem(createdItem)) {\n                    throw new AssertError('LMNC992877533');\n                } else {\n                    return createdItem;\n                }\n            }\n        }\n    }\n\n    /**\n     * Adds a new ComponentItem.  Will use default location selectors to ensure a location is found and\n     * component is successfully added\n     * @param componentType - Type of component to be created.\n     * @param state - Optional initial state to be assigned to component\n     * @returns Location of new ComponentItem created.\n     */\n    addComponent(componentType: JsonValue, componentState?: JsonValue, title?: string): LayoutManager.Location {\n        const location = this.addComponentAtLocation(componentType, componentState, title);\n        if (location === undefined) {\n            throw new AssertError('LMAC99943');\n        } else {\n            return location;\n        }\n    }\n\n    /**\n     * Adds a ComponentItem at the first valid selector location.\n     * @param componentType - Type of component to be created.\n     * @param state - Optional initial state to be assigned to component\n     * @param locationSelectors - Array of location selectors used to find determine location in layout where component\n     * will be added. First location in array which is valid will be used. If undefined,\n     * {@link (LayoutManager:namespace).defaultLocationSelectors} will be used.\n     * @returns Location of new ComponentItem created or undefined if no valid location selector was in array.\n     */\n    addComponentAtLocation(componentType: JsonValue, componentState?: JsonValue, title?: string,\n        locationSelectors?: readonly LayoutManager.LocationSelector[]\n    ): LayoutManager.Location | undefined {\n        const itemConfig: ComponentItemConfig = {\n            type: 'component',\n            componentType,\n            componentState,\n            title,\n        };\n\n        return this.addItemAtLocation(itemConfig, locationSelectors);\n    }\n\n    /**\n     * Adds a new ContentItem.  Will use default location selectors to ensure a location is found and\n     * component is successfully added\n     * @param itemConfig - ResolvedItemConfig of child to be added.\n     * @returns New ContentItem created.\n    */\n    newItem(itemConfig: RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig): ContentItem {\n        const contentItem = this.newItemAtLocation(itemConfig);\n        if (contentItem === undefined) {\n            throw new AssertError('LMNC65588');\n        } else {\n            return contentItem;\n        }\n    }\n\n    /**\n     * Adds a new child ContentItem under the root ContentItem.  If a root does not exist, then create root ContentItem instead\n     * @param itemConfig - ResolvedItemConfig of child to be added.\n     * @param locationSelectors - Array of location selectors used to find determine location in layout where ContentItem\n     * will be added. First location in array which is valid will be used. If undefined,\n     * {@link (LayoutManager:namespace).defaultLocationSelectors} will be used.\n     * @returns New ContentItem created or undefined if no valid location selector was in array. */\n    newItemAtLocation(itemConfig: RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig,\n        locationSelectors?: readonly LayoutManager.LocationSelector[]\n    ): ContentItem | undefined {\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot add component before init');\n        } else {\n            const location = this.addItemAtLocation(itemConfig, locationSelectors);\n            if (location === undefined) {\n                return undefined;\n            } else {\n                const createdItem = location.parentItem.contentItems[location.index];\n                return createdItem;\n            }\n        }\n    }\n\n    /**\n     * Adds a new ContentItem.  Will use default location selectors to ensure a location is found and\n     * component is successfully added.\n     * @param itemConfig - ResolvedItemConfig of child to be added.\n     * @returns Location of new ContentItem created. */\n    addItem(itemConfig: RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig): LayoutManager.Location {\n        const location = this.addItemAtLocation(itemConfig);\n        if (location === undefined) {\n            throw new AssertError('LMAI99943');\n        } else {\n            return location;\n        }\n    }\n\n    /**\n     * Adds a ContentItem at the first valid selector location.\n     * @param itemConfig - ResolvedItemConfig of child to be added.\n     * @param locationSelectors - Array of location selectors used to find determine location in layout where ContentItem\n     * will be added. First location in array which is valid will be used. If undefined,\n     * {@link (LayoutManager:namespace).defaultLocationSelectors} will be used.\n     * @returns Location of new ContentItem created or undefined if no valid location selector was in array. */\n    addItemAtLocation(itemConfig: RowOrColumnItemConfig | StackItemConfig | ComponentItemConfig,\n        locationSelectors?: readonly LayoutManager.LocationSelector[]\n    ): LayoutManager.Location | undefined {\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot add component before init');\n        } else {\n            if (locationSelectors === undefined) {\n                // defaultLocationSelectors should always find a location\n                locationSelectors = LayoutManager.defaultLocationSelectors;\n            }\n\n            const location = this.findFirstLocation(locationSelectors);\n            if (location === undefined) {\n                return undefined;\n            } else {\n                let parentItem = location.parentItem;\n                let addIdx: number;\n                switch (parentItem.type) {\n                    case ItemType.ground: {\n                        const groundItem = parentItem as GroundItem;\n                        addIdx = groundItem.addItem(itemConfig, location.index);\n                        if (addIdx >= 0) {\n                            parentItem = this._groundItem.contentItems[0]; // was added to rootItem\n                        } else {\n                            addIdx = 0; // was added as rootItem (which is the first and only ContentItem in GroundItem)\n                        }\n                        break;\n                    }\n                    case ItemType.row:\n                    case ItemType.column: {\n                        const rowOrColumn = parentItem as RowOrColumn;\n                        addIdx = rowOrColumn.addItem(itemConfig, location.index);\n                        break;\n                    }\n                    case ItemType.stack: {\n                        if (!ItemConfig.isComponent(itemConfig)) {\n                            throw Error(i18nStrings[I18nStringId.ItemConfigIsNotTypeComponent]);\n                        } else {\n                            const stack = parentItem as Stack;\n                            addIdx = stack.addItem(itemConfig, location.index);\n                            break;\n                        }\n                    }\n                    case ItemType.component: {\n                        throw new AssertError('LMAIALC87444602');\n                    }\n                    default:\n                        throw new UnreachableCaseError('LMAIALU98881733', parentItem.type);\n                }\n\n                if (ItemConfig.isComponent(itemConfig)) {\n                    // see if stack was inserted\n                    const item = parentItem.contentItems[addIdx];\n                    if (ContentItem.isStack(item)) {\n                        parentItem = item;\n                        addIdx = 0;\n                    }\n                }\n\n                location.parentItem = parentItem;\n                location.index = addIdx;\n\n                return location;\n            }\n        }\n    }\n\n    /** Loads the specified component ResolvedItemConfig as root.\n     * This can be used to display a Component all by itself.  The layout cannot be changed other than having another new layout loaded.\n     * Note that, if this layout is saved and reloaded, it will reload with the Component as a child of a Stack.\n    */\n    loadComponentAsRoot(itemConfig: ComponentItemConfig): void {\n        if (this._groundItem === undefined) {\n            throw new Error('Cannot add item before init');\n        } else {\n            this._groundItem.loadComponentAsRoot(itemConfig);\n        }\n    }\n\n    /** @deprecated Use {@link (LayoutManager:class).setSize} */\n    updateSize(width: number, height: number): void {\n        this.setSize(width, height);\n    }\n\n    /**\n     * Updates the layout managers size\n     *\n     * @param width - Width in pixels\n     * @param height - Height in pixels\n     */\n    setSize(width: number, height: number): void {\n        this._width = width;\n        this._height = height;\n\n        if (this._isInitialised === true) {\n            if (this._groundItem === undefined) {\n                throw new UnexpectedUndefinedError('LMUS18881');\n            } else {\n                this._groundItem.setSize(this._width, this._height);\n\n                if (this._maximisedStack) {\n                    const { width, height } = getElementWidthAndHeight(this._containerElement);\n                    setElementWidth(this._maximisedStack.element, width);\n                    setElementHeight(this._maximisedStack.element, height);\n                    this._maximisedStack.updateSize(false);\n                }\n\n                this.adjustColumnsResponsive();\n            }\n        }\n    }\n\n    /** @internal */\n    beginSizeInvalidation(): void {\n        this._sizeInvalidationBeginCount++;\n    }\n\n    /** @internal */\n    endSizeInvalidation(): void {\n        if (--this._sizeInvalidationBeginCount === 0) {\n            this.updateSizeFromContainer();\n        }\n    }\n\n    /** @internal */\n    updateSizeFromContainer(): void {\n        const { width, height } = getElementWidthAndHeight(this._containerElement);\n        this.setSize(width, height);\n    }\n\n    /**\n     * Update the size of the root ContentItem.  This will update the size of all contentItems in the tree\n     * @param force - In some cases the size is not updated if it has not changed. In this case, events\n     * (such as ComponentContainer.virtualRectingRequiredEvent) are not fired. Setting force to true, ensures the size is updated regardless, and\n     * the respective events are fired. This is sometimes necessary when a component's size has not changed but it has become visible, and the\n     * relevant events need to be fired.\n     */\n    updateRootSize(force = false): void {\n        if (this._groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMURS28881');\n        } else {\n            this._groundItem.updateSize(force);\n        }\n    }\n\n    /** @public */\n    createAndInitContentItem(config: ResolvedItemConfig, parent: ContentItem): ContentItem {\n        const newItem = this.createContentItem(config, parent);\n        newItem.init();\n        return newItem;\n    }\n\n    /**\n     * Recursively creates new item tree structures based on a provided\n     * ItemConfiguration object\n     *\n     * @param config - ResolvedItemConfig\n     * @param parent - The item the newly created item should be a child of\n     * @internal\n     */\n    createContentItem(config: ResolvedItemConfig, parent: ContentItem): ContentItem {\n        if (typeof config.type !== 'string') {\n            throw new ConfigurationError('Missing parameter \\'type\\'', JSON.stringify(config));\n        }\n\n        /**\n         * We add an additional stack around every component that's not within a stack anyways.\n         */\n        if (\n            // If this is a component\n            ResolvedItemConfig.isComponentItem(config) &&\n\n            // and it's not already within a stack\n            !(parent instanceof Stack) &&\n\n            // and we have a parent\n            !!parent &&\n\n            // and it's not the topmost item in a new window\n            !(this.isSubWindow === true && parent instanceof GroundItem)\n        ) {\n            const stackConfig: ResolvedStackItemConfig = {\n                type: ItemType.stack,\n                content: [config],\n                size: config.size,\n                sizeUnit: config.sizeUnit,\n                minSize: config.minSize,\n                minSizeUnit: config.minSizeUnit,\n                id: config.id,\n                maximised: config.maximised,\n                isClosable: config.isClosable,\n                activeItemIndex: 0,\n                header: undefined,\n            };\n\n            config = stackConfig;\n        }\n\n        const contentItem = this.createContentItemFromConfig(config, parent);\n        return contentItem;\n    }\n\n    findFirstComponentItemById(id: string): ComponentItem | undefined {\n        if (this._groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMFFCIBI82446');\n        } else {\n            return this.findFirstContentItemTypeByIdRecursive(ItemType.component, id, this._groundItem) as ComponentItem;\n        }\n    }\n\n    /**\n     * Creates a popout window with the specified content at the specified position\n     *\n     * @param itemConfigOrContentItem - The content of the popout window's layout manager derived from either\n     * a {@link (ContentItem:class)} or {@link (ItemConfig:interface)} or ResolvedItemConfig content (array of {@link (ItemConfig:interface)})\n     * @param positionAndSize - The width, height, left and top of Popout window\n     * @param parentId -The id of the element this item will be appended to when popIn is called\n     * @param indexInParent - The position of this item within its parent element\n     */\n\n    createPopout(itemConfigOrContentItem: ContentItem | ResolvedRootItemConfig,\n        positionAndSize: ResolvedPopoutLayoutConfig.Window,\n        parentId: string | null,\n        indexInParent: number | null\n    ): BrowserPopout {\n        if (itemConfigOrContentItem instanceof ContentItem) {\n            return this.createPopoutFromContentItem(itemConfigOrContentItem, positionAndSize, parentId, indexInParent);\n        } else {\n            return this.createPopoutFromItemConfig(itemConfigOrContentItem, positionAndSize, parentId, indexInParent);\n        }\n    }\n\n    /** @internal */\n    createPopoutFromContentItem(item: ContentItem,\n        window: ResolvedPopoutLayoutConfig.Window | undefined,\n        parentId: string | null,\n        indexInParent: number | null | undefined,\n    ): BrowserPopout {\n        /**\n         * If the item is the only component within a stack or for some\n         * other reason the only child of its parent the parent will be destroyed\n         * when the child is removed.\n         *\n         * In order to support this we move up the tree until we find something\n         * that will remain after the item is being popped out\n         */\n        let parent = item.parent;\n        let child = item;\n        while (parent !== null && parent.contentItems.length === 1 && !parent.isGround) {\n            child = parent;\n            parent = parent.parent;\n        }\n\n        if (parent === null) {\n            throw new UnexpectedNullError('LMCPFCI00834');\n        } else {\n            if (indexInParent === undefined) {\n                indexInParent = parent.contentItems.indexOf(child);\n            }\n\n            if (parentId !== null) {\n                parent.addPopInParentId(parentId);\n            }\n\n            if (window === undefined) {\n                const windowLeft = globalThis.screenX || globalThis.screenLeft;\n                const windowTop = globalThis.screenY || globalThis.screenTop;\n                const offsetLeft = item.element.offsetLeft;\n                const offsetTop = item.element.offsetTop\n                // const { left: offsetLeft, top: offsetTop } = getJQueryLeftAndTop(item.element);\n                const { width, height } = getElementWidthAndHeight(item.element);\n\n                window = {\n                    left: windowLeft + offsetLeft,\n                    top: windowTop + offsetTop,\n                    width,\n                    height,\n                };\n            }\n\n            const itemConfig = item.toConfig();\n            item.remove();\n\n            if (!ResolvedRootItemConfig.isRootItemConfig(itemConfig)) {\n                throw new Error(`${i18nStrings[I18nStringId.PopoutCannotBeCreatedWithGroundItemConfig]}`);\n            } else {\n                return this.createPopoutFromItemConfig(itemConfig, window, parentId, indexInParent);\n            }\n        }\n    }\n\n    /** @internal */\n    beginVirtualSizedContainerAdding(): void {\n        if (++this._virtualSizedContainerAddingBeginCount === 0) {\n            this._virtualSizedContainers.length = 0;\n        }\n    }\n\n    /** @internal */\n    addVirtualSizedContainer(container: ComponentContainer): void {\n        this._virtualSizedContainers.push(container);\n    }\n\n    /** @internal */\n    endVirtualSizedContainerAdding(): void {\n        if (--this._virtualSizedContainerAddingBeginCount === 0) {\n            const count = this._virtualSizedContainers.length;\n            if (count > 0) {\n                this.fireBeforeVirtualRectingEvent(count);\n                for (let i = 0; i < count; i++) {\n                    const container = this._virtualSizedContainers[i];\n                    container.notifyVirtualRectingRequired();\n                }\n                this.fireAfterVirtualRectingEvent();\n                this._virtualSizedContainers.length = 0;\n            }\n        }\n    }\n\n    /** @internal */\n    fireBeforeVirtualRectingEvent(count: number): void {\n        if (this.beforeVirtualRectingEvent !== undefined) {\n            this.beforeVirtualRectingEvent(count);\n        }\n    }\n\n    /** @internal */\n    fireAfterVirtualRectingEvent(): void {\n        if (this.afterVirtualRectingEvent !== undefined) {\n            this.afterVirtualRectingEvent();\n        }\n    }\n\n    /** @internal */\n    private createPopoutFromItemConfig(rootItemConfig: ResolvedRootItemConfig,\n        window: ResolvedPopoutLayoutConfig.Window,\n        parentId: string | null,\n        indexInParent: number | null\n    ) {\n        const layoutConfig = this.toConfig();\n\n        const popoutLayoutConfig: ResolvedPopoutLayoutConfig = {\n            root: rootItemConfig,\n            openPopouts: [],\n            settings: layoutConfig.settings,\n            dimensions: layoutConfig.dimensions,\n            header: layoutConfig.header,\n            window,\n            parentId,\n            indexInParent,\n            resolved: true,\n        }\n\n        return this.createPopoutFromPopoutLayoutConfig(popoutLayoutConfig);\n    }\n\n    /** @internal */\n    createPopoutFromPopoutLayoutConfig(config: ResolvedPopoutLayoutConfig): BrowserPopout {\n        const configWindow = config.window;\n        const initialWindow: Rect = {\n            left: configWindow.left ?? (globalThis.screenX || globalThis.screenLeft + 20),\n            top: configWindow.top ?? (globalThis.screenY || globalThis.screenTop + 20),\n            width: configWindow.width ?? 500,\n            height: configWindow.height ?? 309,\n        };\n\n        const browserPopout = new BrowserPopout(config, initialWindow, this);\n\n        browserPopout.on('initialised', () => this.emit('windowOpened', browserPopout));\n        browserPopout.on('closed', () => this.reconcilePopoutWindows());\n\n        this._openPopouts.push(browserPopout);\n\n        if (this.layoutConfig.settings.closePopoutsOnUnload && !this._windowBeforeUnloadListening) {\n            globalThis.addEventListener('beforeunload', this._windowBeforeUnloadListener, { passive: true });\n            this._windowBeforeUnloadListening = true;\n        }\n\n        return browserPopout;\n    }\n\n    /**\n     * Closes all Open Popouts\n     * Applications can call this method when a page is unloaded to remove its open popouts\n     */\n\n    closeAllOpenPopouts() {\n        for (let i = 0; i < this._openPopouts.length; i++) {\n            this._openPopouts[i].close();\n        }\n\n        this._openPopouts.length = 0;\n\n        if (this._windowBeforeUnloadListening) {\n            globalThis.removeEventListener('beforeunload', this._windowBeforeUnloadListener);\n            this._windowBeforeUnloadListening = false;\n        }\n    }\n\n    /**\n     * Attaches DragListener to any given DOM element\n     * and turns it into a way of creating new ComponentItems\n     * by 'dragging' the DOM element into the layout\n     *\n     * @param element - The HTML element which will be listened to for commencement of drag.\n     * @param componentTypeOrItemConfigCallback - Type of component to be created, or a callback which will provide the ItemConfig\n     * to be used to create the component.\n     * @param componentState - Optional initial state of component.  This will be ignored if componentTypeOrFtn is a function.\n     *\n     * @returns an opaque object that identifies the DOM element\n\t *          and the attached itemConfig. This can be used in\n\t *          removeDragSource() later to get rid of the drag listeners.\n     */\n    newDragSource(element: HTMLElement, itemConfigCallback: () => (DragSource.ComponentItemConfig | ComponentItemConfig)): DragSource;\n    /** @deprecated will be replaced in version 3 with newDragSource(element: HTMLElement, itemConfig: ComponentItemConfig) */\n    newDragSource(element: HTMLElement, componentType: JsonValue, componentState?: JsonValue, title?: JsonValue, id?: string): DragSource;\n    newDragSource(element: HTMLElement,\n        componentTypeOrItemConfigCallback: JsonValue | (() => (DragSource.ComponentItemConfig | ComponentItemConfig)),\n        componentState?: JsonValue,\n        title?: string,\n        id?: string,\n    ): DragSource {\n        const dragSource = new DragSource(this, element, [], componentTypeOrItemConfigCallback, componentState, title, id);\n        this._dragSources.push(dragSource);\n\n        return dragSource;\n    }\n\n    /**\n\t * Removes a DragListener added by createDragSource() so the corresponding\n\t * DOM element is not a drag source any more.\n\t */\n\tremoveDragSource(dragSource: DragSource): void {\n\t\tremoveFromArray(dragSource, this._dragSources );\n\t\tdragSource.destroy();\n    }\n\n    /** @internal */\n    startComponentDrag(x: number, y: number, dragListener: DragListener, componentItem: ComponentItem, stack: Stack): void {\n        new DragProxy(\n            x,\n            y,\n            dragListener,\n            this,\n            componentItem,\n            stack\n        );\n    }\n\n    /**\n     * Programmatically focuses an item. This focuses the specified component item\n     * and the item emits a focus event\n     *\n     * @param item - The component item to be focused\n     * @param suppressEvent - Whether to emit focus event\n     */\n    focusComponent(item: ComponentItem, suppressEvent = false): void {\n        item.focus(suppressEvent);\n    }\n\n    /**\n     * Programmatically blurs (defocuses) the currently focused component.\n     * If a component item is focused, then it is blurred and and the item emits a blur event\n     *\n     * @param item - The component item to be blurred\n     * @param suppressEvent - Whether to emit blur event\n     */\n    clearComponentFocus(suppressEvent = false): void {\n        this.setFocusedComponentItem(undefined, suppressEvent);\n    }\n\n    /**\n     * Programmatically focuses a component item or removes focus (blurs) from an existing focused component item.\n     *\n     * @param item - If defined, specifies the component item to be given focus.  If undefined, clear component focus.\n     * @param suppressEvents - Whether to emit focus and blur events\n     * @internal\n     */\n    setFocusedComponentItem(item: ComponentItem | undefined, suppressEvents = false): void {\n        if (item !== this._focusedComponentItem) {\n\n            let newFocusedParentItem: ComponentParentableItem | undefined;\n            if (item === undefined) {\n                newFocusedParentItem === undefined;\n            } else {\n                newFocusedParentItem = item.parentItem;\n            }\n\n            if (this._focusedComponentItem !== undefined) {\n                const oldFocusedItem = this._focusedComponentItem;\n                this._focusedComponentItem = undefined;\n                oldFocusedItem.setBlurred(suppressEvents);\n                const oldFocusedParentItem = oldFocusedItem.parentItem;\n                if (newFocusedParentItem === oldFocusedParentItem) {\n                    newFocusedParentItem = undefined;\n                } else {\n                    oldFocusedParentItem.setFocusedValue(false);\n                }\n            }\n\n            if (item !== undefined) {\n                this._focusedComponentItem = item;\n                item.setFocused(suppressEvents);\n                if (newFocusedParentItem !== undefined) {\n                    newFocusedParentItem.setFocusedValue(true);\n                }\n            }\n        }\n    }\n\n    /** @internal */\n    private createContentItemFromConfig(config: ResolvedItemConfig, parent: ContentItem): ContentItem {\n        switch (config.type) {\n            case ItemType.ground: throw new AssertError('LMCCIFC68871');\n            case ItemType.row: return new RowOrColumn(false, this, config as ResolvedRowOrColumnItemConfig, parent);\n            case ItemType.column: return new RowOrColumn(true, this, config as ResolvedRowOrColumnItemConfig, parent);\n            case ItemType.stack: return new Stack(this, config as ResolvedStackItemConfig, parent);\n            case ItemType.component:\n                return new ComponentItem(this, config as ResolvedComponentItemConfig, parent as Stack);\n            default:\n                throw new UnreachableCaseError('CCC913564', config.type, 'Invalid Config Item type specified');\n        }\n    }\n\n    /**\n     * This should only be called from stack component.\n     * Stack will look after docking processing associated with maximise/minimise\n     * @internal\n     **/\n    setMaximisedStack(stack: Stack | undefined): void {\n        if (stack === undefined) {\n            if (this._maximisedStack !== undefined) {\n                this.processMinimiseMaximisedStack();\n            }\n        } else {\n            if (stack !== this._maximisedStack) {\n                if (this._maximisedStack !== undefined) {\n                    this.processMinimiseMaximisedStack();\n                }\n\n                this.processMaximiseStack(stack);\n            }\n        }\n    }\n\n    checkMinimiseMaximisedStack(): void {\n        if (this._maximisedStack !== undefined) {\n            this._maximisedStack.minimise();\n        }\n    }\n\n    // showAllActiveContentItems() was called from ContentItem.show().  Not sure what its purpose was so have commented out\n    // Everything seems to work ok without this.  Have left commented code just in case there was a reason for it becomes\n    // apparent\n\n    // /** @internal */\n    // showAllActiveContentItems(): void {\n    //     const allStacks = this.getAllStacks();\n\n    //     for (let i = 0; i < allStacks.length; i++) {\n    //         const stack = allStacks[i];\n    //         const activeContentItem = stack.getActiveComponentItem();\n\n    //         if (activeContentItem !== undefined) {\n    //             if (!(activeContentItem instanceof ComponentItem)) {\n    //                 throw new AssertError('LMSAACIS22298');\n    //             } else {\n    //                 activeContentItem.container.show();\n    //             }\n    //         }\n    //     }\n    // }\n\n    // hideAllActiveContentItems() was called from ContentItem.hide().  Not sure what its purpose was so have commented out\n    // Everything seems to work ok without this.  Have left commented code just in case there was a reason for it becomes\n    // apparent\n\n    // /** @internal */\n    // hideAllActiveContentItems(): void {\n    //     const allStacks = this.getAllStacks();\n\n    //     for (let i = 0; i < allStacks.length; i++) {\n    //         const stack = allStacks[i];\n    //         const activeContentItem = stack.getActiveComponentItem();\n\n    //         if (activeContentItem !== undefined) {\n    //             if (!(activeContentItem instanceof ComponentItem)) {\n    //                 throw new AssertError('LMSAACIH22298');\n    //             } else {\n    //                 activeContentItem.container.hide();\n    //             }\n    //         }\n    //     }\n    // }\n\n    /** @internal */\n    private cleanupBeforeMaximisedStackDestroyed(event: EventEmitter.BubblingEvent) {\n\t\tif (this._maximisedStack !== null && this._maximisedStack === event.target) {\n\t\t\tthis._maximisedStack.off('beforeItemDestroyed', this._maximisedStackBeforeDestroyedListener);\n\t\t\tthis._maximisedStack = undefined;\n\t\t}\n    }\n\n    /**\n     * This method is used to get around sandboxed iframe restrictions.\n     * If 'allow-top-navigation' is not specified in the iframe's 'sandbox' attribute\n     * (as is the case with codepens) the parent window is forbidden from calling certain\n     * methods on the child, such as window.close() or setting document.location.href.\n     *\n     * This prevented GoldenLayout popouts from popping in in codepens. The fix is to call\n     * _$closeWindow on the child window's gl instance which (after a timeout to disconnect\n     * the invoking method from the close call) closes itself.\n     *\n     * @internal\n     */\n    closeWindow(): void {\n        globalThis.setTimeout(() => globalThis.close(), 1);\n    }\n\n    /** @internal */\n    getArea(x: number, y: number): ContentItem.Area | null {\n        let matchingArea = null;\n        let smallestSurface = Infinity;\n\n        for (let i = 0; i < this._itemAreas.length; i++) {\n            const area = this._itemAreas[i];\n\n            if (\n                x >= area.x1 &&\n                x < area.x2 && // x2 is not included in area\n                y >= area.y1 &&\n                y < area.y2 && // y2 is not included in area\n                smallestSurface > area.surface\n            ) {\n                smallestSurface = area.surface;\n                matchingArea = area;\n            }\n        }\n\n        return matchingArea;\n    }\n\n    /** @internal */\n    calculateItemAreas(): void {\n        const allContentItems = this.getAllContentItems();\n        /**\n         * If the last item is dragged out, highlight the entire container size to\n         * allow to re-drop it. this.ground.contentiItems.length === 0 at this point\n         *\n         * Don't include ground into the possible drop areas though otherwise since it\n         * will used for every gap in the layout, e.g. splitters\n         */\n        const groundItem = this._groundItem;\n        if (groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMCIAR44365');\n        } else {\n            if (allContentItems.length === 1) {\n                // No root ContentItem (just Ground ContentItem)\n                const groundArea = groundItem.getElementArea();\n                if (groundArea === null) {\n                    throw new UnexpectedNullError('LMCIARA44365')\n                } else {\n                    this._itemAreas = [groundArea];\n                }\n                return;\n            } else {\n                if (groundItem.contentItems[0].isStack) {\n                    // if root is Stack, then split stack and sides of Layout are same, so skip sides\n                    this._itemAreas = [];\n                } else {\n                    // sides of layout\n                    this._itemAreas = groundItem.createSideAreas();\n                }\n\n                for (let i = 0; i < allContentItems.length; i++) {\n                    const stack = allContentItems[i];\n                    if (ContentItem.isStack(stack)) {\n                        const area = stack.getArea();\n\n                        if (area === null) {\n                            continue;\n                        } else {\n                            this._itemAreas.push(area);\n                            const stackContentAreaDimensions = stack.contentAreaDimensions;\n                            if (stackContentAreaDimensions === undefined) {\n                                throw new UnexpectedUndefinedError('LMCIASC45599');\n                            } else {\n                                const highlightArea = stackContentAreaDimensions.header.highlightArea\n                                const surface = (highlightArea.x2 - highlightArea.x1) * (highlightArea.y2 - highlightArea.y1);\n\n                                const header: ContentItem.Area = {\n                                    x1: highlightArea.x1,\n                                    x2: highlightArea.x2,\n                                    y1: highlightArea.y1,\n                                    y2: highlightArea.y2,\n                                    contentItem: stack,\n                                    surface,\n                                };\n                                this._itemAreas.push(header);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Called as part of loading a new layout (including initial init()).\n     * Checks to see layout has a maximised item. If so, it maximises that item.\n     * @internal\n     */\n    private checkLoadedLayoutMaximiseItem() {\n        if (this._groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMCLLMI43432');\n        } else {\n            const configMaximisedItems = this._groundItem.getConfigMaximisedItems();\n\n            if (configMaximisedItems.length > 0) {\n                let item = configMaximisedItems[0];\n                if (ContentItem.isComponentItem(item)) {\n                    const stack = item.parent;\n                    if (stack === null) {\n                        throw new UnexpectedNullError('LMXLLMI69999');\n                    } else {\n                        item = stack;\n                    }\n                }\n                if (!ContentItem.isStack(item)) {\n                    throw new AssertError('LMCLLMI19993');\n                } else {\n                    item.maximise();\n                }\n            }\n        }\n    }\n\n    /** @internal */\n    private processMaximiseStack(stack: Stack): void {\n        this._maximisedStack = stack;\n        stack.on('beforeItemDestroyed', this._maximisedStackBeforeDestroyedListener);\n        stack.element.classList.add(DomConstants.ClassName.Maximised);\n        stack.element.insertAdjacentElement('afterend', this._maximisePlaceholder);\n        if (this._groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMMXI19993');\n        } else {\n            this._groundItem.element.prepend(stack.element);\n            const { width, height } = getElementWidthAndHeight(this._containerElement);\n            setElementWidth(stack.element, width);\n            setElementHeight(stack.element, height);\n            stack.updateSize(true);\n            stack.focusActiveContentItem();\n            this._maximisedStack.emit('maximised');\n            this.emit('stateChanged');\n        }\n    }\n\n    /** @internal */\n    private processMinimiseMaximisedStack(): void {\n        if (this._maximisedStack === undefined) {\n            throw new AssertError('LMMMS74422');\n        } else {\n            const stack = this._maximisedStack;\n            if (stack.parent === null) {\n                throw new UnexpectedNullError('LMMI13668');\n            } else {\n                stack.element.classList.remove(DomConstants.ClassName.Maximised);\n                this._maximisePlaceholder.insertAdjacentElement('afterend', stack.element);\n                this._maximisePlaceholder.remove();\n                this.updateRootSize(true);\n                this._maximisedStack = undefined;\n                stack.off('beforeItemDestroyed', this._maximisedStackBeforeDestroyedListener);\n                stack.emit('minimised');\n                this.emit('stateChanged');\n            }\n        }\n    }\n\n    /**\n     * Iterates through the array of open popout windows and removes the ones\n     * that are effectively closed. This is necessary due to the lack of reliably\n     * listening for window.close / unload events in a cross browser compatible fashion.\n     * @internal\n     */\n    private reconcilePopoutWindows() {\n        const openPopouts: BrowserPopout[] = [];\n\n        for (let i = 0; i < this._openPopouts.length; i++) {\n            if (this._openPopouts[i].getWindow().closed === false) {\n                openPopouts.push(this._openPopouts[i]);\n            } else {\n                this.emit('windowClosed', this._openPopouts[i]);\n            }\n        }\n\n        if (this._openPopouts.length !== openPopouts.length) {\n            this._openPopouts = openPopouts;\n            this.emit('stateChanged');\n        }\n\n    }\n\n    /**\n     * Returns a flattened array of all content items,\n     * regardles of level or type\n     * @internal\n     */\n    private getAllContentItems() {\n        if (this._groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMGACI13130');\n        } else {\n            return this._groundItem.getAllContentItems();\n        }\n    }\n\n    /**\n     * Creates Subwindows (if there are any). Throws an error\n     * if popouts are blocked.\n     * @internal\n     */\n    private createSubWindows() {\n        for (let i = 0; i < this.layoutConfig.openPopouts.length; i++) {\n            const popoutConfig = this.layoutConfig.openPopouts[i];\n            this.createPopoutFromPopoutLayoutConfig(popoutConfig);\n        }\n    }\n\n    /**\n     * Debounces resize events\n     * @internal\n     */\n    private handleContainerResize(): void {\n        if (this.resizeWithContainerAutomatically) {\n            this.processResizeWithDebounce();\n        }\n    }\n\n    /**\n     * Debounces resize events\n     * @internal\n     */\n    private processResizeWithDebounce(): void {\n        if (this.resizeDebounceExtendedWhenPossible) {\n            this.checkClearResizeTimeout();\n        }\n\n        if (this._resizeTimeoutId === undefined) {\n            this._resizeTimeoutId = setTimeout(\n                () => {\n                    this._resizeTimeoutId = undefined;\n                    this.beginSizeInvalidation();\n                    this.endSizeInvalidation();\n                },\n                this.resizeDebounceInterval,\n            );\n        }\n    }\n\n    private checkClearResizeTimeout() {\n        if (this._resizeTimeoutId !== undefined) {\n            clearTimeout(this._resizeTimeoutId);\n            this._resizeTimeoutId = undefined;\n        }\n    }\n\n    /**\n     * Determines what element the layout will be created in\n     * @internal\n     */\n    private setContainer() {\n        const bodyElement = document.body;\n        const containerElement = this._containerElement ?? bodyElement;\n\n        if (containerElement === bodyElement) {\n            this.resizeWithContainerAutomatically = true;\n\n            const documentElement = document.documentElement;\n            documentElement.style.height = '100%';\n            documentElement.style.margin = '0';\n            documentElement.style.padding = '0';\n            documentElement.style.overflow = 'clip';\n            bodyElement.style.height = '100%';\n            bodyElement.style.margin = '0';\n            bodyElement.style.padding = '0';\n            bodyElement.style.overflow = 'clip';\n        }\n\n        this._containerElement = containerElement;\n    }\n\n    /**\n     * Called when the window is closed or the user navigates away\n     * from the page\n     * @internal\n     * @deprecated to be removed in version 3\n     */\n    private onBeforeUnload(): void {\n        this.destroy();\n    }\n\n    /**\n     * Adjusts the number of columns to be lower to fit the screen and still maintain minItemWidth.\n     * @internal\n     */\n    private adjustColumnsResponsive() {\n        if (this._groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMACR20883');\n        } else {\n            this._firstLoad = false;\n            // If there is no min width set, or not content items, do nothing.\n            if (this.useResponsiveLayout() &&\n                !this._updatingColumnsResponsive &&\n                this._groundItem.contentItems.length > 0 &&\n                this._groundItem.contentItems[0].isRow)\n            {\n                if (this._groundItem === undefined || this._width === null) {\n                    throw new UnexpectedUndefinedError('LMACR77412');\n                } else {\n                    // If there is only one column, do nothing.\n                    const columnCount = this._groundItem.contentItems[0].contentItems.length;\n                    if (columnCount <= 1) {\n                        return;\n                    } else {\n                        // If they all still fit, do nothing.\n                        const minItemWidth = this.layoutConfig.dimensions.defaultMinItemWidth;\n                        const totalMinWidth = columnCount * minItemWidth;\n                        if (totalMinWidth <= this._width) {\n                            return;\n                        } else {\n                            // Prevent updates while it is already happening.\n                            this._updatingColumnsResponsive = true;\n\n                            // Figure out how many columns to stack, and put them all in the first stack container.\n                            const finalColumnCount = Math.max(Math.floor(this._width / minItemWidth), 1);\n                            const stackColumnCount = columnCount - finalColumnCount;\n\n                            const rootContentItem = this._groundItem.contentItems[0];\n                            const allStacks = this.getAllStacks();\n                            if (allStacks.length === 0) {\n                                throw new AssertError('LMACRS77413')\n                            } else {\n                                const firstStackContainer = allStacks[0];\n                                for (let i = 0; i < stackColumnCount; i++) {\n                                    // Stack from right.\n                                    const column = rootContentItem.contentItems[rootContentItem.contentItems.length - 1];\n                                    this.addChildContentItemsToContainer(firstStackContainer, column);\n                                }\n\n                                this._updatingColumnsResponsive = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Determines if responsive layout should be used.\n     *\n     * @returns True if responsive layout should be used; otherwise false.\n     * @internal\n     */\n    private useResponsiveLayout() {\n        const settings = this.layoutConfig.settings;\n        const alwaysResponsiveMode = settings.responsiveMode === ResponsiveMode.always;\n        const onLoadResponsiveModeAndFirst = settings.responsiveMode === ResponsiveMode.onload && this._firstLoad;\n        return alwaysResponsiveMode || onLoadResponsiveModeAndFirst;\n    }\n\n    /**\n     * Adds all children of a node to another container recursively.\n     * @param container - Container to add child content items to.\n     * @param node - Node to search for content items.\n     * @internal\n     */\n    private addChildContentItemsToContainer(container: ContentItem, node: ContentItem) {\n        const contentItems = node.contentItems;\n        if (node instanceof Stack) {\n            for (let i = 0; i < contentItems.length; i++) {\n                const item = contentItems[i];\n                node.removeChild(item, true);\n                container.addChild(item);\n            }\n        } else {\n            for (let i = 0; i < contentItems.length; i++) {\n                const item = contentItems[i];\n                this.addChildContentItemsToContainer(container, item);\n            }\n        }\n    }\n\n    /**\n     * Finds all the stacks.\n     * @returns The found stack containers.\n     * @internal\n     */\n    private getAllStacks() {\n        if (this._groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMFASC52778');\n        } else {\n            const stacks: Stack[] = [];\n            this.findAllStacksRecursive(stacks, this._groundItem);\n\n            return stacks;\n        }\n    }\n\n    /** @internal */\n    private findFirstContentItemType(type: ItemType): ContentItem | undefined {\n        if (this._groundItem === undefined) {\n            throw new UnexpectedUndefinedError('LMFFCIT82446');\n        } else {\n            return this.findFirstContentItemTypeRecursive(type, this._groundItem);\n        }\n    }\n\n    /** @internal */\n    private findFirstContentItemTypeRecursive(type: ItemType, node: ContentItem): ContentItem | undefined {\n        const contentItems = node.contentItems;\n        const contentItemCount = contentItems.length;\n        if (contentItemCount === 0) {\n            return undefined;\n        } else {\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                if (contentItem.type === type) {\n                    return contentItem;\n                }\n            }\n\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                const foundContentItem = this.findFirstContentItemTypeRecursive(type, contentItem);\n                if (foundContentItem !== undefined) {\n                    return foundContentItem;\n                }\n            }\n\n            return undefined;\n        }\n    }\n\n    /** @internal */\n    private findFirstContentItemTypeByIdRecursive(type: ItemType, id: string, node: ContentItem): ContentItem | undefined {\n        const contentItems = node.contentItems;\n        const contentItemCount = contentItems.length;\n        if (contentItemCount === 0) {\n            return undefined;\n        } else {\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                if (contentItem.type === type && contentItem.id === id) {\n                    return contentItem;\n                }\n            }\n\n            for (let i = 0; i < contentItemCount; i++) {\n                const contentItem = contentItems[i];\n                const foundContentItem = this.findFirstContentItemTypeByIdRecursive(type, id, contentItem);\n                if (foundContentItem !== undefined) {\n                    return foundContentItem;\n                }\n            }\n\n            return undefined;\n        }\n    }\n\n    /**\n     * Finds all the stack containers.\n     *\n     * @param stacks - Set of containers to populate.\n     * @param node - Current node to process.\n     * @internal\n     */\n    private findAllStacksRecursive(stacks: Stack[], node: ContentItem) {\n        const contentItems = node.contentItems;\n        for (let i = 0; i < contentItems.length; i++) {\n            const item = contentItems[i];\n            if (item instanceof Stack) {\n                stacks.push(item);\n            } else {\n                if (!item.isComponent) {\n                    this.findAllStacksRecursive(stacks, item);\n                }\n            }\n        }\n    }\n\n    /** @internal */\n    private findFirstLocation(selectors: readonly LayoutManager.LocationSelector[]): LayoutManager.Location | undefined {\n        const count = selectors.length;\n        for (let i = 0; i < count; i++) {\n            const selector = selectors[i];\n            const location = this.findLocation(selector);\n            if (location !== undefined) {\n                return location;\n            }\n        }\n        return undefined;\n    }\n\n    /** @internal */\n    private findLocation(selector: LayoutManager.LocationSelector): LayoutManager.Location | undefined {\n        const selectorIndex = selector.index;\n        switch (selector.typeId) {\n            case LayoutManager.LocationSelector.TypeId.FocusedItem: {\n                if (this._focusedComponentItem === undefined) {\n                    return undefined\n                } else {\n                    const parentItem = this._focusedComponentItem.parentItem;\n                    const parentContentItems = parentItem.contentItems;\n                    const parentContentItemCount = parentContentItems.length;\n                    if (selectorIndex === undefined) {\n                        return { parentItem, index: parentContentItemCount };\n                    } else {\n                        const focusedIndex = parentContentItems.indexOf(this._focusedComponentItem);\n                        const index = focusedIndex + selectorIndex;\n                        if (index < 0 || index > parentContentItemCount) {\n                            return undefined;\n                        } else {\n                            return { parentItem, index };\n                        }\n                    }\n                }\n            }\n            case LayoutManager.LocationSelector.TypeId.FocusedStack: {\n                if (this._focusedComponentItem === undefined) {\n                    return undefined\n                } else {\n                    const parentItem = this._focusedComponentItem.parentItem;\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                }\n            }\n            case LayoutManager.LocationSelector.TypeId.FirstStack: {\n                const parentItem = this.findFirstContentItemType(ItemType.stack);\n                if (parentItem === undefined) {\n                    return undefined;\n                } else {\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                }\n            }\n            case LayoutManager.LocationSelector.TypeId.FirstRowOrColumn: {\n                let parentItem = this.findFirstContentItemType(ItemType.row);\n                if (parentItem !== undefined) {\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                } else {\n                    parentItem = this.findFirstContentItemType(ItemType.column);\n                    if (parentItem !== undefined) {\n                        return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                    } else {\n                        return undefined;\n                    }\n                }\n            }\n            case LayoutManager.LocationSelector.TypeId.FirstRow: {\n                const parentItem = this.findFirstContentItemType(ItemType.row);\n                if (parentItem === undefined) {\n                    return undefined;\n                } else {\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                }\n            }\n            case LayoutManager.LocationSelector.TypeId.FirstColumn: {\n                const parentItem = this.findFirstContentItemType(ItemType.column);\n                if (parentItem === undefined) {\n                    return undefined;\n                } else {\n                    return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                }\n            }\n            case LayoutManager.LocationSelector.TypeId.Empty: {\n                if (this._groundItem === undefined) {\n                    throw new UnexpectedUndefinedError('LMFLRIF18244');\n                } else {\n                    if (this.rootItem !== undefined) {\n                        return undefined;\n                    } else {\n                        if (selectorIndex === undefined || selectorIndex === 0)\n                            return { parentItem: this._groundItem, index: 0 };\n                        else {\n                            return undefined;\n                        }\n                    }\n                }\n            }\n            case LayoutManager.LocationSelector.TypeId.Root: {\n                if (this._groundItem === undefined) {\n                    throw new UnexpectedUndefinedError('LMFLF18244');\n                } else {\n                    const groundContentItems = this._groundItem.contentItems;\n                    if (groundContentItems.length === 0) {\n                        if (selectorIndex === undefined || selectorIndex === 0)\n                            return { parentItem: this._groundItem, index: 0 };\n                        else {\n                            return undefined;\n                        }\n                    } else {\n                        const parentItem = groundContentItems[0];\n                        return this.tryCreateLocationFromParentItem(parentItem, selectorIndex);\n                    }\n                }\n            }\n        }\n    }\n\n    /** @internal */\n    private tryCreateLocationFromParentItem(parentItem: ContentItem,\n        selectorIndex: number | undefined\n    ): LayoutManager.Location | undefined {\n        const parentContentItems = parentItem.contentItems;\n        const parentContentItemCount = parentContentItems.length;\n        if (selectorIndex === undefined) {\n            return { parentItem, index: parentContentItemCount };\n        } else {\n            if (selectorIndex < 0 || selectorIndex > parentContentItemCount) {\n                return undefined;\n            } else {\n                return { parentItem, index: selectorIndex };\n            }\n        }\n    }\n}\n\n/** @public */\nexport namespace LayoutManager {\n    export type BeforeVirtualRectingEvent = (this: void, count: number) => void;\n    export type AfterVirtualRectingEvent = (this: void) => void;\n\n    /** @internal */\n    export interface ConstructorParameters {\n        constructorOrSubWindowLayoutConfig: LayoutConfig | undefined;\n        isSubWindow: boolean;\n        containerElement: HTMLElement | undefined;\n    }\n\n    /** @internal */\n    export function createMaximisePlaceElement(document: Document): HTMLElement {\n        const element = document.createElement('div');\n        element.classList.add(DomConstants.ClassName.MaximisePlace);\n        return element;\n    }\n\n    /** @internal */\n    export function createTabDropPlaceholderElement(document: Document): HTMLElement {\n        const element = document.createElement('div');\n        element.classList.add(DomConstants.ClassName.DropTabPlaceholder);\n        return element;\n    }\n\n    /**\n     * Specifies a location of a ContentItem without referencing the content item.\n     * Used to specify where a new item is to be added\n     * @public\n     */\n    export interface Location {\n        parentItem: ContentItem;\n        index: number;\n    }\n\n    /**\n     * A selector used to specify a unique location in the layout\n     * @public\n     */\n    export interface LocationSelector {\n        /** Specifies selector algorithm */\n        typeId: LocationSelector.TypeId;\n        /** Used by algorithm to determine index in found ContentItem */\n        index?: number;\n    }\n\n    /** @public */\n    export namespace LocationSelector {\n        export const enum TypeId {\n            /** Stack with focused Item. Index specifies offset from index of focused item (eg 1 is the position after focused item) */\n            FocusedItem,\n            /** Stack with focused Item. Index specfies ContentItems index */\n            FocusedStack,\n            /** First stack found in layout */\n            FirstStack,\n            /** First Row or Column found in layout (rows are searched first) */\n            FirstRowOrColumn,\n            /** First Row in layout */\n            FirstRow,\n            /** First Column in layout */\n            FirstColumn,\n            /** Finds a location if layout is empty. The found location will be the root ContentItem. */\n            Empty,\n            /** Finds root if layout is empty, otherwise a child under root */\n            Root,\n        }\n    }\n\n    /**\n     * Default LocationSelectors array used if none is specified.  Will always find a location.\n     * @public\n     */\n    export const defaultLocationSelectors: readonly LocationSelector[] = [\n        { typeId: LocationSelector.TypeId.FocusedStack, index: undefined },\n        { typeId: LocationSelector.TypeId.FirstStack, index: undefined },\n        { typeId: LocationSelector.TypeId.FirstRowOrColumn, index: undefined },\n        { typeId: LocationSelector.TypeId.Root, index: undefined },\n    ];\n\n    /**\n     * LocationSelectors to try to get location next to existing focused item\n     * @public\n     */\n    export const afterFocusedItemIfPossibleLocationSelectors: readonly LocationSelector[] = [\n        { typeId: LocationSelector.TypeId.FocusedItem, index: 1 },\n        { typeId: LocationSelector.TypeId.FirstStack, index: undefined },\n        { typeId: LocationSelector.TypeId.FirstRowOrColumn, index: undefined },\n        { typeId: LocationSelector.TypeId.Root, index: undefined },\n    ];\n}\n", "import { LayoutConfig } from './config/config';\nimport { ResolvedComponentItemConfig, ResolvedLayoutConfig, ResolvedPopoutLayoutConfig } from './config/resolved-config';\nimport { ComponentContainer } from './container/component-container';\nimport { BindError } from './errors/external-error';\nimport { UnexpectedUndefinedError } from './errors/internal-error';\nimport { LayoutManager } from './layout-manager';\nimport { DomConstants } from './utils/dom-constants';\nimport { I18nStringId, i18nStrings } from './utils/i18n-strings';\n\n/** @public */\nexport class VirtualLayout extends LayoutManager {\n    /**\n     * @deprecated Use {@link (VirtualLayout:class).bindComponentEvent} and\n     * {@link (VirtualLayout:class).unbindComponentEvent} with virtual components\n     */\n    getComponentEvent: VirtualLayout.GetComponentEventHandler | undefined;\n    /**\n     * @deprecated Use {@link (VirtualLayout:class).bindComponentEvent} and\n     * {@link (VirtualLayout:class).unbindComponentEvent} with virtual components\n     */\n    releaseComponentEvent: VirtualLayout.ReleaseComponentEventHandler | undefined;\n\n    bindComponentEvent: VirtualLayout.BindComponentEventHandler | undefined;\n    unbindComponentEvent: VirtualLayout.UnbindComponentEventHandler | undefined;\n\n    /** @internal @deprecated use while constructor is not determinate */\n    private _bindComponentEventHanlderPassedInConstructor = false; // remove when constructor is determinate\n    /** @internal  @deprecated use while constructor is not determinate */\n    private _creationTimeoutPassed = false; // remove when constructor is determinate\n\n    /**\n     * @param container - A Dom HTML element. Defaults to body\n     * @param bindComponentEventHandler - Event handler to bind components\n     * @param bindComponentEventHandler - Event handler to unbind components\n     * If bindComponentEventHandler is defined, then constructor will be determinate. It will always call the init()\n     * function and the init() function will always complete. This means that the bindComponentEventHandler will be called\n     * if constructor is for a popout window. Make sure bindComponentEventHandler is ready for events.\n     */\n    constructor(\n        container?: HTMLElement,\n        bindComponentEventHandler?: VirtualLayout.BindComponentEventHandler,\n        unbindComponentEventHandler?: VirtualLayout.UnbindComponentEventHandler,\n    );\n    /** @deprecated specify layoutConfig in {@link (LayoutManager:class).loadLayout} */\n    constructor(config: LayoutConfig, container?: HTMLElement);\n    /** @internal */\n    constructor(configOrOptionalContainer: LayoutConfig | HTMLElement | undefined,\n        containerOrBindComponentEventHandler: HTMLElement | VirtualLayout.BindComponentEventHandler | undefined,\n        unbindComponentEventHandler: VirtualLayout.UnbindComponentEventHandler | undefined,\n        skipInit: true,\n    );\n    /** @internal */\n    constructor(configOrOptionalContainer: LayoutConfig | HTMLElement | undefined,\n        containerOrBindComponentEventHandler?: HTMLElement | VirtualLayout.BindComponentEventHandler,\n        unbindComponentEventHandler?: VirtualLayout.UnbindComponentEventHandler,\n        skipInit?: true,\n    ) {\n        super(VirtualLayout.createLayoutManagerConstructorParameters(configOrOptionalContainer, containerOrBindComponentEventHandler));\n\n        if (containerOrBindComponentEventHandler !== undefined) {\n            if (typeof containerOrBindComponentEventHandler === 'function') {\n                this.bindComponentEvent = containerOrBindComponentEventHandler;\n                this._bindComponentEventHanlderPassedInConstructor = true;\n\n                if (unbindComponentEventHandler !== undefined) {\n                    this.unbindComponentEvent = unbindComponentEventHandler;\n                }\n            }\n        }\n\n        if (!this._bindComponentEventHanlderPassedInConstructor) {\n            // backward compatibility\n\n            if (this.isSubWindow) {\n                // document.body.style.visibility = 'hidden';\n                // Set up layoutConfig since constructor is not determinate and may exit early. Other functions may need\n                // this.layoutConfig. this.layoutConfig is again calculated in the same way when init() completes.\n                // Remove this when constructor is determinate.\n                if (this._constructorOrSubWindowLayoutConfig === undefined) {\n                    throw new UnexpectedUndefinedError('VLC98823');\n                } else {\n                    const resolvedLayoutConfig = LayoutConfig.resolve(this._constructorOrSubWindowLayoutConfig);\n                    // remove root from layoutConfig\n                    this.layoutConfig = {\n                        ...resolvedLayoutConfig,\n                        root: undefined,\n                    }\n                }\n            }\n        }\n\n        if (skipInit !== true) {\n            if (!this.deprecatedConstructor) {\n                this.init();\n            }\n        }\n    }\n\n    override destroy(): void {\n        this.bindComponentEvent = undefined;\n        this.unbindComponentEvent = undefined;\n\n        super.destroy();\n    }\n\n\n    /**\n     * Creates the actual layout. Must be called after all initial components\n     * are registered. Recurses through the configuration and sets up\n     * the item tree.\n     *\n     * If called before the document is ready it adds itself as a listener\n     * to the document.ready event\n     * @deprecated LayoutConfig should not be loaded in {@link (LayoutManager:class)} constructor, but rather in a\n     * {@link (LayoutManager:class).loadLayout} call.  If LayoutConfig is not specified in {@link (LayoutManager:class)} constructor,\n     * then init() will be automatically called internally and should not be called externally.\n     */\n    override init(): void {\n\n        /**\n         * If the document isn't ready yet, wait for it.\n         */\n        if (!this._bindComponentEventHanlderPassedInConstructor && (document.readyState === 'loading' || document.body === null)) {\n            document.addEventListener('DOMContentLoaded', () => this.init(), { passive: true });\n            return;\n        }\n\n        /**\n         * If this is a subwindow, wait a few milliseconds for the original\n         * page's js calls to be executed, then replace the bodies content\n         * with GoldenLayout\n         */\n        if (!this._bindComponentEventHanlderPassedInConstructor && this.isSubWindow === true && !this._creationTimeoutPassed) {\n            setTimeout(() => this.init(), 7);\n            this._creationTimeoutPassed = true;\n            return;\n        }\n\n        if (this.isSubWindow === true) {\n            if (!this._bindComponentEventHanlderPassedInConstructor) {\n                this.clearHtmlAndAdjustStylesForSubWindow();\n            }\n\n            // Expose this instance on the window object to allow the opening window to interact with it\n            window.__glInstance = this;\n        }\n\n        super.init();\n    }\n\n    /**\n     * Clears existing HTML and adjusts style to make window suitable to be a popout sub window\n     * Curently is automatically called when window is a subWindow and bindComponentEvent is not passed in the constructor\n     * If bindComponentEvent is not passed in the constructor, the application must either call this function explicitly or\n     * (preferably) make the window suitable as a subwindow.\n     * In the future, it is planned that this function is NOT automatically called in any circumstances.  Applications will\n     * need to determine whether a window is a Golden Layout popout window and either call this function explicitly or\n     * hide HTML not relevant to the popout.\n     * See apitest for an example of how HTML is hidden when popout windows are displayed\n     */\n    clearHtmlAndAdjustStylesForSubWindow(): void {\n        const headElement = document.head;\n\n        const appendNodeLists = new Array<NodeListOf<Element>>(4);\n        appendNodeLists[0] = document.querySelectorAll('body link');\n        appendNodeLists[1] = document.querySelectorAll('body style');\n        appendNodeLists[2] = document.querySelectorAll('template');\n        appendNodeLists[3] = document.querySelectorAll('.gl_keep');\n\n        for (let listIdx = 0; listIdx < appendNodeLists.length; listIdx++) {\n            const appendNodeList = appendNodeLists[listIdx];\n            for (let nodeIdx = 0; nodeIdx < appendNodeList.length; nodeIdx++) {\n                const node = appendNodeList[nodeIdx];\n                headElement.appendChild(node);\n            }\n        }\n\n        const bodyElement = document.body;\n        bodyElement.innerHTML = '';\n        bodyElement.style.visibility = 'visible';\n        this.checkAddDefaultPopinButton();\n\n        /*\n        * This seems a bit pointless, but actually causes a reflow/re-evaluation getting around\n        * slickgrid's \"Cannot find stylesheet.\" bug in chrome\n        */\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const x = document.body.offsetHeight;\n    }\n    /**\n     * Will add button if not popinOnClose specified in settings\n     * @returns true if added otherwise false\n     */\n    checkAddDefaultPopinButton(): boolean {\n        if (this.layoutConfig.settings.popInOnClose) {\n            return false;\n        } else {\n            const popInButtonElement = document.createElement('div');\n            popInButtonElement.classList.add(DomConstants.ClassName.Popin);\n            popInButtonElement.setAttribute('title', this.layoutConfig.header.dock);\n            const iconElement = document.createElement('div');\n            iconElement.classList.add(DomConstants.ClassName.Icon);\n            const bgElement = document.createElement('div');\n            bgElement.classList.add(DomConstants.ClassName.Bg);\n            popInButtonElement.appendChild(iconElement);\n            popInButtonElement.appendChild(bgElement);\n            popInButtonElement.addEventListener('click', () => this.emit('popIn'));\n            document.body.appendChild(popInButtonElement);\n            return true;\n        }\n    }\n\n    /** @internal */\n    override bindComponent(container: ComponentContainer, itemConfig: ResolvedComponentItemConfig): ComponentContainer.BindableComponent {\n        if (this.bindComponentEvent !== undefined) {\n            const bindableComponent = this.bindComponentEvent(container, itemConfig);\n            return bindableComponent;\n        } else {\n            if (this.getComponentEvent !== undefined) {\n                return {\n                    virtual: false,\n                    component: this.getComponentEvent(container, itemConfig),\n                }\n            } else {\n                // There is no component registered for this type, and we don't have a getComponentEvent defined.\n                // This might happen when the user pops out a dialog and the component types are not registered upfront.\n                const text = i18nStrings[I18nStringId.ComponentTypeNotRegisteredAndBindComponentEventHandlerNotAssigned];\n                const message = `${text}: ${JSON.stringify(itemConfig)}`\n                throw new BindError(message);\n            }\n        }\n    }\n\n    /** @internal */\n    override unbindComponent(container: ComponentContainer, virtual: boolean, component: ComponentContainer.Component | undefined): void {\n        if (this.unbindComponentEvent !== undefined) {\n            this.unbindComponentEvent(container);\n        } else {\n            if (!virtual && this.releaseComponentEvent !== undefined) {\n                if (component === undefined) {\n                    throw new UnexpectedUndefinedError('VCUCRCU333998');\n                } else {\n                    this.releaseComponentEvent(container, component);\n                }\n            }\n        }\n    }\n}\n\n/** @public */\nexport namespace VirtualLayout {\n    /**\n     * @deprecated Use virtual components with {@link (VirtualLayout:class).bindComponentEvent} and\n     * {@link (VirtualLayout:class).unbindComponentEvent} events.\n     */\n    export type GetComponentEventHandler =\n        (this: void, container: ComponentContainer, itemConfig: ResolvedComponentItemConfig) => ComponentContainer.Component;\n    /**\n     * @deprecated Use virtual components with {@link (VirtualLayout:class).bindComponentEvent} and\n     * {@link (VirtualLayout:class).unbindComponentEvent} events.\n     */\n    export type ReleaseComponentEventHandler =\n        (this: void, container: ComponentContainer, component: ComponentContainer.Component) => void;\n\n    export type BindComponentEventHandler =\n        (this: void, container: ComponentContainer, itemConfig: ResolvedComponentItemConfig) => ComponentContainer.BindableComponent;\n    export type UnbindComponentEventHandler =\n        (this: void, container: ComponentContainer) => void;\n\n    export type BeforeVirtualRectingEvent = (this: void) => void;\n\n    /** @internal\n     * Veriable to hold the state whether we already checked if we are running in a sub window.\n     * Fixes popout and creation of nested golden-layouts.\n     */\n    let subWindowChecked = false;\n\n    /** @internal */\n    export function createLayoutManagerConstructorParameters(configOrOptionalContainer: LayoutConfig | HTMLElement | undefined,\n        containerOrBindComponentEventHandler?: HTMLElement |  VirtualLayout.BindComponentEventHandler):\n        LayoutManager.ConstructorParameters\n    {\n        const windowConfigKey = subWindowChecked ? null : new URL(document.location.href).searchParams.get('gl-window');\n        subWindowChecked = true;\n        const isSubWindow = windowConfigKey !== null;\n\n        let containerElement: HTMLElement | undefined;\n        let config: LayoutConfig | undefined;\n        if (windowConfigKey !== null) {\n            const windowConfigStr = localStorage.getItem(windowConfigKey);\n            if (windowConfigStr === null) {\n                throw new Error('Null gl-window Config');\n            }\n            localStorage.removeItem(windowConfigKey);\n            const minifiedWindowConfig = JSON.parse(windowConfigStr) as ResolvedPopoutLayoutConfig;\n            const resolvedConfig = ResolvedLayoutConfig.unminifyConfig(minifiedWindowConfig);\n            config = LayoutConfig.fromResolved(resolvedConfig)\n\n            if (configOrOptionalContainer instanceof HTMLElement) {\n                containerElement = configOrOptionalContainer;\n            }\n        } else {\n            if (configOrOptionalContainer === undefined) {\n                config = undefined;\n            } else {\n                if (configOrOptionalContainer instanceof HTMLElement) {\n                    config = undefined;\n                    containerElement = configOrOptionalContainer;\n                } else {\n                    // backwards compatibility\n                    config = configOrOptionalContainer;\n                }\n            }\n\n            if (containerElement === undefined) {\n                if (containerOrBindComponentEventHandler instanceof HTMLElement) {\n                    containerElement = containerOrBindComponentEventHandler;\n                }\n            }\n        }\n\n        return {\n            constructorOrSubWindowLayoutConfig: config,\n            isSubWindow,\n            containerElement,\n        };\n    }\n}\n", "import { LayoutConfig } from './config/config';\nimport { ResolvedComponentItemConfig } from './config/resolved-config';\nimport { ComponentContainer } from './container/component-container';\nimport { ApiError, BindError } from './errors/external-error';\nimport { AssertError, UnexpectedUndefinedError } from './errors/internal-error';\nimport { I18nStringId, i18nStrings } from './utils/i18n-strings';\nimport { JsonValue, LogicalZIndex } from './utils/types';\nimport { deepExtendValue, ensureElementPositionAbsolute, numberToPixels, setElementDisplayVisibility, setElementHeight, setElementWidth } from './utils/utils';\nimport { VirtualLayout } from './virtual-layout';\n\n/** @public */\nexport class GoldenLayout extends VirtualLayout {\n    /** @internal */\n    private _componentTypesMap = new Map<string, GoldenLayout.ComponentInstantiator>();\n    /** @internal */\n    private _getComponentConstructorFtn: GoldenLayout.GetComponentConstructorCallback;\n\n    /** @internal */\n    private _registeredComponentMap = new Map<ComponentContainer, ComponentContainer.Component>();\n    /** @internal */\n    private _virtuableComponentMap = new Map<ComponentContainer, GoldenLayout.VirtuableComponent>();\n    /** @internal */\n    private _goldenLayoutBoundingClientRect: DOMRect;\n\n    /** @internal */\n    private _containerVirtualRectingRequiredEventListener =\n        (container: ComponentContainer, width: number, height: number) => this.handleContainerVirtualRectingRequiredEvent(container, width, height);\n    /** @internal */\n    private _containerVirtualVisibilityChangeRequiredEventListener =\n        (container: ComponentContainer, visible: boolean) => this.handleContainerVirtualVisibilityChangeRequiredEvent(container, visible);\n    /** @internal */\n    private _containerVirtualZIndexChangeRequiredEventListener =\n        (container: ComponentContainer, logicalZIndex: LogicalZIndex, defaultZIndex: string) =>\n            this.handleContainerVirtualZIndexChangeRequiredEvent(container, logicalZIndex, defaultZIndex);\n\n    /**\n     * @param container - A Dom HTML element. Defaults to body\n     * @param bindComponentEventHandler - Event handler to bind components\n     * @param bindComponentEventHandler - Event handler to unbind components\n     * If bindComponentEventHandler is defined, then constructor will be determinate. It will always call the init()\n     * function and the init() function will always complete. This means that the bindComponentEventHandler will be called\n     * if constructor is for a popout window. Make sure bindComponentEventHandler is ready for events.\n     */\n    constructor(\n        container?: HTMLElement,\n        bindComponentEventHandler?: VirtualLayout.BindComponentEventHandler,\n        unbindComponentEventHandler?: VirtualLayout.UnbindComponentEventHandler,\n    );\n    /** @deprecated specify layoutConfig in {@link (LayoutManager:class).loadLayout} */\n    constructor(config: LayoutConfig, container?: HTMLElement);\n    /** @internal */\n    constructor(configOrOptionalContainer: LayoutConfig | HTMLElement | undefined,\n        containerOrBindComponentEventHandler?: HTMLElement | VirtualLayout.BindComponentEventHandler,\n        unbindComponentEventHandler?: VirtualLayout.UnbindComponentEventHandler,\n    ) {\n        super(configOrOptionalContainer, containerOrBindComponentEventHandler, unbindComponentEventHandler, true);\n        // we told VirtualLayout to not call init() (skipInit set to true) so that Golden Layout can initialise its properties before init is called\n        if (!this.deprecatedConstructor) {\n            this.init();\n        }\n    }\n\n    /**\n     * Register a new component type with the layout manager.\n     *\n     * @deprecated See {@link https://stackoverflow.com/questions/40922531/how-to-check-if-a-javascript-function-is-a-constructor}\n     * instead use {@link (GoldenLayout:class).registerComponentConstructor}\n     * or {@link (GoldenLayout:class).registerComponentFactoryFunction}\n     */\n    registerComponent(name: string,\n        componentConstructorOrFactoryFtn: GoldenLayout.ComponentConstructor | GoldenLayout.ComponentFactoryFunction,\n        virtual = false\n    ): void {\n        if (typeof componentConstructorOrFactoryFtn !== 'function') {\n            throw new ApiError('registerComponent() componentConstructorOrFactoryFtn parameter is not a function')\n        } else {\n            if (componentConstructorOrFactoryFtn.hasOwnProperty('prototype')) {\n                const componentConstructor = componentConstructorOrFactoryFtn as GoldenLayout.ComponentConstructor;\n                this.registerComponentConstructor(name, componentConstructor, virtual);\n            } else {\n                const componentFactoryFtn = componentConstructorOrFactoryFtn as GoldenLayout.ComponentFactoryFunction;\n                this.registerComponentFactoryFunction(name, componentFactoryFtn, virtual);\n            }\n        }\n    }\n\n    /**\n     * Register a new component type with the layout manager.\n     */\n    registerComponentConstructor(typeName: string, componentConstructor: GoldenLayout.ComponentConstructor, virtual = false): void {\n        if (typeof componentConstructor !== 'function') {\n            throw new Error(i18nStrings[I18nStringId.PleaseRegisterAConstructorFunction]);\n        }\n\n        const existingComponentType = this._componentTypesMap.get(typeName);\n\n        if (existingComponentType !== undefined) {\n            throw new BindError(`${i18nStrings[I18nStringId.ComponentIsAlreadyRegistered]}: ${typeName}`);\n        }\n\n        this._componentTypesMap.set(typeName, {\n                constructor: componentConstructor,\n                factoryFunction: undefined,\n                virtual,\n            }\n        );\n    }\n\n    /**\n     * Register a new component with the layout manager.\n     */\n    registerComponentFactoryFunction(typeName: string, componentFactoryFunction: GoldenLayout.ComponentFactoryFunction, virtual = false): void {\n        if (typeof componentFactoryFunction !== 'function') {\n            throw new BindError('Please register a constructor function');\n        }\n\n        const existingComponentType = this._componentTypesMap.get(typeName);\n\n        if (existingComponentType !== undefined) {\n            throw new BindError(`${i18nStrings[I18nStringId.ComponentIsAlreadyRegistered]}: ${typeName}`);\n        }\n\n        this._componentTypesMap.set(typeName, {\n                constructor: undefined,\n                factoryFunction: componentFactoryFunction,\n                virtual,\n            }\n        );\n    }\n\n    /**\n     * Register a component function with the layout manager. This function should\n     * return a constructor for a component based on a config.\n     * This function will be called if a component type with the required name is not already registered.\n     * It is recommended that applications use the {@link (VirtualLayout:class).getComponentEvent} and\n     * {@link (VirtualLayout:class).releaseComponentEvent} instead of registering a constructor callback\n     * @deprecated use {@link (GoldenLayout:class).registerGetComponentConstructorCallback}\n     */\n    registerComponentFunction(callback: GoldenLayout.GetComponentConstructorCallback): void {\n        this.registerGetComponentConstructorCallback(callback);\n    }\n\n    /**\n     * Register a callback closure with the layout manager which supplies a Component Constructor.\n     * This callback should return a constructor for a component based on a config.\n     * This function will be called if a component type with the required name is not already registered.\n     * It is recommended that applications use the {@link (VirtualLayout:class).getComponentEvent} and\n     * {@link (VirtualLayout:class).releaseComponentEvent} instead of registering a constructor callback\n     */\n    registerGetComponentConstructorCallback(callback: GoldenLayout.GetComponentConstructorCallback): void {\n        if (typeof callback !== 'function') {\n            throw new Error('Please register a callback function');\n        }\n\n        if (this._getComponentConstructorFtn !== undefined) {\n            console.warn('Multiple component functions are being registered.  Only the final registered function will be used.')\n        }\n\n        this._getComponentConstructorFtn = callback;\n    }\n\n    getRegisteredComponentTypeNames(): string[] {\n        const typeNamesIterableIterator = this._componentTypesMap.keys();\n        return Array.from(typeNamesIterableIterator);\n    }\n\n    /**\n     * Returns a previously registered component instantiator.  Attempts to utilize registered\n     * component type by first, then falls back to the component constructor callback function (if registered).\n     * If neither gets an instantiator, then returns `undefined`.\n     * Note that `undefined` will return if config.componentType is not a string\n     *\n     * @param config - The item config\n     * @public\n     */\n    getComponentInstantiator(config: ResolvedComponentItemConfig): GoldenLayout.ComponentInstantiator | undefined {\n        let instantiator: GoldenLayout.ComponentInstantiator | undefined;\n\n        const typeName = ResolvedComponentItemConfig.resolveComponentTypeName(config)\n        if (typeName !== undefined) {\n            instantiator = this._componentTypesMap.get(typeName);\n        }\n        if (instantiator === undefined) {\n            if (this._getComponentConstructorFtn !== undefined) {\n                instantiator = {\n                    constructor: this._getComponentConstructorFtn(config),\n                    factoryFunction: undefined,\n                    virtual: false,\n                }\n            }\n        }\n\n        return instantiator;\n    }\n\n    /** @internal */\n    override bindComponent(container: ComponentContainer, itemConfig: ResolvedComponentItemConfig): ComponentContainer.BindableComponent {\n        let instantiator: GoldenLayout.ComponentInstantiator | undefined;\n\n        const typeName = ResolvedComponentItemConfig.resolveComponentTypeName(itemConfig);\n        if (typeName !== undefined) {\n            instantiator = this._componentTypesMap.get(typeName);\n        }\n        if (instantiator === undefined) {\n            if (this._getComponentConstructorFtn !== undefined) {\n                instantiator = {\n                    constructor: this._getComponentConstructorFtn(itemConfig),\n                    factoryFunction: undefined,\n                    virtual: false,\n                }\n            }\n        }\n\n        let result: ComponentContainer.BindableComponent;\n        if (instantiator !== undefined) {\n            const virtual = instantiator.virtual;\n            // handle case where component is obtained by name or component constructor callback\n            let componentState: JsonValue | undefined;\n            if (itemConfig.componentState === undefined) {\n                componentState = undefined;\n            } else {\n                // make copy\n                componentState = deepExtendValue({}, itemConfig.componentState) as JsonValue;\n            }\n\n            let component: ComponentContainer.Component | undefined;\n            const componentConstructor = instantiator.constructor;\n            if (componentConstructor !== undefined) {\n                component = new componentConstructor(container, componentState, virtual);\n            } else {\n                const factoryFunction = instantiator.factoryFunction;\n                if (factoryFunction !== undefined) {\n                    component = factoryFunction(container, componentState, virtual);\n                } else {\n                    throw new AssertError('LMBCFFU10008');\n                }\n            }\n\n            if (virtual) {\n                if (component === undefined) {\n                    throw new UnexpectedUndefinedError('GLBCVCU988774');\n                } else {\n                    const virtuableComponent = component as GoldenLayout.VirtuableComponent;\n                    const componentRootElement = virtuableComponent.rootHtmlElement;\n                    if (componentRootElement === undefined) {\n                        throw new BindError(`${i18nStrings[I18nStringId.VirtualComponentDoesNotHaveRootHtmlElement]}: ${typeName}`);\n                    } else {\n                        ensureElementPositionAbsolute(componentRootElement);\n                        this.container.appendChild(componentRootElement);\n                        this._virtuableComponentMap.set(container, virtuableComponent);\n                        container.virtualRectingRequiredEvent = this._containerVirtualRectingRequiredEventListener;\n                        container.virtualVisibilityChangeRequiredEvent = this._containerVirtualVisibilityChangeRequiredEventListener;\n                        container.virtualZIndexChangeRequiredEvent = this._containerVirtualZIndexChangeRequiredEventListener;\n                    }\n                }\n            }\n\n            this._registeredComponentMap.set(container, component);\n\n            result = {\n                virtual: instantiator.virtual,\n                component,\n            };\n\n        } else {\n            // Use getComponentEvent\n            result = super.bindComponent(container, itemConfig);\n        }\n\n        return result;\n    }\n\n    /** @internal */\n    override unbindComponent(container: ComponentContainer, virtual: boolean, component: ComponentContainer.Component | undefined): void {\n        const registeredComponent = this._registeredComponentMap.get(container);\n        if (registeredComponent === undefined) {\n            super.unbindComponent(container, virtual, component); // was not created from registration so use virtual unbind events\n        } else {\n            const virtuableComponent = this._virtuableComponentMap.get(container);\n            if (virtuableComponent !== undefined) {\n                const componentRootElement = virtuableComponent.rootHtmlElement;\n                if (componentRootElement === undefined) {\n                    throw new AssertError('GLUC77743', container.title);\n                } else {\n                    this.container.removeChild(componentRootElement);\n                    this._virtuableComponentMap.delete(container);\n                }\n            }\n        }\n    }\n\n    override fireBeforeVirtualRectingEvent(count: number): void {\n        this._goldenLayoutBoundingClientRect = this.container.getBoundingClientRect();\n        super.fireBeforeVirtualRectingEvent(count);\n    }\n\n\n    /** @internal */\n    private handleContainerVirtualRectingRequiredEvent(container: ComponentContainer, width: number, height: number): void {\n        const virtuableComponent = this._virtuableComponentMap.get(container);\n        if (virtuableComponent === undefined) {\n            throw new UnexpectedUndefinedError('GLHCSCE55933');\n        } else {\n            const rootElement = virtuableComponent.rootHtmlElement;\n            if (rootElement === undefined) {\n                throw new BindError(i18nStrings[I18nStringId.ComponentIsNotVirtuable] + ' ' + container.title);\n            } else {\n                const containerBoundingClientRect = container.element.getBoundingClientRect();\n                const left = containerBoundingClientRect.left - this._goldenLayoutBoundingClientRect.left;\n                rootElement.style.left = numberToPixels(left);\n                const top = containerBoundingClientRect.top - this._goldenLayoutBoundingClientRect.top;\n                rootElement.style.top = numberToPixels(top);\n                setElementWidth(rootElement, width);\n                setElementHeight(rootElement, height);\n            }\n        }\n    }\n\n    /** @internal */\n    private handleContainerVirtualVisibilityChangeRequiredEvent(container: ComponentContainer, visible: boolean): void {\n        const virtuableComponent = this._virtuableComponentMap.get(container);\n        if (virtuableComponent === undefined) {\n            throw new UnexpectedUndefinedError('GLHCVVCRE55934');\n        } else {\n            const rootElement = virtuableComponent.rootHtmlElement;\n            if (rootElement === undefined) {\n                throw new BindError(i18nStrings[I18nStringId.ComponentIsNotVirtuable] + ' ' + container.title);\n            } else {\n                setElementDisplayVisibility(rootElement, visible);\n            }\n        }\n    }\n\n    /** @internal */\n    private handleContainerVirtualZIndexChangeRequiredEvent(container: ComponentContainer, logicalZIndex: LogicalZIndex, defaultZIndex: string) {\n        const virtuableComponent = this._virtuableComponentMap.get(container);\n        if (virtuableComponent === undefined) {\n            throw new UnexpectedUndefinedError('GLHCVZICRE55935');\n        } else {\n            const rootElement = virtuableComponent.rootHtmlElement;\n            if (rootElement === undefined) {\n                throw new BindError(i18nStrings[I18nStringId.ComponentIsNotVirtuable] + ' ' + container.title);\n            } else {\n                rootElement.style.zIndex = defaultZIndex;\n            }\n        }\n    }\n}\n\n/** @public */\nexport namespace GoldenLayout {\n    export interface VirtuableComponent {\n        rootHtmlElement: HTMLElement;\n    }\n\n    export type ComponentConstructor = new(container: ComponentContainer, state: JsonValue | undefined, virtual: boolean) => ComponentContainer.Component;\n    export type ComponentFactoryFunction = (container: ComponentContainer, state: JsonValue | undefined, virtual: boolean) => ComponentContainer.Component | undefined;\n    export type GetComponentConstructorCallback = (this: void, config: ResolvedComponentItemConfig) => ComponentConstructor;\n\n    export interface ComponentInstantiator {\n        constructor: ComponentConstructor | undefined;\n        factoryFunction: ComponentFactoryFunction | undefined;\n        virtual: boolean;\n    }\n}\n"],
  "mappings": "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",
  "names": ["I18nStrings", "StyleConstants", "WidthOrHeightPropertyName", "Side", "LogicalZIndex", "JsonValue", "ItemType", "ResponsiveMode", "SizeUnitEnum", "ConfigMinifier", "ResolvedItemConfig", "ResolvedHeaderedItemConfig", "Header", "ResolvedStackItemConfig", "ResolvedComponentItemConfig", "ResolvedRowOrColumnItemConfig", "ResolvedRootItemConfig", "ResolvedGroundItemConfig", "ResolvedLayoutConfig", "Settings", "createCopy", "Dimensions", "ResolvedPopoutLayoutConfig", "Window", "ItemConfig", "HeaderedItemConfig", "Header", "id", "StackItemConfig", "ComponentItemConfig", "RowOrColumnItemConfig", "RootItemConfig", "LayoutConfig", "Settings", "resolve", "Dimensions", "fromResolved", "PopoutLayoutConfig", "Window", "window", "EventEmitter", "window", "RowOrColumn", "document", "GroundItem", "Area", "document", "tabIndex", "Stack", "document", "DragSource", "EventHub", "location", "width", "height", "window", "LayoutManager", "document", "VirtualLayout"]
}
